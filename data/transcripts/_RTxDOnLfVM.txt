
[00:00:00.000 --> 00:00:07.440]   In this chapter of the Agents SDK course we are going to be taking a look at tools. Now for tools
[00:00:07.440 --> 00:00:15.180]   in Agents SDK there are various ways that we can use them. First we have pre-built tools so there is
[00:00:15.180 --> 00:00:22.780]   a small number of these pre-built tools that come with Agents SDK. They are OpenAI built and they
[00:00:22.780 --> 00:00:29.340]   allow us to do a few interesting things. Then there are of course custom tools so we can define our
[00:00:29.340 --> 00:00:38.080]   own tools and use those as well. So in this chapter we'll work through those and take a look at how we
[00:00:38.080 --> 00:00:46.580]   use tools and how we can best use tools in Agents SDK. So for this notebook I would recommend actually
[00:00:46.580 --> 00:00:53.360]   you can open this one in Colab or if you prefer run it locally. It is completely up to you. We of course
[00:00:53.360 --> 00:01:02.100]   will need the OpenAI API key unless you're using another provider. Although with another provider I will
[00:01:02.100 --> 00:01:10.840]   note that these pre-built tools will not work. So yeah you have to be using OpenAI models to use these. So there
[00:01:10.840 --> 00:01:19.580]   are a few of these pre-built tools from Agents SDK. Those include the Web Search tool, the File Search
[00:01:19.580 --> 00:01:24.580]   tool and Computer Use tool among others. And we're just going to take a quick look at the Web Search tool
[00:01:24.580 --> 00:01:32.320]   which we briefly use in the previous example. So when we're passing tools to our Agents, we define an
[00:01:32.320 --> 00:01:38.320]   Agent object, we pass the name instructions as we would usually do, we also pass a model as we would
[00:01:38.320 --> 00:01:47.320]   usually do. But then we also provide tools. Okay and this is just a list of these function tool objects and
[00:01:47.320 --> 00:01:52.260]   we'll see that in a moment. Right now it's just a pre-built web search tool. Another thing to note
[00:01:52.260 --> 00:01:58.600]   here is that the Nano model is not recommended for tools. So you should use at least Mini ideally.
[00:01:58.600 --> 00:02:07.300]   Now we can see which tools an Agent object has access to by just looking at the tools attribute. And we'll
[00:02:07.300 --> 00:02:13.980]   see a list. In this case it's just a web search tool that we just defined. And as we usually would do,
[00:02:13.980 --> 00:02:22.920]   we use the runner object to run our Agent and get some results from there. So you can see the final
[00:02:22.920 --> 00:02:34.260]   output there. So that is today. And this all seems relatively recent. Now although the pre-built tools
[00:02:34.260 --> 00:02:41.500]   are, you know, they're really nice. It's nice to have those. In most cases I think the majority of tools
[00:02:41.500 --> 00:02:49.560]   we would be using are either defined through MCP or they are custom tools. Custom tools that we are
[00:02:49.560 --> 00:02:56.140]   building and we are defining within the framework. Now the way that we do that is we use this function
[00:02:56.140 --> 00:03:02.880]   tool object. Now the function tool, it's a decorator, we're using it here. Function tool used in this way
[00:03:02.880 --> 00:03:08.820]   converts our tool here which is just fetching the time and it's just returning the time for us. So we might
[00:03:08.820 --> 00:03:16.200]   use this in this scenario that we need to be able to tell our LLM or the LLM needs to be able to check
[00:03:16.200 --> 00:03:22.320]   time. Maybe the user says, hey, you know, what time is it right now? Or how many days is it until
[00:03:22.320 --> 00:03:32.380]   Christmas, right? In this case the LLM might go and use a fetch time tool. You may also just insert time
[00:03:32.380 --> 00:03:39.720]   directly into your system prompt if this is something where you're expecting your agent to be like time
[00:03:39.720 --> 00:03:47.100]   aware like a lot of the time or you can just give it all to use. It depends.
[00:03:47.100 --> 00:03:55.060]   So in this case we're just going to define a function tool for our model to fetch the time.
[00:03:55.060 --> 00:04:01.440]   Now one thing, if we don't set the name overrider here, this is optional, right? So we can just do,
[00:04:01.440 --> 00:04:09.520]   you know, without that, we could just do function tool. But in this case, the function tool name
[00:04:09.520 --> 00:04:16.440]   as provided to our LLM will be fetch time. Alternatively, if you want to give it an actual
[00:04:16.440 --> 00:04:22.720]   name or a different name to what the function is called, you can do that. So you just use this name
[00:04:22.720 --> 00:04:30.760]   override parameter. I believe also that the name here cannot be, it needs to follow like a lowercase
[00:04:30.760 --> 00:04:38.420]   with underscores format. So let's just try that because I don't quite remember. Okay. You can see
[00:04:38.420 --> 00:04:44.320]   if we do that, if we don't format that name correctly, we're going to get this. So invalid tool's name
[00:04:44.320 --> 00:04:49.500]   string does not match pattern. Okay. And it tells you here, this is the pattern we're allowed.
[00:04:49.500 --> 00:04:55.740]   So we're allowed to have hyphens. We're allowed, we are actually allowed uppercase. So we're allowed
[00:04:55.740 --> 00:05:06.280]   uppercase, lowercase and numbers or underscores. Okay. So that's good to know. So we could, if we wanted
[00:05:06.280 --> 00:05:12.260]   to, we could just do something like this. That should work, but I'll revert it to what we had before.
[00:05:12.260 --> 00:05:21.640]   Okay. Now we can just confirm that this is a function tool object. And you see, yes, our fetch time
[00:05:21.640 --> 00:05:27.160]   function is in fact a function tool object. That's great. That means, that means our decorator worked
[00:05:27.160 --> 00:05:33.140]   as expected. And because it's a function tool object, that means we can, we have these specific
[00:05:33.140 --> 00:05:39.680]   attributes that we can pull out. So we can get the name, which you'll see a moment ago,
[00:05:39.680 --> 00:05:45.960]   I modified this. Let's run this again. And we'll see that it's now our underscore name there or a valid
[00:05:45.960 --> 00:05:52.600]   name. We can see the description. Hey, that's weird. Where did we, where did we set that? So let's come
[00:05:52.600 --> 00:05:57.240]   back up a little bit and we can see that the description is being pulled from the dark string. So
[00:05:57.240 --> 00:06:05.080]   this dark string here is actually pretty important. It is in here that you described your LLM how and when
[00:06:05.080 --> 00:06:13.660]   it should use a particular tool. Okay. So it's important that you, that you use this and make sure
[00:06:13.660 --> 00:06:19.100]   that you describe, right? In this scenario, this is a very simple scenario. So it doesn't, you know,
[00:06:19.100 --> 00:06:25.200]   we just write something simple, but for example, web search in your dark string here, you should be
[00:06:25.200 --> 00:06:30.820]   telling your LLM, look, this is a web search tool you should use, or you should provide as much useful
[00:06:30.820 --> 00:06:37.240]   context as possible in your search query. This is in natural language. If it's a, depending on what
[00:06:37.240 --> 00:06:43.100]   web search engine you're using, right? So you can give the LLM instructions on how to best use your tool
[00:06:43.100 --> 00:06:48.860]   within this dark string. That, that is an important thing. You should always do that. Then we can also
[00:06:48.860 --> 00:06:55.600]   check the parameters. So parameters here, we can see, okay, this function, terrible example, it doesn't
[00:06:55.600 --> 00:07:00.480]   have any parameters. So we're going to see, okay, there's no required parameters. There's just nothing
[00:07:00.480 --> 00:07:08.960]   in here. So that's fine. We're going to see later a tool with parameters. Okay. So we have our output
[00:07:08.960 --> 00:07:15.700]   class here. We don't necessarily need to use this, but this is, this allows us to do structured output.
[00:07:16.120 --> 00:07:25.080]   I'm going to run without this first and I'm going to switch to using it. So do this and let's just
[00:07:25.080 --> 00:07:29.000]   run this and see, see what we get. Okay. So something happened.
[00:07:29.000 --> 00:07:37.780]   Let's take a look. Okay. So we've got this. The current time is this. Now the, what I want to show you
[00:07:37.780 --> 00:07:43.920]   with that output class is that you can also structure your output. So in this, this is a,
[00:07:43.920 --> 00:07:51.140]   you know, we're adding a lot of complexity to a very simple use case here, but it's good for
[00:07:51.140 --> 00:07:58.440]   demoing all of this. We want our response. Okay. As we just got, that's just our response here. But I
[00:07:58.440 --> 00:08:05.580]   also want the LM to tell me why did it do what it did. Okay. So the LM is just going to say, okay,
[00:08:05.580 --> 00:08:11.400]   I use the fetch current time tool because the user asked about the current time. So I needed to do
[00:08:11.400 --> 00:08:18.280]   that. Right. So we should see something like that. So yeah, we define that both of these outputs are
[00:08:18.280 --> 00:08:26.300]   strings. You may also, I don't know, let's say we want like a confidence score, for example,
[00:08:26.300 --> 00:08:32.800]   that could be a float. Uh, yeah, you can see, thank you copilot for writing that for me. You can see
[00:08:32.800 --> 00:08:38.040]   the confidence here. We have our flow. This is a confidence level in its response from zero to one.
[00:08:38.040 --> 00:08:44.920]   So that can actually be a pretty useful thing to, to include as well in general. So yeah, this is
[00:08:44.920 --> 00:08:52.340]   structured output that we are providing. And we provide that via the output type parameter as
[00:08:52.340 --> 00:08:57.680]   before. We're going to use that runner object. And then let's see what final output is because now we
[00:08:57.680 --> 00:09:03.740]   have multiple outputs. So it's going to be a bit different. Okay. We can see output class, the
[00:09:03.740 --> 00:09:10.820]   response here, and we can see the approach taken. I fetch current time using systems time query function
[00:09:10.820 --> 00:09:16.980]   to provide you with the exact and update time. Okay. That's great. And then we see that is the output
[00:09:16.980 --> 00:09:22.080]   class that we defined that that object. So we can also go in there. If we want to access each one of
[00:09:22.080 --> 00:09:33.240]   those specific values, we can go in like that. Okay. So we come to here. No, I already printed it here.
[00:09:33.240 --> 00:09:40.660]   Nevermind. We can print it again. Okay. And we can also use the function tool object here as well.
[00:09:40.660 --> 00:09:48.840]   So, you know, we can do that with Pydantic, for example. This can be useful if you are wanting to
[00:09:48.840 --> 00:09:56.260]   define a particular structure for the input. So you can see here in this example, we have these
[00:09:56.260 --> 00:10:01.940]   function args. We're going to be using these function args in a tool, which is just going to
[00:10:01.940 --> 00:10:08.680]   multiply two numbers together. Again, super simple example, but nonetheless, really simple example.
[00:10:08.680 --> 00:10:12.640]   We have the description for that. So this is the, you know, where we had the dark string before,
[00:10:12.640 --> 00:10:22.580]   but then we also have this params JSON schema, right? Params JSON schema is consuming what we have up here
[00:10:22.580 --> 00:10:28.500]   and using that to describe to our LM what the input parameters are. And this is really useful because
[00:10:28.500 --> 00:10:33.940]   by default, we can't do that. So if we, we just define a function and we decorate it with function
[00:10:33.940 --> 00:10:43.080]   tool, we can't specify in that function descriptions for each and every parameter, right? So if you have
[00:10:43.080 --> 00:10:47.960]   a set of parameters you need to describe, this is really useful for those more complex use cases.
[00:10:47.960 --> 00:10:55.260]   You can describe everything in much more detail using this approach, which is, it's pretty good.
[00:10:55.540 --> 00:11:01.880]   And you can also validate things as they're coming in as well. So that's great. We, we do still need to,
[00:11:01.880 --> 00:11:08.680]   of course, define our function that is going to be used. So we have this multiply numbers function here,
[00:11:08.680 --> 00:11:16.480]   and we would just pass that down here to the on invoke tool. Okay. So we have that. Now we can come
[00:11:16.480 --> 00:11:23.860]   down and just see, as we did before, we can see everything that we have defined. So we get name
[00:11:23.860 --> 00:11:30.520]   and description as before. Okay. We define these a different way before, but the outcome is the same.
[00:11:30.520 --> 00:11:36.940]   Okay. So this is the, within that function tool object, these are those attributes. And then we also have
[00:11:36.940 --> 00:11:40.960]   this parameter JSON schema. This one is a little bit different because now we have parameters. Okay.
[00:11:41.040 --> 00:11:47.800]   So within the properties dictionary here, before this was empty because we had no parameters. Now there are parameters.
[00:11:47.800 --> 00:11:55.780]   We have X and Y. And also within those parameters, we have descriptions. Okay. So this is all getting sent to the LLM.
[00:11:55.780 --> 00:12:01.380]   The LLM now knows exactly what each one of these parameters is for. Of course, in this example,
[00:12:01.380 --> 00:12:08.480]   this is a very basic example, it's not really needed, but for more complicated tools, this is,
[00:12:08.480 --> 00:12:15.220]   this can be very helpful. We also have this required parameter down here. Now this is saying, okay,
[00:12:15.220 --> 00:12:19.900]   X and Y are both required parameters for this function. So the LLM knows it must generate both
[00:12:19.900 --> 00:12:25.400]   of these to use the tool correctly. What may happen, right? You, you might have optional parameters.
[00:12:25.900 --> 00:12:31.800]   So let's just set one of these to optional very quickly. Let's say, you know, we don't need
[00:12:31.800 --> 00:12:39.780]   X for whatever reason. So we'll run this. We'll come down to here and we'll now see if we make the
[00:12:39.780 --> 00:12:44.320]   scrollable, we'll see it required is now just Y. We don't need X. It's an optional parameter,
[00:12:44.320 --> 00:12:52.000]   but X is still provided within our schema here. So it's still described. The LLM still knows it can use
[00:12:52.000 --> 00:12:56.820]   X if it needs to, but it's an optional parameter. So it doesn't have to, which can be really used.
[00:12:56.820 --> 00:13:03.940]   Well, you come and need that in, in many tools. So we have that. Um, we, of course, in this scenario,
[00:13:03.940 --> 00:13:11.440]   we are definitely going to keep X as a required parameter. So rerun those. So let's just go down
[00:13:11.440 --> 00:13:21.060]   here and run our new query. So we're saying we want to multiply 3.41 by 7.2. Let's see what we get here.
[00:13:21.060 --> 00:13:25.940]   We can, uh, we can, well, we, we're going to get an object out of this. I'll just show you that very
[00:13:25.940 --> 00:13:34.340]   quickly. So final outputs. That's because we, we set our output class again down here and we can see
[00:13:34.340 --> 00:13:41.880]   response and approach taken. And we'll just print both of those out a little more nicely here. Okay.
[00:13:41.880 --> 00:13:48.460]   So that's pretty cool. Now the very last thing we'll, we'll take a quick look at here. We will cover this
[00:13:48.460 --> 00:13:56.060]   in a little more, a little more detail later. We want to look at agents as tools. So in agents SDK,
[00:13:56.060 --> 00:14:03.920]   we can use handoffs and agents as tools as ways to handle multi-agent systems. Now agents as tools
[00:14:03.920 --> 00:14:11.220]   is what it sounds like. You define an agent and then you actually just provide that agent as a tool for
[00:14:11.220 --> 00:14:19.460]   another agent. So in this example, kind of a, again, silly example, because you would just use the tools
[00:14:19.460 --> 00:14:26.260]   directly, but nonetheless, in this example, we're going to have our multiply agent, which has access to the
[00:14:26.260 --> 00:14:33.860]   multiply tool. And then we also have a time agent, which has access to the fetch time tool. In reality, it's, you would
[00:14:33.860 --> 00:14:41.460]   probably use both of these as more like, okay, this is my social media agent. It is the agent that is going
[00:14:41.460 --> 00:14:50.020]   to read all of my social media things and generate posts for me or make posts for me. And then maybe we
[00:14:50.020 --> 00:14:55.700]   have like a writer agent, which has been prompted with all this, you know, writing goodness and maybe can
[00:14:55.700 --> 00:15:03.220]   reference, you know, our past materials to generate a article or social media post or whatever. Right.
[00:15:03.220 --> 00:15:09.380]   And those two agents would work in tandem to, you know, like read, okay, what, what should we talk
[00:15:09.380 --> 00:15:15.700]   about? I'm going to generate a post and, you know, post it out and, you know, just generate loads of AI
[00:15:15.700 --> 00:15:23.060]   slop for everyone to scroll past as they're on their, on X or LinkedIn or whatever else. Right. So,
[00:15:23.860 --> 00:15:29.860]   you know, you might want to use it or not for, for that. This example is a little silly in that,
[00:15:29.860 --> 00:15:34.900]   yeah, we would just use like, you probably won't even use these as tools a lot of the time,
[00:15:34.900 --> 00:15:43.060]   but nonetheless, this is how it works. So coming down here, we've created our two tool agents or sub
[00:15:43.060 --> 00:15:47.540]   agents, however you want to call them. And then we're also going to create this orchestra agent.
[00:15:47.540 --> 00:15:52.420]   And this is the kind of like the controlling agent. So when you're using agents as tools,
[00:15:52.420 --> 00:15:58.180]   you do need like a top level agent. And we actually don't need to provide this information
[00:15:58.180 --> 00:16:04.500]   here. We can remove that. So it's just saying, okay, you're an orchestra agent. You're going to
[00:16:04.500 --> 00:16:10.100]   do some stuff. And then we have these two tools, which are agents, right? So we just write the
[00:16:10.100 --> 00:16:16.180]   multiply agent or the agent name as tool. Then we provide the tool name. So as you know,
[00:16:16.180 --> 00:16:21.380]   how do we call this and the description for it as well, let's go ahead and let's, let's put all this
[00:16:21.380 --> 00:16:28.100]   together. Let's run and we'll say, what time is it? Now, when we're using agents and tools, just remember
[00:16:28.100 --> 00:16:34.500]   that, okay, we have our orchestra agent that is going to say, I want to use the time agent. Time agent
[00:16:34.500 --> 00:16:40.260]   checks time, writes a response, takes it to the orchestra agent. Then the orchestra agent is going to write,
[00:16:40.260 --> 00:16:47.140]   it's going to read that response and then write the response to you. So it's a token heavy
[00:16:47.140 --> 00:16:53.780]   approach. Just bear that in mind. The, the handoffs are a bit lighter and better than we'll look at
[00:16:53.780 --> 00:17:02.020]   those pretty soon. So let's see what we got. And yes, you can see. Okay, cool. So we can take a quick
[00:17:02.020 --> 00:17:08.580]   look at our tracers to see what that looked like. So the, the multi-agent thing, you can see the two
[00:17:08.580 --> 00:17:14.660]   tools we use here. So go into there. There was two tools were actually the orchestra agent calling the
[00:17:14.660 --> 00:17:22.100]   fetch current time agent, and then the fetch current time agent calling the fetch current time tool. Okay.
[00:17:22.100 --> 00:17:28.580]   Again, I just want to emphasize that this is not the way that you should use sub agents,
[00:17:28.580 --> 00:17:37.380]   like all agents as tools in agents SDK. This is a very, very silly example. This is just to show you
[00:17:37.380 --> 00:17:45.940]   how it works. We'll see pretty soon more realistic examples, but for now, that is actually it. So we've
[00:17:45.940 --> 00:17:53.780]   covered tools and you know, how we, how we use tools, how we define tool, both built-in and the custom
[00:17:53.780 --> 00:18:01.380]   tools. And then we've also seen how we can use agents as tools. So that's it for this chapter.
[00:18:01.380 --> 00:18:06.660]   I will see you in the next one. Thanks.
[00:18:06.660 --> 00:18:20.260]   Bye.

