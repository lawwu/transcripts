
[00:00:00.000 --> 00:00:10.000]   So, Rachel and I started FastAI with this idea of making neural networks uncool again.
[00:00:10.000 --> 00:00:15.720]   It is a grand plan to be sure because currently they are terribly cool.
[00:00:15.720 --> 00:00:23.000]   But really there are some things that we want to see improve and that's why we're doing
[00:00:23.000 --> 00:00:24.680]   this course.
[00:00:24.680 --> 00:00:27.160]   We're actually not making any money out of this course.
[00:00:27.160 --> 00:00:33.440]   We're donating our fees both to the Diversity Fellowships that we're running and also to
[00:00:33.440 --> 00:00:35.680]   the Fred Hollows Foundation.
[00:00:35.680 --> 00:00:39.720]   I would like to briefly give a quick pitch for the Fred Hollows Foundation, for those
[00:00:39.720 --> 00:00:42.920]   of you who aren't aware of it.
[00:00:42.920 --> 00:00:48.840]   Because as you know, deep learning is fantastic for computer vision.
[00:00:48.840 --> 00:00:53.000]   It's basically allowing computers to see for the first time.
[00:00:53.000 --> 00:00:57.480]   What you might not realize is that there are something like 3 or 4 million people in the
[00:00:57.480 --> 00:01:02.320]   world who can't see because they have something called cataract blindness.
[00:01:02.320 --> 00:01:09.280]   Cataract blindness can be cured for $25 per eye.
[00:01:09.280 --> 00:01:14.200]   And actually the group of people who got that price down from thousands of dollars to $25
[00:01:14.200 --> 00:01:17.560]   was Fred Hollows, who was the Australian of the Year some years ago.
[00:01:17.560 --> 00:01:24.200]   He's passed away now, but his legacy is in this foundation where if you donate $25, you're
[00:01:24.200 --> 00:01:26.120]   giving somebody their sight back.
[00:01:26.120 --> 00:01:34.680]   So as you learn to teach computers how to see, Rachel and I are also donating our fees
[00:01:34.680 --> 00:01:36.720]   from this to helping humans to see.
[00:01:36.720 --> 00:01:40.120]   So we think that's a nice little touch.
[00:01:40.120 --> 00:01:44.840]   So we're doing this both to help the Fred Hollows Foundation, but more importantly to
[00:01:44.840 --> 00:01:49.680]   help something we care a lot about, which is making deep learning more accessible.
[00:01:49.680 --> 00:01:53.080]   It's currently terribly exclusive.
[00:01:53.080 --> 00:01:57.800]   As I'm sure you've noticed, resources for teaching it tend to be quite mathematically
[00:01:57.800 --> 00:01:58.800]   intensive.
[00:01:58.800 --> 00:02:04.320]   They really seem to be focused on a certain kind of ivory tower type audience.
[00:02:04.320 --> 00:02:11.640]   So we're trying to create training and examples which are for non-machine learning and math
[00:02:11.640 --> 00:02:18.680]   experts dealing with small data sets, kind of giving raw models of applications you can
[00:02:18.680 --> 00:02:19.680]   develop quickly.
[00:02:19.680 --> 00:02:25.220]   And today we're going to see how to create a real useful piece of deep learning code
[00:02:25.220 --> 00:02:28.880]   in seven lines of code.
[00:02:28.880 --> 00:02:36.000]   We want to get to the point where it's easy for domain experts to work with deep learning.
[00:02:36.000 --> 00:02:39.720]   There are a lot of domain experts here, whether you're working with getting satellites in
[00:02:39.720 --> 00:02:45.840]   the air or whether you're working with analyzing the results of chemical studies or whether
[00:02:45.840 --> 00:02:51.000]   you're analyzing fraud at a bank, and I know all those people here in this audience, you
[00:02:51.000 --> 00:02:56.280]   are domain experts that we want to enable to use deep learning.
[00:02:56.280 --> 00:03:01.960]   At this stage, the audience for this course is coders, because that's as far as we think
[00:03:01.960 --> 00:03:03.280]   we can get at this point.
[00:03:03.280 --> 00:03:06.840]   We don't need you to be a math expert, but we do need you to be coders, and I know all
[00:03:06.840 --> 00:03:11.120]   of you have been told of that prerequisite.
[00:03:11.120 --> 00:03:15.560]   With your help, we can get to the point where non-coders will also be able to participate
[00:03:15.560 --> 00:03:16.920]   in this.
[00:03:16.920 --> 00:03:23.120]   The reason why we care about this is that there are problems like improving agricultural
[00:03:23.120 --> 00:03:27.600]   yields in the developing world, or making medical diagnostics available to those who
[00:03:27.600 --> 00:03:28.960]   don't have them, or so forth.
[00:03:28.960 --> 00:03:33.120]   These are things that can be solved with deep learning, but they're not going to be solved
[00:03:33.120 --> 00:03:37.960]   by people who are at these more ivory tower firms on the whole, because they're not really
[00:03:37.960 --> 00:03:39.960]   that familiar with these problems.
[00:03:39.960 --> 00:03:44.640]   The people who are familiar with these problems are the people who work with them every day.
[00:03:44.640 --> 00:03:48.160]   So for example, I've had quite a bit to do with a lot of these kinds of people, such
[00:03:48.160 --> 00:03:52.960]   as through the World Economic Forum, I know people who are trying to help cure TB and
[00:03:52.960 --> 00:03:58.640]   malaria, I know people who are trying to help with agricultural issues in the developing
[00:03:58.640 --> 00:04:03.320]   world and so forth, and these are all people who want to be using deep learning for things
[00:04:03.320 --> 00:04:10.400]   like analyzing crop imagery from satellites, or my most recent startup, which was analyzing
[00:04:10.400 --> 00:04:15.480]   radiological studies using deep learning to deal with things like the fact that in the
[00:04:15.480 --> 00:04:20.560]   entire continent of Africa, there are only seven pediatric radiologists.
[00:04:20.560 --> 00:04:28.600]   So most kids in Africa, in fact most countries in Africa, no kids have access to any radiologists
[00:04:28.600 --> 00:04:34.240]   and therefore have no access to any kind of modern image-based medical diagnostics.
[00:04:34.240 --> 00:04:38.440]   So these are some of the reasons that we're creating and running this course, and so we
[00:04:38.440 --> 00:04:42.840]   hope that the kind of feel of this community is going to be very different with the kind
[00:04:42.840 --> 00:04:46.280]   of feel of a lot of the deep learning type communities that have appeared before that
[00:04:46.280 --> 00:04:52.080]   have been all about let's trim 0.1% of this academic benchmark.
[00:04:52.080 --> 00:04:58.960]   This is going to be all about let's do shit that matters to people as quickly as possible.
[00:04:58.960 --> 00:05:02.400]   Sometimes to do that, we're going to have to push the state of the art of the research,
[00:05:02.400 --> 00:05:08.440]   and where that happens, we won't be afraid to show you the state of the art of the research.
[00:05:08.440 --> 00:05:13.680]   The idea is that by the end of Part 1 of this, you will be able to use all of the current
[00:05:13.680 --> 00:05:18.080]   best practices in the most important deep learning applications.
[00:05:18.080 --> 00:05:22.840]   If you stick around for Part 2, you'll be at the cutting edge of research in most of
[00:05:22.840 --> 00:05:24.700]   the most important research areas.
[00:05:24.700 --> 00:05:29.680]   So we're not dumbing this down by any means, we're just refocusing it.
[00:05:29.680 --> 00:05:37.880]   So the reason why we're excited about this is that we have now the three pieces of this
[00:05:37.880 --> 00:05:40.540]   universal learning machine.
[00:05:40.540 --> 00:05:50.380]   We now have the three critical pieces, like an infinitely flexible function, all-purpose
[00:05:50.380 --> 00:05:53.400]   parameter fitting, which is fast and scalable.
[00:05:53.400 --> 00:05:57.480]   So I'll tell you what I mean about these three pieces.
[00:05:57.480 --> 00:06:02.660]   The neural network is the function, we're going to learn about exactly how neural networks
[00:06:02.660 --> 00:06:03.660]   work.
[00:06:03.660 --> 00:06:09.760]   But the important thing about a neural network is that they are universal approximation machines.
[00:06:09.760 --> 00:06:13.640]   There's a mathematical proof, the universal approximation theorem, that we're going to
[00:06:13.640 --> 00:06:21.440]   learn all about which tells us that this kind of mathematical function is capable of handling
[00:06:21.440 --> 00:06:23.560]   any kind of problem we can throw at it.
[00:06:23.560 --> 00:06:28.480]   Whether that mathematical function be how do I translate English into Hungarian, or
[00:06:28.480 --> 00:06:33.340]   whether that mathematical function is how do I recognize pictures of cats, or whether
[00:06:33.340 --> 00:06:38.760]   that mathematical function is how do I identify unhealthy crops.
[00:06:38.760 --> 00:06:40.560]   It can handle any of these things.
[00:06:40.560 --> 00:06:47.160]   So with that mathematical function, the second thing you need is some way to fit the parameters
[00:06:47.160 --> 00:06:50.480]   of that function to your particular need.
[00:06:50.480 --> 00:06:55.320]   And there's a very simple way to do that, called gradient descent, and in particular
[00:06:55.320 --> 00:07:02.000]   something called backward propagation, which we will learn all about in this lesson and
[00:07:02.000 --> 00:07:03.000]   the next lesson.
[00:07:03.000 --> 00:07:09.880]   The important thing is that these two pieces together allow us to start with a function
[00:07:09.880 --> 00:07:15.340]   that is in theory capable of doing anything and turn it into a function that is in practice
[00:07:15.340 --> 00:07:20.840]   capable of doing whatever you want to do, as long as you have data that shows examples
[00:07:20.840 --> 00:07:23.040]   of what you want to do.
[00:07:23.040 --> 00:07:27.440]   The third piece, which has been missing until very recently, is being able to do this in
[00:07:27.440 --> 00:07:34.200]   a way that actually works with the amount of data that you have in the time you have available.
[00:07:34.200 --> 00:07:39.080]   And this has all changed thanks particularly to GPUs.
[00:07:39.080 --> 00:07:45.400]   So GPUs are graphics processing units, also called video cards, that's kind of an older
[00:07:45.400 --> 00:07:49.680]   term now, also called graphics cards.
[00:07:49.680 --> 00:07:55.360]   And these are devices inside your computer which were originally designed for playing
[00:07:55.360 --> 00:08:01.200]   computer games, so it's kind of like when you're looking at this alien from the left-hand
[00:08:01.200 --> 00:08:06.160]   side and there's light coming from above, what would each pixel, what pixel color do
[00:08:06.160 --> 00:08:08.240]   I need for each place?
[00:08:08.240 --> 00:08:14.400]   That's basically a whole bunch of linear algebra operations, a whole bunch of matrix products.
[00:08:14.400 --> 00:08:18.440]   It turns out that those are the same operations that we need for deep learning.
[00:08:18.440 --> 00:08:23.040]   And so because of the massive amount of money in the gaming industry that were thrown at
[00:08:23.040 --> 00:08:28.880]   this problem, we now have incredibly cheap, incredibly powerful cards for figuring out
[00:08:28.880 --> 00:08:31.000]   what aliens look like.
[00:08:31.000 --> 00:08:36.480]   And we can now use these, therefore, to figure out how to improve medical diagnostics in
[00:08:36.480 --> 00:08:37.640]   Africa.
[00:08:37.640 --> 00:08:41.920]   So it's a nice, handy little side effect.
[00:08:41.920 --> 00:08:48.120]   GPUs are in all of your computers, but not all of your computers are suitable for deep
[00:08:48.120 --> 00:08:49.620]   learning.
[00:08:49.620 --> 00:08:56.240]   And the reason is that programming a GPU to do deep learning really requires a particular
[00:08:56.240 --> 00:09:05.440]   kind of GPU, and in practice at the moment, it really requires a GPU from Nvidia because
[00:09:05.440 --> 00:09:12.600]   Nvidia GPUs support a kind of programming called CUDA, which we will be learning about.
[00:09:12.600 --> 00:09:19.080]   There are other GPUs that do support deep learning, but they're a bit of a pain, they're
[00:09:19.080 --> 00:09:21.000]   not very widely used.
[00:09:21.000 --> 00:09:23.920]   And so one of the things we're going to be doing is making sure that all of you guys
[00:09:23.920 --> 00:09:27.640]   have access to an Nvidia GPU.
[00:09:27.640 --> 00:09:34.840]   The good news is that in the last month, I think, Amazon has made available good quality
[00:09:34.840 --> 00:09:38.940]   Nvidia GPUs for everybody for the first time.
[00:09:38.940 --> 00:09:43.840]   They call them, very excitingly, their P2 instances.
[00:09:43.840 --> 00:09:48.480]   So I've spent quite a bit of the last month making sure that it's really easy to use these
[00:09:48.480 --> 00:09:52.960]   new P2 instances, I've given you all access to a script to do that.
[00:09:52.960 --> 00:09:58.880]   Unfortunately, we're still at the point where they don't trust people to use these correctly,
[00:09:58.880 --> 00:10:11.280]   so you have to ask permission to use these P2 instances.
[00:10:11.280 --> 00:10:19.160]   The Data Institute folks, for anybody who does not yet have an AWS P2 instance or their
[00:10:19.160 --> 00:10:27.880]   own GPU server, they are going to collect all of your AWS IDs and they have a contact at
[00:10:27.880 --> 00:10:32.840]   Amazon who will go through and get them all approved.
[00:10:32.840 --> 00:10:35.880]   They haven't made any promises, they've just said they will do what they can.
[00:10:35.880 --> 00:10:45.160]   So they're aware of how urgent that is, so if you email your AWS ID to Mindy, she will
[00:10:45.160 --> 00:10:46.160]   get that organized.
[00:10:46.160 --> 00:10:54.000]   We'll come back and look at AWS in more detail very shortly.
[00:10:54.000 --> 00:11:08.640]   The other thing that I've done is on the wiki, I've added some information about getting set-up.
[00:11:08.640 --> 00:11:12.640]   There is actually quite an interesting option called OVH.
[00:11:12.640 --> 00:11:15.840]   I'm sure by the time this is a MOOC, there's going to be a lot more, but this is the only
[00:11:15.840 --> 00:11:21.940]   company I've come across who will give you a by-the-month server with decent deep learning
[00:11:21.940 --> 00:11:24.920]   graphics cards on it.
[00:11:24.920 --> 00:11:27.080]   And it's only $200.
[00:11:27.080 --> 00:11:37.880]   And to give you a sense of how crazily cheap that is, if you go to their page for GPU servers,
[00:11:37.880 --> 00:11:47.360]   you'll see that this GTX 970 is $195 a month, and then their next cheapest is $2000 a month.
[00:11:47.360 --> 00:11:55.800]   It just so happens that this GTX 970 is ridiculously cheap for how good it is at deep learning.
[00:11:55.800 --> 00:12:00.200]   And the reason is that deep learning uses single precision arithmetic, in other words
[00:12:00.200 --> 00:12:02.880]   it uses less accurate arithmetic.
[00:12:02.880 --> 00:12:10.520]   These higher-end cards are designed for fluid simulations and tracking nuclear bonds and
[00:12:10.520 --> 00:12:13.720]   stuff like that that require double precision arithmetic.
[00:12:13.720 --> 00:12:20.760]   So it turns out these GTX 970s are only good for two things, games and deep learning.
[00:12:20.760 --> 00:12:25.520]   So the fact that you can get one of these things which has got two GTX 970s in, this
[00:12:25.520 --> 00:12:27.120]   is a really good deal.
[00:12:27.120 --> 00:12:33.040]   So one of the things you might consider doing in your team is maybe sharing the cost of
[00:12:33.040 --> 00:12:34.040]   one of these.
[00:12:34.040 --> 00:12:41.320]   $200 a month is pretty good compared to worrying about starting and stopping your 90 cents
[00:12:41.320 --> 00:12:51.160]   per hour AWS instance, particularly if AWS takes a while to say yes.
[00:12:51.160 --> 00:12:58.000]   So AWS, how many people here have used AWS before?
[00:12:58.000 --> 00:12:59.280]   Maybe a third or a half.
[00:12:59.280 --> 00:13:05.160]   So AWS is Amazon Web Services, I'm sure most of you if not all of you have heard of it.
[00:13:05.160 --> 00:13:10.400]   It's basically Amazon making their entire backend infrastructure available to everybody
[00:13:10.400 --> 00:13:12.280]   else to use.
[00:13:12.280 --> 00:13:16.740]   So rather than calling it a server, you get something they call an instance.
[00:13:16.740 --> 00:13:20.080]   You can think of it as basically being the same thing, it's a little computer that you
[00:13:20.080 --> 00:13:21.080]   get to use.
[00:13:21.080 --> 00:13:23.120]   In fact, not necessarily little.
[00:13:23.120 --> 00:13:30.360]   Some of their instances cost $14 or $15 an hour and give you like 8 or 16 graphics cards
[00:13:30.360 --> 00:13:33.960]   and dozens of CPUs and hundreds of gigabytes of RAM.
[00:13:33.960 --> 00:13:38.760]   The cool thing about AWS is that you can do a lot of work on their free instance.
[00:13:38.760 --> 00:13:57.520]   You can get a free instance called a t2.micro, and you can get everything set up and working
[00:13:57.520 --> 00:14:02.880]   on a really small dataset, and then you can switch it across, if you want to then run
[00:14:02.880 --> 00:14:08.320]   it on a big dataset, switch it across to one of these expensive things and have it run
[00:14:08.320 --> 00:14:11.040]   and finished within an hour or two.
[00:14:11.040 --> 00:14:17.440]   So that's one of the things that I really like about AWS.
[00:14:17.440 --> 00:14:21.400]   Microsoft also have something a lot like AWS called Azure.
[00:14:21.400 --> 00:14:25.120]   Unfortunately, their GPU instances are not yet publicly available.
[00:14:25.120 --> 00:14:29.000]   I've reached out to Microsoft to see if we can get access to those as well, and I'll
[00:14:29.000 --> 00:14:33.120]   let you know if we hear back from them.
[00:14:33.120 --> 00:14:38.400]   So one of the things that Rachel has done today is to start jotting down some of the
[00:14:38.400 --> 00:14:43.880]   common problems that people have found with their AWS installs.
[00:14:43.880 --> 00:14:51.280]   Getting AWS setup is a bit of a pain, so we've created a script that basically will do everything
[00:14:51.280 --> 00:14:52.280]   for you.
[00:14:52.280 --> 00:14:56.320]   But the nice thing is that that script is very easy for you to have a look at and see
[00:14:56.320 --> 00:14:58.120]   what's going on.
[00:14:58.120 --> 00:15:06.720]   So over time, you can get a sense of how AWS works.
[00:15:06.720 --> 00:15:12.600]   Behind the scenes, AWS is using their command line interface, or CLI, which we've given
[00:15:12.600 --> 00:15:16.640]   you instructions on how to install.
[00:15:16.640 --> 00:15:26.680]   As well as using the CLI, you can also go to console.aws.amazon.com and use this graphical
[00:15:26.680 --> 00:15:28.640]   interface.
[00:15:28.640 --> 00:15:33.640]   In general, I try to avoid using this graphical interface because everything takes so much
[00:15:33.640 --> 00:15:39.480]   longer, and it's so hard to get things to work repeatedly, but it can be nice to kind
[00:15:39.480 --> 00:15:43.280]   of look around and see how everything is put together.
[00:15:43.280 --> 00:15:47.480]   And again, we're going to come back and see a lot more about how to use the graphical
[00:15:47.480 --> 00:15:56.240]   interface here, as well as how to create and use scripts.
[00:15:56.240 --> 00:16:04.240]   So these are some of the pieces that we want to show you.
[00:16:04.240 --> 00:16:07.680]   I wanted to talk a bit more before we go into more detail about some of the interesting
[00:16:07.680 --> 00:16:10.240]   things that we've seen happening in deep learning recently.
[00:16:10.240 --> 00:16:17.400]   Perhaps the thing that I found most fascinating recently was when one of the leading folks
[00:16:17.400 --> 00:16:24.000]   at Google Brain presented this at a conference at Stanford which showed the use of deep learning
[00:16:24.000 --> 00:16:33.680]   at Google, and you can see this is just 2012 to today, or maybe two months ago.
[00:16:33.680 --> 00:16:38.520]   It's gone from nothing to over 2,500 projects.
[00:16:38.520 --> 00:16:42.880]   Now the reason I find this interesting is because this is what's going to happen to
[00:16:42.880 --> 00:16:49.360]   every organization and every industry over the next few months and few years.
[00:16:49.360 --> 00:16:54.480]   So they've kind of described how at Google it's getting used pretty much everywhere,
[00:16:54.480 --> 00:16:57.840]   and you can imagine probably if they redid this now today, two months later, it's probably
[00:16:57.840 --> 00:17:00.000]   going to be somewhere up here.
[00:17:00.000 --> 00:17:06.160]   So we kind of felt like it would be great to help kickstart lots of other organizations
[00:17:06.160 --> 00:17:09.240]   to start going up this ramp.
[00:17:09.240 --> 00:17:13.040]   That's another reason we're doing this.
[00:17:13.040 --> 00:17:18.760]   I really like looking at applications, and we started seeing some examples of these kind
[00:17:18.760 --> 00:17:23.640]   of like deep learning amateurs applications if you like.
[00:17:23.640 --> 00:17:26.320]   This is an example of it.
[00:17:26.320 --> 00:17:31.440]   What these guys did is they're not machine learning or deep learning experts, they downloaded
[00:17:31.440 --> 00:17:33.840]   a copy of Cafe.
[00:17:33.840 --> 00:17:35.880]   They ran a pre-existing model.
[00:17:35.880 --> 00:17:40.380]   This is what we're going to learn to do today, run a pre-existing model and use the features
[00:17:40.380 --> 00:17:43.360]   from that model to do something interesting.
[00:17:43.360 --> 00:17:46.480]   In their case, the thing they decided to do that was interesting was to take data that
[00:17:46.480 --> 00:17:51.000]   they already had, because they're skin lesion people, and analyze skin lesions.
[00:17:51.000 --> 00:17:56.480]   These are the different kinds of skin lesions that you can have, and they found, for example,
[00:17:56.480 --> 00:18:04.760]   that the previous best for finding this particular kind of skin lesion was 15.6% accuracy.
[00:18:04.760 --> 00:18:10.320]   When they did this off-the-shelf Cafe pre-existing model with a simple linear thing on top, they
[00:18:10.320 --> 00:18:13.560]   quadrupled it to 60%.
[00:18:13.560 --> 00:18:18.920]   So often when you take a deep learning model and use the very simple techniques we'll learn
[00:18:18.920 --> 00:18:26.720]   today, you can get extraordinarily upticks compared to non-deep learning approaches.
[00:18:26.720 --> 00:18:32.360]   Another example of that was looking at plant diseases, and there's been at least two groups
[00:18:32.360 --> 00:18:39.000]   that have done this in the last few months, and again, very successful results from people
[00:18:39.000 --> 00:18:44.120]   who are not deep learning or machine learning experts.
[00:18:44.120 --> 00:18:47.040]   Similar results in radio modulation.
[00:18:47.040 --> 00:18:53.020]   So these folks who are elect and computer engineering people found that they could double
[00:18:53.020 --> 00:18:57.800]   the effective coverage area of phone networks and stuff like that.
[00:18:57.800 --> 00:19:00.040]   So this is a massive result.
[00:19:00.040 --> 00:19:04.040]   And again, they used very simple approaches.
[00:19:04.040 --> 00:19:14.280]   It's being used in fashion, it's being used to diagnose heart disease by hedge fund analysts.
[00:19:14.280 --> 00:19:21.320]   So there's a particular post which I found really inspiring actually in trying to put
[00:19:21.320 --> 00:19:25.800]   this together, which is that Keras, which is the main library we'll be using, the author
[00:19:25.800 --> 00:19:31.080]   of that put together this post showing how to build powerful models using very little
[00:19:31.080 --> 00:19:32.080]   data.
[00:19:32.080 --> 00:19:37.120]   I really just wanted to give a shout out to this and say this work that Francois has been
[00:19:37.120 --> 00:19:40.960]   doing has been very important in a lot of the stuff that we're going to be learning
[00:19:40.960 --> 00:19:45.440]   over the next few classes.
[00:19:45.440 --> 00:19:52.320]   The basic environment we're going to be working in most of the time is the IPython notebook
[00:19:52.320 --> 00:19:55.400]   or the Jupyter notebook.
[00:19:55.400 --> 00:19:58.080]   So let me just kind of give you a sense of what's going on here.
[00:19:58.080 --> 00:20:11.280]   When you have a Jupyter notebook open, you will see something which is a good time to
[00:20:11.280 --> 00:20:14.440]   show you about starting and stopping AWS instances.
[00:20:14.440 --> 00:20:20.000]   So I just tried to go to my notebook on AWS and it says it can't be reached.
[00:20:20.000 --> 00:20:29.680]   So my guess is that if we go back to my console, you can see I have zero running instances,
[00:20:29.680 --> 00:20:33.200]   so I've got zero servers currently running.
[00:20:33.200 --> 00:20:38.520]   So if I click that, I will see all my servers.
[00:20:38.520 --> 00:20:45.320]   Normally I would have one P2 server or instance and one T2 because I used the free one for
[00:20:45.320 --> 00:20:52.840]   kind of getting everything set up and then used the paid one once everything is working.
[00:20:52.840 --> 00:20:56.240]   Because I've been fiddling around with things for this class, I just have the P2 at the
[00:20:56.240 --> 00:20:57.240]   moment.
[00:20:57.240 --> 00:21:04.640]   So having gone here, one way I could start this is by going start here.
[00:21:04.640 --> 00:21:10.800]   But like I said, I don't much like using this GUI for stuff because it's just so much easier
[00:21:10.800 --> 00:21:27.960]   to do things through the command line.
[00:21:27.960 --> 00:21:33.440]   So one of the things that I showed you guys that you could download today is a bunch of
[00:21:33.440 --> 00:21:38.000]   aliases for making starting and stopping AWS really quick.
[00:21:38.000 --> 00:21:44.640]   If you haven't got them yet, you can find links to them on Slack, or you can just go
[00:21:44.640 --> 00:21:51.240]   to Platform.ai/files and there's a bunch of different things here.
[00:21:51.240 --> 00:21:57.800]   This AWS alias.sh is a file that sets up these various aliases.
[00:21:57.800 --> 00:22:06.600]   So the easiest way to grab stuff on your AWS instance or server is to use something called
[00:22:06.600 --> 00:22:09.080]   WGet.
[00:22:09.080 --> 00:22:17.400]   I would right-click on this and choose Copy Link Address and then go WGet and paste in
[00:22:17.400 --> 00:22:24.760]   that and that will go ahead and download that file.
[00:22:24.760 --> 00:22:31.160]   Now I already had one so I created a copy of it.
[00:22:31.160 --> 00:22:34.960]   We can take a look at that file and you'll see it's basically a bunch of lines that say
[00:22:34.960 --> 00:22:45.280]   alias something equals something else and it's created AWS get P2, AWS get T2, AWS start,
[00:22:45.280 --> 00:22:47.800]   AWS SSH, AWS stop.
[00:22:47.800 --> 00:22:54.980]   I'm going to show you what these things do because I find them pretty convenient.
[00:22:54.980 --> 00:23:03.440]   Basically if I run AWS get P2, so first of all I say source AWS alias.sh and that just
[00:23:03.440 --> 00:23:05.360]   runs that file.
[00:23:05.360 --> 00:23:08.040]   In bash, that's how you just run a file.
[00:23:08.040 --> 00:23:14.840]   And that's now caused all of those names to appear as aliases to my system.
[00:23:14.840 --> 00:23:28.920]   So if I now run alias get P2, that's going to go ahead and ask Amazon for the ID of my
[00:23:28.920 --> 00:23:31.400]   P2 instance.
[00:23:31.400 --> 00:23:36.520]   Not only does it print it, but it's going to save it into a variable called instanceID
[00:23:36.520 --> 00:23:41.560]   and all of my other scripts will use $instanceID.
[00:23:41.560 --> 00:23:49.240]   So I now want to start that instance, so I just type AWS start and that's going to go
[00:23:49.240 --> 00:23:55.920]   ahead and do this equivalent thing of going to the GUI, right-clicking, choosing start.
[00:23:55.920 --> 00:24:04.840]   The other nice thing it does is it waits until the instance is running.
[00:24:04.840 --> 00:24:13.600]   And then at the end it asks the queries for the IP address and prints it out.
[00:24:13.600 --> 00:24:19.320]   Now this script that I have given you guys to set up these instances uses something called
[00:24:19.320 --> 00:24:24.680]   an elastic IP that actually keeps the same IP address every time you run it.
[00:24:24.680 --> 00:24:29.460]   So you should find that IP address stays the same, which makes it easier.
[00:24:29.460 --> 00:24:32.040]   So there is the IP.
[00:24:32.040 --> 00:24:44.800]   So I then have something called AWS SSH and AWS SSH will go ahead and SSH into that instance.
[00:24:44.800 --> 00:24:53.040]   So all it does is basically use the username ubuntu, because that's the default username
[00:24:53.040 --> 00:25:02.160]   for this kind of image on AWS, and then $instanceIP, so that's that IP address we just got.
[00:25:02.160 --> 00:25:08.600]   The other thing it does is to use the private key that was created when this was originally
[00:25:08.600 --> 00:25:09.600]   set up.
[00:25:09.600 --> 00:25:14.180]   Now in my case, I've actually moved that private key to be my default key, so I don't actually
[00:25:14.180 --> 00:25:15.180]   need that minus IP.
[00:25:15.180 --> 00:25:24.040]   So I just type ssh ubuntu at $instanceip, but you can just type aws-ssh, and you'll see
[00:25:24.040 --> 00:25:26.840]   bang, here we are.
[00:25:26.840 --> 00:25:37.720]   So we are now inside that AWS image.
[00:25:37.720 --> 00:25:43.400]   One of the handy things about AWS is they have these things called AMIs, Amazon Machine
[00:25:43.400 --> 00:25:51.080]   Images, and an AMI is basically a snapshot of a computer at a particular point in time.
[00:25:51.080 --> 00:25:57.120]   And you can start your own instance using a copy of that snapshot.
[00:25:57.120 --> 00:26:03.040]   So in the script I've given you guys, I've created and provided an AMI which has all
[00:26:03.040 --> 00:26:04.600]   the stuff we want installed.
[00:26:04.600 --> 00:26:09.800]   So that's why it is that when you use that script and log into it, you can start running
[00:26:09.800 --> 00:26:11.160]   things straight away.
[00:26:11.160 --> 00:26:12.700]   So let's do that right now.
[00:26:12.700 --> 00:26:17.500]   I've created a directory already for you called nvs for notebooks.
[00:26:17.500 --> 00:26:22.000]   So we can go ahead and type jupyter notebook.
[00:26:22.000 --> 00:26:28.640]   And this is how we ask Amazon to set up a jupyter notebook server for us.
[00:26:28.640 --> 00:26:33.480]   And when it's done, it says okay, the jupyter notebook is running at all IP addresses on
[00:26:33.480 --> 00:26:36.020]   your system, 8-8-8-8.
[00:26:36.020 --> 00:26:38.000]   So what is our IP address?
[00:26:38.000 --> 00:26:42.200]   Well, it told us up here when we started it, it's 52 blah blah blah.
[00:26:42.200 --> 00:26:51.340]   So I'm going to go to my instance and I'll go 52, 40, 116, 116, in my case, colon, and
[00:26:51.340 --> 00:26:55.800]   it told me that the port is 8-8-8-8, so colon 8-8-8-8.
[00:26:55.800 --> 00:27:04.000]   So I'm just typing in that here, press enter, and I put too many colons.
[00:27:04.000 --> 00:27:10.720]   That's better.
[00:27:10.720 --> 00:27:16.060]   I've set up a password and it's just dl_course.
[00:27:16.060 --> 00:27:19.460]   We can look later on at how to change that password if people want to, but it'd be handy
[00:27:19.460 --> 00:27:22.580]   to have a password there for everybody if you want to start looking at some of your
[00:27:22.580 --> 00:27:25.800]   own data.
[00:27:25.800 --> 00:27:34.680]   And actually by default, it's not going to show you anything, so I'm going to delete
[00:27:34.680 --> 00:27:35.680]   that.
[00:27:35.680 --> 00:27:42.760]   So now we can just go ahead and say new notebook, and just say python condor root.
[00:27:42.760 --> 00:27:50.280]   And this sets up a scientific computing environment for you where you can type python commands
[00:27:50.280 --> 00:27:51.520]   and get back responses.
[00:27:51.520 --> 00:27:54.520]   So 1 plus 1.
[00:27:54.520 --> 00:27:55.520]   There we go.
[00:27:55.520 --> 00:27:57.600]   It seems to be computing things correctly.
[00:27:57.600 --> 00:28:04.760]   So the basic idea here is that over there on Amazon, you have your server.
[00:28:04.760 --> 00:28:08.440]   It is running a program called Jupyter Notebook.
[00:28:08.440 --> 00:28:17.400]   Jupyter Notebook is causing a particular port which is 8-8-8-8 to be opened on that server,
[00:28:17.400 --> 00:28:25.200]   where if you access it, it then gives you access to this Jupyter Notebook environment.
[00:28:25.200 --> 00:28:31.880]   In your team, you guys can all use the same Jupyter Notebook if you want to, or you could
[00:28:31.880 --> 00:28:34.820]   run multiple Jupyter Notebooks on one machine.
[00:28:34.820 --> 00:28:36.840]   It's really pretty flexible.
[00:28:36.840 --> 00:28:47.480]   So now that I've created one, I could rename this, say, this is Jeremy's Notebook.
[00:28:47.480 --> 00:28:52.520]   And so then Rachel might come along and be like, oh, I want to run something as well.
[00:28:52.520 --> 00:29:00.560]   So she goes new and her computer, and it creates a whole new one over here.
[00:29:00.560 --> 00:29:09.080]   And she could save file, rename, Rachel's Notebook.
[00:29:09.080 --> 00:29:15.280]   So if I now go back here, you can see both of these notebooks are shown to be running.
[00:29:15.280 --> 00:29:20.200]   So the server is running multiple kernels, they're called.
[00:29:20.200 --> 00:29:24.080]   And you can see back here, it's saying "creating new notebook, kernel started".
[00:29:24.080 --> 00:29:26.280]   So each of those are totally separate.
[00:29:26.280 --> 00:29:38.920]   So from one of them, I say "name = Rachel", and in the other one, I say "name = Jeremy",
[00:29:38.920 --> 00:29:43.360]   and then over here, I say "name".
[00:29:43.360 --> 00:29:50.160]   You'll see that they are not in any way talking to each other, they're totally separate.
[00:29:50.160 --> 00:29:54.400]   So that's a super handy way to do work.
[00:29:54.400 --> 00:30:00.960]   The other nice thing is that you can not just type code, but you can also type markdown.
[00:30:00.960 --> 00:30:13.680]   So I could go to section, I want to talk about something here.
[00:30:13.680 --> 00:30:19.640]   And so as I do that, it allows me to mix and match information and code.
[00:30:19.640 --> 00:30:23.640]   And every piece of code that comes out, I can see where it came from.
[00:30:23.640 --> 00:30:28.260]   And it also, as you'll see, lets us put in visualizations and plots and so forth.
[00:30:28.260 --> 00:30:33.800]   So some of you may have come across this important concept called literate programming.
[00:30:33.800 --> 00:30:40.020]   Literate programming is the idea that as you code, you are documenting what you're doing
[00:30:40.020 --> 00:30:48.240]   in a very deep way, not just for others, but maybe more importantly for yourself.
[00:30:48.240 --> 00:30:52.380]   And so when you're doing data science work, work like a scientist.
[00:30:52.380 --> 00:30:57.560]   How many people here are in some form scientists or have been scientists?
[00:30:57.560 --> 00:31:03.280]   You guys will know the importance of your journal notebook.
[00:31:03.280 --> 00:31:08.400]   The greatest scientists, they're all stories about the kinds of notebooks they kept and
[00:31:08.400 --> 00:31:12.760]   how their lab notebooks worked or their lab journals worked.
[00:31:12.760 --> 00:31:15.040]   This is critical for data scientists too.
[00:31:15.040 --> 00:31:20.160]   This idea that as you do experiments, you're keeping track of what did I do, what worked,
[00:31:20.160 --> 00:31:21.520]   what didn't work.
[00:31:21.520 --> 00:31:26.080]   I can see all the people who put their hand up as scientists are all nodding right now.
[00:31:26.080 --> 00:31:28.400]   So this makes it super easy to do that.
[00:31:28.400 --> 00:31:34.360]   So be helpful to yourself and to your team by taking advantage of this.
[00:31:34.360 --> 00:31:42.180]   Now in order to learn to use this environment, all you have to do is press H. And when you
[00:31:42.180 --> 00:31:47.440]   press H, it brings up all of these keyboard shortcuts.
[00:31:47.440 --> 00:31:52.280]   After not very long, you will get to know all of them because they're all extremely
[00:31:52.280 --> 00:31:53.280]   useful.
[00:31:53.280 --> 00:31:59.080]   But the main ones I find particularly helpful is you hit M to turn into markdown mode.
[00:31:59.080 --> 00:32:03.600]   So that's the mode where you can enter text rather than code, or Y to switch it back to
[00:32:03.600 --> 00:32:04.760]   code again.
[00:32:04.760 --> 00:32:09.520]   And you certainly need to know Shift+Enter, which evaluates the cell and gives you a new
[00:32:09.520 --> 00:32:12.000]   cell to enter into.
[00:32:12.000 --> 00:32:17.360]   And you also need Escape, which pops you out of entering information and gets you back
[00:32:17.360 --> 00:32:20.000]   into this command mode.
[00:32:20.000 --> 00:32:23.040]   And then Enter to go back into edit mode again.
[00:32:23.040 --> 00:32:25.120]   So just to show you that.
[00:32:25.120 --> 00:32:33.760]   Enter to get into edit mode, Escape to get out of edit mode, Shift+Enter to evaluate.
[00:32:33.760 --> 00:32:39.120]   And you can see as I move around, it changes which one is highlighted.
[00:32:39.120 --> 00:32:44.240]   I've started to create some resources on the wiki for helping you with Jupyter Notebook.
[00:32:44.240 --> 00:32:53.500]   It's still pretty early, but you guys I'm sure can help by adding more information here.
[00:32:53.500 --> 00:33:01.080]   One of the things I particularly mentioned is that there are some good tutorials.
[00:33:01.080 --> 00:33:20.120]   I thought I had also mentioned my favorite book, which I now can't see here, Python Libraries.
[00:33:20.120 --> 00:33:23.280]   Python for Data Analysis by Wes McKinney.
[00:33:23.280 --> 00:33:24.280]   It's a little old.
[00:33:24.280 --> 00:33:30.080]   It also covers pandas a lot, which you don't need, but it's a good book for getting familiar
[00:33:30.080 --> 00:33:45.160]   with this basic kind of Python scientific programming stuff.
[00:33:45.160 --> 00:33:51.440]   So the last kind of ingredient that I want to introduce is Kaggle.
[00:33:51.440 --> 00:33:57.160]   How many people here have been to or done anything with Kaggle at any point?
[00:33:57.160 --> 00:34:00.600]   About a third of you.
[00:34:00.600 --> 00:34:05.120]   Anybody who is in the master's program here, I'm sure will have used Kaggle or shortly to
[00:34:05.120 --> 00:34:14.320]   use Kaggle, mainly because it's just a great place to get all kinds of interesting datasets.
[00:34:14.320 --> 00:34:22.040]   So for example, if you wanted to test your ability to do automated drug discovery, you
[00:34:22.040 --> 00:34:27.520]   could go to Kaggle and download the files for the Merck Molecular Activity Challenge,
[00:34:27.520 --> 00:34:33.040]   run some models and test them to see how they compare to the state of the art by comparing
[00:34:33.040 --> 00:34:36.520]   to the leaderboard.
[00:34:36.520 --> 00:34:43.080]   So Kaggle is a place where various organizations run machine learning competitions.
[00:34:43.080 --> 00:34:45.240]   They generally run for about three months.
[00:34:45.240 --> 00:34:49.020]   It's super cool because they get archived essentially forever.
[00:34:49.020 --> 00:34:53.160]   You can download the data for them later on and find out how you would have gone in that
[00:34:53.160 --> 00:34:56.040]   competition.
[00:34:56.040 --> 00:35:03.460]   Generally speaking, if you're in the top 50%, that means you have an okay-ish model that
[00:35:03.460 --> 00:35:06.360]   is somewhat worthwhile.
[00:35:06.360 --> 00:35:10.580]   If you're in the top 20%, that means you have a very good model.
[00:35:10.580 --> 00:35:19.780]   If you're in the top 10%, that means you're at an expert level for this type of problem.
[00:35:19.780 --> 00:35:24.200]   If you're in the top 10, it literally means you're one of the best in the world.
[00:35:24.200 --> 00:35:27.840]   Because every time I've seen a Kaggle competition -- I used to be president of Kaggle, so I'm
[00:35:27.840 --> 00:35:33.280]   very familiar with this -- every time I've seen a Kaggle competition, at least the top
[00:35:33.280 --> 00:35:41.080]   10 generally all beat the previous best in the world and generally are from really good
[00:35:41.080 --> 00:35:45.220]   machine learning experts who are going beyond anything that's been done before.
[00:35:45.220 --> 00:35:50.920]   It seems that the power of competition pushes people way beyond what the previous academic
[00:35:50.920 --> 00:35:54.460]   state of the art was.
[00:35:54.460 --> 00:36:00.380]   So Kaggle is a great environment to find interesting datasets and to benchmark your own approaches.
[00:36:00.380 --> 00:36:04.180]   So we're going to be using it for both of these purposes.
[00:36:04.180 --> 00:36:09.740]   Our first challenge will be dogs versus cats.
[00:36:09.740 --> 00:36:17.620]   So sometimes on Kaggle, they run competitions that are not done for lots of money, but sometimes
[00:36:17.620 --> 00:36:20.620]   they're done for free or for a bit of fun.
[00:36:20.620 --> 00:36:26.420]   In this case, it was actually done for a particular purpose which was, can you create an algorithm
[00:36:26.420 --> 00:36:29.860]   that can recognize the difference between dog photos and cat photos?
[00:36:29.860 --> 00:36:37.860]   And the reason why was because this particular organization was using that problem as a capture.
[00:36:37.860 --> 00:36:42.260]   In other words, to tell the difference between humans and computers.
[00:36:42.260 --> 00:36:49.620]   It turned out that the state of the art, machine classifiers, could score 80% accuracy on this
[00:36:49.620 --> 00:36:51.380]   task.
[00:36:51.380 --> 00:36:57.420]   So really, this group wanted to know, can you surpass the state of the art?
[00:36:57.420 --> 00:37:00.740]   Is this a useful capture?
[00:37:00.740 --> 00:37:06.980]   And then if you can surpass the state of the art, can they then use this kind of dogs versus
[00:37:06.980 --> 00:37:11.880]   cats recognizer for their pet finding work, which is what they were doing?
[00:37:11.880 --> 00:37:16.180]   So really the goal here was to beat 80%.
[00:37:16.180 --> 00:37:24.740]   Now this is a great example of the kind of thing which you could use for a thousand or
[00:37:24.740 --> 00:37:26.580]   million different purposes.
[00:37:26.580 --> 00:37:32.220]   For example, the work I did in cancer detection is this.
[00:37:32.220 --> 00:37:39.300]   So if you take a CT, or an X-ray, or an MRI, and you say to a deep learning algorithm,
[00:37:39.300 --> 00:37:44.100]   these people have malignant cancer, these people don't, it's the same as cats versus
[00:37:44.100 --> 00:37:45.100]   dogs.
[00:37:45.100 --> 00:37:52.000]   If this is a healthy, high crop yield area from satellite photos, this isn't, that's
[00:37:52.000 --> 00:37:53.920]   cat versus dogs.
[00:37:53.920 --> 00:37:59.180]   If you say this is one kind of skin lesion and this is another kind of skin lesion.
[00:37:59.180 --> 00:38:04.260]   If you say this is an abstract painting and this is not.
[00:38:04.260 --> 00:38:07.800]   This is an extremely valuable painting and this is not.
[00:38:07.800 --> 00:38:11.660]   This is a well-taken photo and this is not.
[00:38:11.660 --> 00:38:17.340]   They're all image analysis problems that are generally classification problems.
[00:38:17.340 --> 00:38:20.620]   These are all examples of things people have done with this kind of technology.
[00:38:20.620 --> 00:38:29.140]   So cats versus dogs, it turns out, is a very powerful format, and so if we can learn to
[00:38:29.140 --> 00:38:34.180]   solve this well, we can solve all of these kinds of classification problems.
[00:38:34.180 --> 00:38:40.540]   Not just binary, so not just is it this group or that group, but also things like that skin
[00:38:40.540 --> 00:38:41.900]   lesion example.
[00:38:41.900 --> 00:38:46.120]   These are 10 different types of skin lesions, which type is it?
[00:38:46.120 --> 00:38:53.280]   Or the crop disease example, which of these 13 crop diseases are we looking at here?
[00:38:53.280 --> 00:39:01.980]   An example of an actual thing that I saw, I can probably find it, was cucumber analysis.
[00:39:01.980 --> 00:39:04.420]   Cucumber deep learning.
[00:39:04.420 --> 00:39:11.420]   There can't be too many things with those particular keywords, there we go.
[00:39:11.420 --> 00:39:20.220]   A Japanese cucumber farmer used this approach to deep learning to do the automated all their
[00:39:20.220 --> 00:39:24.460]   logistics and basically had a system that would put the different grades of cucumbers
[00:39:24.460 --> 00:39:30.900]   into different bins automatically and make their cucumber workflow much more efficient.
[00:39:30.900 --> 00:39:39.860]   So if that was your idea for a start-up, it's already been done, but there's many more.
[00:39:39.860 --> 00:39:46.140]   So they are all of our basic pieces.
[00:39:46.140 --> 00:39:59.100]   So to get started, here we are with this AWS server with a pretty empty looking set of
[00:39:59.100 --> 00:40:00.760]   notebooks here.
[00:40:00.760 --> 00:40:06.140]   So we want to go ahead and start getting some work done.
[00:40:06.140 --> 00:40:10.060]   So to do that, we need to download the basic files that we need.
[00:40:10.060 --> 00:40:14.300]   So I've sent you all of this information already.
[00:40:14.300 --> 00:40:20.540]   All of the information you need is on our platform.iai website.
[00:40:20.540 --> 00:40:28.020]   All of the notebooks are in files/NVs.
[00:40:28.020 --> 00:40:34.140]   So what I'm going to do is, actually I'm going to show you a cool little trick.
[00:40:34.140 --> 00:40:38.620]   I'm going to press Ctrl+C twice, that shuts down the notebook.
[00:40:38.620 --> 00:40:40.260]   So the notebook is not running.
[00:40:40.260 --> 00:40:45.700]   Don't worry, it saves itself automatically on a regular basis, or you can just hit S
[00:40:45.700 --> 00:40:48.220]   to save it right now.
[00:40:48.220 --> 00:40:53.700]   So shutting down the notebook, as you'll see, the Python notebook files are still sitting
[00:40:53.700 --> 00:40:54.700]   there.
[00:40:54.700 --> 00:41:08.940]   And you can see actually that behind the scenes, they're just big bunches of JSON text.
[00:41:08.940 --> 00:41:15.220]   So you can stick them in GitHub and they'll all work perfectly well.
[00:41:15.220 --> 00:41:17.980]   What I generally like to do is run something called Tmux.
[00:41:17.980 --> 00:41:22.060]   How many people here have used Tmux or Screen before?
[00:41:22.060 --> 00:41:23.060]   Less than I expected.
[00:41:23.060 --> 00:41:26.780]   So those of you who haven't, you're going to love this trick.
[00:41:26.780 --> 00:41:35.340]   Tmux and Screen are programs that let you run programs on your server, close your terminal,
[00:41:35.340 --> 00:41:39.620]   come back later and your program will still be running in the exact same way.
[00:41:39.620 --> 00:41:42.700]   I don't remember if Tmux is already installed, it is.
[00:41:42.700 --> 00:41:47.460]   So to use it, you just go Tmux.
[00:41:47.460 --> 00:41:52.500]   And it looks like nothing happened, except a little green bar has appeared at the bottom.
[00:41:52.500 --> 00:42:00.580]   But if I now hit Tmux's magic command, which is Ctrl+B and press question mark, you can
[00:42:00.580 --> 00:42:04.460]   see there are lots of keystrokes that it has ready for me to use.
[00:42:04.460 --> 00:42:11.780]   And so one of the ones I like is Ctrl+B double quote, which creates a second window underneath
[00:42:11.780 --> 00:42:18.460]   this one, or Ctrl+B percent, which shows a second window next to this one.
[00:42:18.460 --> 00:42:29.220]   And so I tend to set up a little Tmux session and get it all set up the way I want.
[00:42:29.220 --> 00:42:35.020]   So I'm not going to go into detail about how to do everything I show you.
[00:42:35.020 --> 00:42:41.780]   What I really want to do in the class is to say, here's something that exists, here's
[00:42:41.780 --> 00:42:47.140]   something I recommend using, here's what it's called, and during the week, you can play
[00:42:47.140 --> 00:42:50.660]   with it, you can ask questions, you can use it in your team, and so forth.
[00:42:50.660 --> 00:42:55.180]   So here it is, it's called Tmux, this is what it does, and I'll show you something cool.
[00:42:55.180 --> 00:43:04.380]   If I now go Ctrl+B and then D to detach, close out of this altogether, it's all gone.
[00:43:04.380 --> 00:43:18.580]   So if I now go back into my server, I wasn't able to SSH in properly because currently
[00:43:18.580 --> 00:43:20.980]   $instance.ip is not defined.
[00:43:20.980 --> 00:43:25.820]   And the reason for that is that I have to -- this is good, I get to show you lots of
[00:43:25.820 --> 00:43:36.220]   steps -- rather than every time I start sourcing my aws-alias.sh file, what I should do is I
[00:43:36.220 --> 00:43:45.380]   should go vim.bashrc.bashrc is a file that is run every time you run bash.
[00:43:45.380 --> 00:43:57.340]   And if I edit my bashrc file, and at the end I type source aws-alias.sh, and just to show
[00:43:57.340 --> 00:44:05.660]   you, I'm going to close it and re-open it.
[00:44:05.660 --> 00:44:08.300]   If you're wondering why my computer is going so slowly, it's because when you have these
[00:44:08.300 --> 00:44:14.700]   big Skype calls running at the same time as green recording, everything slows down.
[00:44:14.700 --> 00:44:16.880]   So you can see now all those aliases are there.
[00:44:16.880 --> 00:44:22.980]   So before I SSH to $instance.id, I have to find out my correct IP address.
[00:44:22.980 --> 00:44:39.940]   So I can say aws-get p2, get my instance ID, and then we can -- you know what, I'm not
[00:44:39.940 --> 00:44:45.340]   sure I've got something here to actually just get the IP address.
[00:44:45.340 --> 00:44:46.340]   So that's interesting.
[00:44:46.340 --> 00:44:49.900]   As you can see, I'm kind of playing with this a little bit as I go, so I'm going to go ahead
[00:44:49.900 --> 00:44:52.260]   and show you how to do this.
[00:44:52.260 --> 00:44:57.860]   So right now, the IP address only gets printed out when I start an instance.
[00:44:57.860 --> 00:45:03.420]   In this case, I've already got an instance running, so I'm going to edit this script
[00:45:03.420 --> 00:45:04.980]   and I'll change it later on.
[00:45:04.980 --> 00:45:12.940]   So basically I'm going to create a new alias called aws-ip, and I'm going to get rid of
[00:45:12.940 --> 00:45:21.340]   the bit that starts the instances, get rid of the bit that waits for it to be running,
[00:45:21.340 --> 00:45:26.740]   and I'm just going to keep the bit that says instance-ip equals something, something, something.
[00:45:26.740 --> 00:45:40.460]   So I'm going to call this aws-alius.sh, and I've got a new alias called aws-ip, and now
[00:45:40.460 --> 00:45:46.700]   I can go ssh-ubuntu@dollar-instance-ip.
[00:45:46.700 --> 00:45:51.740]   Having said all that, because my IP address is going to be the same every time, and I
[00:45:51.740 --> 00:45:57.420]   couldn't really be bothered waiting for all that, I'm going to manually put my IP address
[00:45:57.420 --> 00:45:58.420]   in here.
[00:45:58.420 --> 00:46:05.420]   So the next time I run this, I can just press up arrow and just rerun that command.
[00:46:05.420 --> 00:46:11.580]   So I'm showing you lots of ways of doing things, so you can decide what your own workflow is
[00:46:11.580 --> 00:46:13.180]   like or come up with better ones.
[00:46:13.180 --> 00:46:23.580]   So here's the cool thing, I'm back in my box here, and then if I say tmux-attach, I am exactly
[00:46:23.580 --> 00:46:24.900]   back to where I came from.
[00:46:24.900 --> 00:46:28.720]   So whatever I had running and whatever it said it was, it's still sitting there.
[00:46:28.720 --> 00:46:32.220]   So the particularly cool thing is that any notebooks, kernels I had running, they're
[00:46:32.220 --> 00:46:35.060]   all still sitting there.
[00:46:35.060 --> 00:46:39.140]   This is particularly helpful if you run something like those OVH servers or one of your own
[00:46:39.140 --> 00:46:40.140]   servers.
[00:46:40.140 --> 00:46:44.380]   In the AWS, it's a little less helpful because you really need to shut it down to avoid paying
[00:46:44.380 --> 00:46:45.380]   the money.
[00:46:45.380 --> 00:46:50.860]   But if you've got something you can keep running, for all the MSAM students, you will have access
[00:46:50.860 --> 00:46:58.940]   to the GPU server we have here at the University, which is particularly helpful for you guys.
[00:46:58.940 --> 00:47:04.980]   So I actually tend to use this little bottom right-hand window to permanently have Jupyter
[00:47:04.980 --> 00:47:06.660]   notebook running.
[00:47:06.660 --> 00:47:09.580]   So that's kind of like my particular way of running.
[00:47:09.580 --> 00:47:16.220]   And then I tend to use this left-hand window to kind of do other things.
[00:47:16.220 --> 00:47:29.420]   And in particular, I'm going to go ahead and grab my notebooks.
[00:47:29.420 --> 00:47:32.660]   So the easiest way to grab things is with wget.
[00:47:32.660 --> 00:47:44.880]   I now have a notebook, Lesson 1, and so if I go back to my Jupyter notebook, see it's
[00:47:44.880 --> 00:47:54.300]   appeared, Lesson 1, and if I click on it...
[00:47:54.300 --> 00:48:02.060]   If you're using a T2 instance, the free ones, generally speaking, particularly the first
[00:48:02.060 --> 00:48:05.180]   time you run something it can take quite a long time to open.
[00:48:05.180 --> 00:48:08.780]   You should find the second time it's quite fast by the way.
[00:48:08.780 --> 00:48:13.300]   So here is our notebook, and so hopefully quite a few of you have already got to the
[00:48:13.300 --> 00:48:17.340]   point today that you can see this, those of you that haven't will get plenty of help during
[00:48:17.340 --> 00:48:20.780]   the week.
[00:48:20.780 --> 00:48:30.780]   This particular notebook uses two external scripts to help, those scripts are called
[00:48:30.780 --> 00:48:33.940]   utils and vgg16.
[00:48:33.940 --> 00:48:43.820]   So the last thing I'm going to do before I break is to grab those, and just pop these
[00:48:43.820 --> 00:48:55.620]   all in this notebooks directory, so they're all in the same place, vgg16, wget, then unzip
[00:48:55.620 --> 00:49:07.500]   them, and then the only other thing you need is the data.
[00:49:07.500 --> 00:49:15.980]   So the data sits in the platform.ai data directory, and the data is all the dogs and cats.
[00:49:15.980 --> 00:49:21.440]   Now I've taken the Kaggle data and made changes to it, which I'm going to be showing you.
[00:49:21.440 --> 00:49:26.380]   So rather than downloading it from Kaggle, I suggest you grab it from platform.ai, and
[00:49:26.380 --> 00:49:31.540]   I've sent you this information today as well.
[00:49:31.540 --> 00:49:38.820]   So I'm going to cd into data, and wget that as well.
[00:49:38.820 --> 00:49:42.620]   And so that's going to run for a few minutes, and so while it does, I think it's a good
[00:49:42.620 --> 00:49:45.460]   time to have a break.
[00:49:45.460 --> 00:49:54.540]   Let's have a 10 minute break during which you are welcome to keep going with your install,
[00:49:54.540 --> 00:49:59.500]   chat to myself or Rachel or Tyro or Jad if you've got any questions, or get to know your
[00:49:59.500 --> 00:50:02.260]   team or just go and have a coffee.
[00:50:02.260 --> 00:50:13.940]   So let's get back together at 5 past 8.
[00:50:13.940 --> 00:50:18.140]   The previous section, I think, for some of you, and I was chatting to a couple of you
[00:50:18.140 --> 00:50:24.900]   during the break, was a bit of a fire hose of information because it was like, here's
[00:50:24.900 --> 00:50:31.700]   Bash, here's AWS, here's Kaggle, here's GPUs, blah, blah, blah.
[00:50:31.700 --> 00:50:35.100]   For some of you, it was probably really boring.
[00:50:35.100 --> 00:50:38.860]   Most practicing data scientists are probably using all of those things already.
[00:50:38.860 --> 00:50:47.380]   So if you're at one extreme of the fire hose of information, don't worry.
[00:50:47.380 --> 00:50:52.660]   We have all week to get through it, you'll have the video tomorrow, and by the time you're
[00:50:52.660 --> 00:50:57.380]   here again next week, I want to make sure that everybody who has the time and interest
[00:50:57.380 --> 00:51:01.900]   to work hard on it has got through all of the material.
[00:51:01.900 --> 00:51:07.180]   If you haven't, like you're a couple of days, maybe it's early on the weekend and you're
[00:51:07.180 --> 00:51:11.740]   thinking you're not going to get there, please let Rachel and I know, we will work with you
[00:51:11.740 --> 00:51:15.180]   in person to get you there.
[00:51:15.180 --> 00:51:20.420]   Everybody who puts the time in, I am determined to make sure can get through the material.
[00:51:20.420 --> 00:51:25.480]   If you don't really have the background and you don't really have the time, that's fine.
[00:51:25.480 --> 00:51:31.560]   Maybe you won't get through all of the material, but I really am determined that everybody
[00:51:31.560 --> 00:51:34.860]   who's prepared and able to put in the time can get through everything.
[00:51:34.860 --> 00:51:42.060]   So between the community resources and the video and Rachel and I and folks like Taro
[00:51:42.060 --> 00:51:45.860]   and Yad, we will help everybody.
[00:51:45.860 --> 00:51:49.220]   To those of you who are kind of practicing data scientists and you are familiar with
[00:51:49.220 --> 00:51:56.940]   all of these pieces, I apologize that it will be a bit slow for you and hopefully as we
[00:51:56.940 --> 00:51:59.820]   move along there will be more and more new stuff.
[00:51:59.820 --> 00:52:04.660]   I'm kind of hoping that for those of you who already have some level of expertise, we will
[00:52:04.660 --> 00:52:09.500]   continually give you ways that you can go further.
[00:52:09.500 --> 00:52:14.540]   So for example, at the moment I'm thinking can you help us with these scripts to make
[00:52:14.540 --> 00:52:21.380]   them better, to make them simpler, to make them more powerful, to create Azure versions
[00:52:21.380 --> 00:52:23.500]   of them.
[00:52:23.500 --> 00:52:27.180]   All the stuff that we're doing to try and make deep learning as accessible as possible,
[00:52:27.180 --> 00:52:28.500]   can you help contribute to that?
[00:52:28.500 --> 00:52:30.700]   Can you help contribute to the wiki?
[00:52:30.700 --> 00:52:37.020]   So for those of you who already have quite a high level of expertise, I'm really looking
[00:52:37.020 --> 00:52:40.660]   to make sure that there's always ways that you can push yourself.
[00:52:40.660 --> 00:52:45.940]   So if you're ever feeling a bit bored, let me know.
[00:52:45.940 --> 00:52:49.740]   That is a perfectly reasonable thing to say, hey I'm kind of a bit bored and I'll try and
[00:52:49.740 --> 00:52:57.900]   give you something to do that you don't know how to do and then you won't be bored anymore.
[00:52:57.900 --> 00:53:08.540]   So at this point, I downloaded dogscats.zip and I unzipped it.
[00:53:08.540 --> 00:53:12.940]   If you're wondering about the -q, that's just because unzip otherwise prints out every single
[00:53:12.940 --> 00:53:17.460]   file name as it goes, so that's Q for quiet.
[00:53:17.460 --> 00:53:23.780]   So just about the most important thing for doing this kind of image classification is
[00:53:23.780 --> 00:53:28.540]   how the data directories are structured.
[00:53:28.540 --> 00:53:39.340]   And in particular, you'll notice that we have a training set and a test set, and that's because
[00:53:39.340 --> 00:53:46.780]   when we downloaded the data originally from Kaggle, it had a train.zip and a test.zip.
[00:53:46.780 --> 00:53:54.540]   Keras, which is the library we're going to use, expects that each class of object that
[00:53:54.540 --> 00:53:58.080]   you're going to recognize is in a different directory.
[00:53:58.080 --> 00:54:09.100]   So the one main thing I did after I downloaded it from Kaggle is that I created two directories,
[00:54:09.100 --> 00:54:12.780]   one called cats and one called dogs, and I put all the cats in the cats and all the dogs
[00:54:12.780 --> 00:54:13.780]   in the dogs.
[00:54:13.780 --> 00:54:18.180]   Because when I downloaded them from Kaggle, they were all in one directory and they were
[00:54:18.180 --> 00:54:23.060]   called cat.one.jpg or dog.one.jpg, so that was pretty straightforward.
[00:54:23.060 --> 00:54:48.220]   So now if I ls train dog.one star, sorry, dogs/dog.one, okay, for example, or dog.tenstar.
[00:54:48.220 --> 00:55:07.740]   So there are, I don't know why there's 11,501, there's maybe 11,500 dogs in there, obviously
[00:55:07.740 --> 00:55:20.100]   on something weird, and then cats. So that's the number of dogs and cats that we have in
[00:55:20.100 --> 00:55:21.460]   our training set.
[00:55:21.460 --> 00:55:27.160]   And so for those of you who haven't done much data science before, there's this really key
[00:55:27.160 --> 00:55:30.980]   concept that you have a training set and a test set.
[00:55:30.980 --> 00:55:37.920]   And Kaggle, being a competition, makes this really obvious. The files in the training
[00:55:37.920 --> 00:55:44.380]   set tell you what they are. Here is a dog, it's called dog.something. But if I look in
[00:55:44.380 --> 00:55:55.100]   the test set, they don't say anything, they're just numbers. Why is that? That's because
[00:55:55.100 --> 00:56:01.700]   your job in this Kaggle competition is to say for 43.jpg, is it a dog or is it a cat?
[00:56:01.700 --> 00:56:18.180]   So there are 12,500 images in the test directory for you to classify. Even if you're not doing
[00:56:18.180 --> 00:56:22.580]   a Kaggle competition, you should always do this yourself. In fact, ideally you would
[00:56:22.580 --> 00:56:26.820]   get one of your colleagues to do it without you being involved, to split the data into
[00:56:26.820 --> 00:56:31.780]   a test set and a training set and to not let you look at the test set until you've promised
[00:56:31.780 --> 00:56:34.420]   you're finished.
[00:56:34.420 --> 00:56:41.820]   And Kaggle kind of enforces this. They let you submit to the leaderboard and find out
[00:56:41.820 --> 00:56:47.100]   how you're going, but actually the final score is given based on a totally separate set of
[00:56:47.100 --> 00:56:55.380]   data that is not scored. For me, before I started entering Kaggle competitions, I kind
[00:56:55.380 --> 00:57:02.140]   of thought that my data science process was reasonably rigorous. But once I actually started
[00:57:02.140 --> 00:57:07.060]   doing competitions, I realized that that level of enforcing the test training split made
[00:57:07.060 --> 00:57:11.740]   me a much better data scientist. You know, you can't cheat. So I do suggest you do this
[00:57:11.740 --> 00:57:16.540]   in your own projects as well.
[00:57:16.540 --> 00:57:24.460]   Now because we also want to tune our algorithm in terms of different architectures and parameters
[00:57:24.460 --> 00:57:31.340]   and so forth, it's also a very good idea to split your training set further into a training
[00:57:31.340 --> 00:57:34.900]   set and a validation set. We'll see a lot more about how this works, but you'll see
[00:57:34.900 --> 00:57:42.180]   in this case I've created another directory called valid, which has dogs and cats as well.
[00:57:42.180 --> 00:57:55.340]   So it's structured exactly the same. And here you can see that there are a thousand cats
[00:57:55.340 --> 00:57:56.460]   and a thousand dogs.
[00:57:56.460 --> 00:58:00.980]   So when I originally downloaded from Kaggle, there were 12,500 cats and dogs in the training
[00:58:00.980 --> 00:58:06.620]   set. That's why in my training set there are 11,500 because I've moved a thousand of each
[00:58:06.620 --> 00:58:15.540]   of them to a validation set. So that's the basic data structure we have.
[00:58:15.540 --> 00:58:19.500]   Other than splitting things into test training and validation sets, that's the most important
[00:58:19.500 --> 00:58:23.700]   advice I have just as a data scientist. The second most important advice I have as a data
[00:58:23.700 --> 00:58:29.520]   scientist is to always do nearly all of your work on a sample. A sample is a very small
[00:58:29.520 --> 00:58:34.300]   amount of data that you can run so quickly that everything you try, you get a nearly
[00:58:34.300 --> 00:58:41.860]   immediate answer to. This allows you to very quickly try things, change things and get
[00:58:41.860 --> 00:58:44.180]   a basic process running.
[00:58:44.180 --> 00:58:51.860]   So I always create a sample with 100 or so items to just get started with. So you'll
[00:58:51.860 --> 00:59:01.140]   see I have a directory called sample and in that I have a whole separate train and valid.
[00:59:01.140 --> 00:59:06.100]   I did not move things there, I copied them there. The purpose of this sample directory
[00:59:06.100 --> 00:59:10.020]   is just to let me do things really quickly.
[00:59:10.020 --> 00:59:29.020]   So you'll see inside sample train, we have cats and dogs, but this time there are 8.
[00:59:29.020 --> 00:59:34.220]   I probably should have put more in there. I think probably more like 100 would have been
[00:59:34.220 --> 00:59:38.660]   good, but I think at the time I was probably using a really low-powered computer for my
[00:59:38.660 --> 00:59:44.380]   testing. But it's enough to check that my script is working.
[00:59:44.380 --> 00:59:53.580]   So now that everything is downloaded, you can see that I have -- and my Jupyter notebook
[00:59:53.580 --> 01:00:02.820]   has automatically noticed that it's changed. I'll get rid of these zip files. And I'll
[01:00:02.820 --> 01:00:09.820]   get rid of the Rachel's and Jeremy's notebooks that I was just playing with. And we're ready
[01:00:09.820 --> 01:00:15.180]   to get started with doing some deep learning.
[01:00:15.180 --> 01:00:25.020]   So the goal for you guys during this week will be to replicate everything that I've
[01:00:25.020 --> 01:00:32.340]   done, initially just by making sure that this notebook works for you, but then to replicate
[01:00:32.340 --> 01:00:38.620]   it with another dataset. And so one of the things we'll do tomorrow is we'll post some
[01:00:38.620 --> 01:00:44.440]   ideas of other interesting Kaggle datasets you could try, and maybe other people can
[01:00:44.440 --> 01:00:48.520]   also post other interesting datasets they've found elsewhere.
[01:00:48.520 --> 01:00:53.540]   So the idea will be to make sure that during the week, you can run your own classification
[01:00:53.540 --> 01:00:58.900]   process on some dataset other than dogs and cats. But first of all, make sure that you
[01:00:58.900 --> 01:01:00.500]   can run this.
[01:01:00.500 --> 01:01:09.540]   So as you can see in this notebook, I've used markdown cells. How many people have used
[01:01:09.540 --> 01:01:18.060]   markdown before? So those of you who don't know, markdown is what we use both in the
[01:01:18.060 --> 01:01:23.180]   notebook as well as on the wiki. It's basically a way of really quickly creating formatted
[01:01:23.180 --> 01:01:26.940]   text. There's not enough of you that aren't familiar with it that I'm going to go into
[01:01:26.940 --> 01:01:32.060]   it in detail. If you're not familiar with it, please Google markdown. And you can experiment
[01:01:32.060 --> 01:01:38.060]   with it either on the wiki or in your notebook.
[01:01:38.060 --> 01:01:41.900]   As you can see though, I've basically created cells with headings and some text, and during
[01:01:41.900 --> 01:01:47.220]   the week you can read through these in detail. As we mentioned, we're going to try to enter
[01:01:47.220 --> 01:01:56.700]   the dogs and cats competition. So 25,000 labeled dog cat photos, half of each. 12,500 in the
[01:01:56.700 --> 01:02:04.180]   test set. And the goal is to beat 80%.
[01:02:04.180 --> 01:02:10.340]   As we go along, we are going to be learning about quite a few libraries. Not too many,
[01:02:10.340 --> 01:02:14.860]   but enough that for those of you that haven't used Python for data science before, it's
[01:02:14.860 --> 01:02:18.700]   going to seem like quite a few. By the end of the 7 weeks, hopefully you'll be pretty
[01:02:18.700 --> 01:02:21.420]   familiar with all of them.
[01:02:21.420 --> 01:02:27.700]   One of the really important three is Matplotlib. That's because Matplotlib does all of our
[01:02:27.700 --> 01:02:35.340]   plotting and visualization. On the wiki, we have a section called Python Libraries. As
[01:02:35.340 --> 01:02:41.620]   you can see, we have our top three listed up here. At the moment, there are just links
[01:02:41.620 --> 01:02:48.140]   to where they come from. I'm hoping that you guys will help us to turn this into a really
[01:02:48.140 --> 01:02:53.260]   rich source of information about places that you found lots of helpful staff answers to
[01:02:53.260 --> 01:02:58.340]   frequently asked questions. For now, if you're not familiar with one of these things, type
[01:02:58.340 --> 01:03:03.980]   the word followed by a tutorial into Google and you'll find lots of resources. One of
[01:03:03.980 --> 01:03:11.380]   these things are widely used. Keras is a little bit less so because it's just a deep learning
[01:03:11.380 --> 01:03:17.820]   library and therefore relatively new. NumPy and Matplotlib and all these other ones, scikit-learn,
[01:03:17.820 --> 01:03:21.620]   scipy, there's lots of books about them, there's lots of tutorials about them, there's lots
[01:03:21.620 --> 01:03:25.700]   of videos about them.
[01:03:25.700 --> 01:03:33.660]   Matplotlib creates plots. One of the things we need to do is to tell Jupyter Notebook
[01:03:33.660 --> 01:03:37.260]   what to do with those plots. Should it pop open a new window for them? Should it save
[01:03:37.260 --> 01:03:44.160]   them? So this sent Matplotlib inline says, "Please show our plots in the actual Jupyter
[01:03:44.160 --> 01:03:51.700]   notebook." So that's pretty much the first line in every Jupyter notebook that I create.
[01:03:51.700 --> 01:03:55.580]   And here's the thing I told you about, which is sometimes I want to run stuff on a sample
[01:03:55.580 --> 01:04:00.220]   and sometimes I want to run it on everything. And so I make it really easy for myself by
[01:04:00.220 --> 01:04:05.800]   having a single thing called path which I can switch between the sample and the everything.
[01:04:05.800 --> 01:04:10.340]   So for now, let's just do things on the sample.
[01:04:10.340 --> 01:04:15.500]   And so as I said, you should do all of your work on the sample until everything is working.
[01:04:15.500 --> 01:04:20.500]   So as you can see, each time I've done something I press Shift+Enter and it puts a little number
[01:04:20.500 --> 01:04:29.340]   after the 'in', showing that this is the second input cell that I've run.
[01:04:29.340 --> 01:04:34.820]   Like every programming language, a large amount of the power of Python comes from the libraries
[01:04:34.820 --> 01:04:42.780]   that you use, and to use a library in Python you have to do two things. You have to install
[01:04:42.780 --> 01:04:52.020]   it and then you have to import it. In Python, I strongly recommend that you use a particular
[01:04:52.020 --> 01:04:57.180]   Python distribution called Anaconda. And if you're using the scripts and AMIs we provided,
[01:04:57.180 --> 01:05:04.460]   you are already using Anaconda. You can check what Python you're using by typing which Python
[01:05:04.460 --> 01:05:09.260]   and it will tell you. You'll see that not only am I using Anaconda, but I'm using an
[01:05:09.260 --> 01:05:15.460]   Anaconda that is installed into my home directory. So no screwing around with sudo or any of that
[01:05:15.460 --> 01:05:21.340]   business. Again, if you use our AMI in scripts, this has all been done for you.
[01:05:21.340 --> 01:05:27.060]   With Anaconda, installing anything is the simplest typing conda, install, and the name
[01:05:27.060 --> 01:05:31.820]   of the thing. And on Anaconda, everything's been pre-compiled, so you don't have to wait
[01:05:31.820 --> 01:05:37.820]   for it to compile, you don't have to worry about dependencies, anything, it just works.
[01:05:37.820 --> 01:05:44.780]   That is why we very highly recommend using Anaconda.
[01:05:44.780 --> 01:05:51.820]   It works on Mac, it works on Windows, and it works on Linux. Lots of Windows users use
[01:05:51.820 --> 01:05:57.420]   it, very few Linux users use it, very few Mac users use it. I think that's a mistake because
[01:05:57.420 --> 01:06:02.340]   lots of Mac and Linux users also have trouble with compiling dependencies and all that stuff.
[01:06:02.340 --> 01:06:05.300]   I suggest that everybody uses it.
[01:06:05.300 --> 01:06:12.180]   From time to time, you will come across something that does not have an Anaconda installer available,
[01:06:12.180 --> 01:06:20.380]   in which case you have to use pip instead. In our case, I think just Theano and Keras
[01:06:20.380 --> 01:06:26.580]   are in that situation, but neither of those need compiling anything at all. So they're
[01:06:26.580 --> 01:06:29.060]   very easy to install.
[01:06:29.060 --> 01:06:33.900]   So once you've installed it by typing conda, install, whatever, and most things are already
[01:06:33.900 --> 01:06:39.420]   installed for you with our AMIs, you then have to tell Python that I want to use it
[01:06:39.420 --> 01:06:44.140]   in this particular session, which you do just by typing import and the thing you want to
[01:06:44.140 --> 01:06:45.140]   look at.
[01:06:45.140 --> 01:06:49.060]   So I'm not going to go through all these libraries right now, I'll go through them as we use
[01:06:49.060 --> 01:06:57.660]   them. But one of the big three is here, which is NumPy. NumPy is the thing which, as our
[01:06:57.660 --> 01:07:04.060]   wiki page describes, provides all of our basic linear algebra. How many people here have
[01:07:04.060 --> 01:07:09.900]   some familiarity at all with linear algebra? Nearly all of you, good.
[01:07:09.900 --> 01:07:17.140]   So if you're somebody who didn't put up your hand, I would suggest looking at the resources
[01:07:17.140 --> 01:07:29.600]   that Taro added to the wiki at the bottom here. So go back to the homepage and go to
[01:07:29.600 --> 01:07:36.900]   linear algebra for deep learning. Generally speaking, for any math stuff, my suggestion
[01:07:36.900 --> 01:07:43.780]   is to go to the Khan Academy site. Khan Academy has really great videos for introducing these
[01:07:43.780 --> 01:07:49.860]   kind of simple topics. We just need to know these three things, mainly really the first
[01:07:49.860 --> 01:07:57.580]   two things for this course. And NumPy is the thing which gives you these linear algebra
[01:07:57.580 --> 01:08:03.580]   operations in Python. And as you'll see, it makes them extremely easy to use. Pretty much
[01:08:03.580 --> 01:08:10.500]   everybody renames NumPy to np. So that's what import NumPy as np does. You'll find in nearly
[01:08:10.500 --> 01:08:18.460]   everybody's script on the internet, it'll be np.something, not NumPy.something. In general,
[01:08:18.460 --> 01:08:24.660]   we try to stick with the same kind of approaches that everybody else uses so that nothing will
[01:08:24.660 --> 01:08:28.100]   be too unfamiliar.
[01:08:28.100 --> 01:08:35.220]   So we've imported some libraries that we need. We also try to provide some additional utilities
[01:08:35.220 --> 01:08:39.140]   and scripts for things that we think probably ought to exist but don't exist that make things
[01:08:39.140 --> 01:08:47.980]   easier. There's very few of them, nearly all of it is in one script called utils. There's
[01:08:47.980 --> 01:08:54.140]   a cool little trick which is that if you are using external script that you've created
[01:08:54.140 --> 01:08:58.180]   and you're changing it quite a bit, so now that you've got utils, feel free to add and
[01:08:58.180 --> 01:09:03.100]   change and do whatever you like to it. If you import it like this, import utils, relude
[01:09:03.100 --> 01:09:09.580]   utils and then from utils import whatever you need, you can go back and rerun that cell
[01:09:09.580 --> 01:09:15.940]   later after you've changed utils.py and all of your changes will be there, available for
[01:09:15.940 --> 01:09:16.940]   you to use.
[01:09:16.940 --> 01:09:21.780]   So for now we're just going to use one thing from our utils library called plots, which
[01:09:21.780 --> 01:09:24.980]   you'll see used in a moment.
[01:09:24.980 --> 01:09:32.420]   So our first step will be to use a pre-trained model. So what do we mean by a pre-trained
[01:09:32.420 --> 01:09:40.100]   model? What we mean is that somebody has already come along, downloaded millions of images off
[01:09:40.100 --> 01:09:46.220]   the internet and built a deep learning model that has learned to recognize the contents
[01:09:46.220 --> 01:09:50.140]   of those images.
[01:09:50.140 --> 01:09:55.980]   Nearly always when people create these pre-trained models, they use a particular dataset called
[01:09:55.980 --> 01:10:00.380]   ImageNet. The reason that they tend to use ImageNet, or one of the key reasons that they
[01:10:00.380 --> 01:10:06.300]   tend to use ImageNet is because ImageNet has the most respected annual computer vision
[01:10:06.300 --> 01:10:18.620]   competition. So people that win the ImageNet challenge tend to be companies like Google
[01:10:18.620 --> 01:10:22.420]   and Microsoft. A couple of years ago, it tended to be people who immediately then got hired
[01:10:22.420 --> 01:10:25.220]   by Google and Microsoft.
[01:10:25.220 --> 01:10:32.260]   ImageNet itself is fun to explore. If you go to ImageNet and go to Explore, you can check
[01:10:32.260 --> 01:10:43.260]   it out. And basically there are 32,000 categories. So for example, we can go to ImageNet, let's
[01:10:43.260 --> 01:10:54.220]   look at plants and plant life, let's go to crops, let's go to field crops, corn type
[01:10:54.220 --> 01:11:02.960]   crops, dent corn, so here we have a number of pictures of dent corn. There are 397 of
[01:11:02.960 --> 01:11:05.500]   them.
[01:11:05.500 --> 01:11:12.180]   The folks that create these pre-trained networks basically download a large subset of ImageNet.
[01:11:12.180 --> 01:11:18.900]   The competition has 1,000 of these 32,000 categories that people compete on. So nearly
[01:11:18.900 --> 01:11:24.860]   always people just build models for these 1,000.
[01:11:24.860 --> 01:11:32.780]   I would be remiss if I did not mention the shortcomings of the ImageNet dataset. Can
[01:11:32.780 --> 01:11:41.460]   anybody tell me something that they notice in common about what these photos look like
[01:11:41.460 --> 01:11:47.340]   or how they're structured?
[01:11:47.340 --> 01:11:56.980]   They're just one thing. If you look at an arbitrary photo, say from my photo album,
[01:11:56.980 --> 01:12:01.660]   you'll see there's a person here, a bridge there, something else here. ImageNet is carefully
[01:12:01.660 --> 01:12:09.420]   curated to be pictures of Flint corn. These are like 312 pictures that are designed to
[01:12:09.420 --> 01:12:15.100]   be really good pictures of Flint corn, whatever that is.
[01:12:15.100 --> 01:12:25.040]   This is an easier problem than many problems that you will be facing. For example, I was
[01:12:25.040 --> 01:12:31.980]   talking to Robin from Planet Labs at a break about the work that they're doing with satellite
[01:12:31.980 --> 01:12:36.580]   imagery. Their satellite imagery is going to have a lot more than a picture of a piece
[01:12:36.580 --> 01:12:44.500]   of corn, like a Planet Labs satellite. Where's Robin? How many pixels is a Planet Labs photo?
[01:12:44.500 --> 01:12:52.580]   A couple of million. So pretty big, and in that couple of million pixels you're going
[01:12:52.580 --> 01:13:00.380]   to have like what kind of area would that cover? 50 square kilometers. 500 square kilometers.
[01:13:00.380 --> 01:13:05.340]   So there's going to be tennis courts and swimming pools and people sunbathing and all kinds
[01:13:05.340 --> 01:13:13.580]   of stuff. So when Robin takes this stuff to Planet Labs, he's not just going to be able
[01:13:13.580 --> 01:13:19.500]   to use a pre-trained network directly. But we're going to show you how you can use some
[01:13:19.500 --> 01:13:24.140]   of the structure of the pre-trained network even if you are not looking at photos that
[01:13:24.140 --> 01:13:26.100]   are this clear.
[01:13:26.100 --> 01:13:31.540]   Having said that, if you remember the slide I showed you earlier of the plant disease
[01:13:31.540 --> 01:13:38.580]   project, each of those plant disease pictures were very clearly just pictures of one thing.
[01:13:38.580 --> 01:13:43.900]   This certainly happens as well. But do be aware that when you're using a pre-trained network,
[01:13:43.900 --> 01:13:48.940]   you are inheriting the shortcomings and biases of the data it was trained from, and therefore
[01:13:48.940 --> 01:13:52.940]   you should always look at the data it was trained from.
[01:13:52.940 --> 01:13:59.620]   So being aware of that, I would say that for us, this is going to be quite a suitable kind
[01:13:59.620 --> 01:14:05.940]   of dataset, and as we look at the dataset, you'll see why I say that.
[01:14:05.940 --> 01:14:13.260]   So each year, most of the winners of the ImageNet competition make their source code and their
[01:14:13.260 --> 01:14:20.820]   weights available. So when I say their source code and their weights, the source code is
[01:14:20.820 --> 01:14:26.060]   the thing that defines -- remember I told you there are three bits that give us modern
[01:14:26.060 --> 01:14:31.500]   deep learning. It's the infinitely flexible function, it's the way to train the parameters,
[01:14:31.500 --> 01:14:36.980]   and it's the fast and scalable. The particular functional form is what is the neural network
[01:14:36.980 --> 01:14:41.420]   architecture. We're going to be learning a lot about that. But that's the source code.
[01:14:41.420 --> 01:14:46.060]   So generally you download the source code from the folks that build the model.
[01:14:46.060 --> 01:14:51.260]   The second is the parameters that were learned. Generally an ImageNet winner has trained a
[01:14:51.260 --> 01:14:58.740]   model for days or weeks, nowadays often on many GPUs, to find the particular set of parameters,
[01:14:58.740 --> 01:15:03.780]   the particular weights that make it really good at recognizing those ImageNet pictures.
[01:15:03.780 --> 01:15:09.420]   So you generally have to get the code and the weights. And once you have those two things,
[01:15:09.420 --> 01:15:16.980]   you can replicate that particular ImageNet winner's results.
[01:15:16.980 --> 01:15:25.060]   One of the winners of 2014 was the Visual Geometry Group. It's an Oxford University group. And
[01:15:25.060 --> 01:15:31.620]   so there's this model called VGG. You'll hear about it lots. Generally speaking, every year's
[01:15:31.620 --> 01:15:37.580]   ImageNet winners, the particular models they used are so well used in the community that
[01:15:37.580 --> 01:15:47.160]   people call them by name. So the 2012 winner was AlexNet, 2014 was VGG, 2015 was I guess
[01:15:47.160 --> 01:15:54.500]   our conception, 2016 was ResNet, so they all have names.
[01:15:54.500 --> 01:16:06.140]   VGG is a couple of years old, so it's not quite the best today. But it's special because it's
[01:16:06.140 --> 01:16:11.380]   the last of the really powerful simple architectures.
[01:16:11.380 --> 01:16:17.900]   We will get to the more complex architectures. Depending on how we go, it might be in this
[01:16:17.900 --> 01:16:22.220]   set of classes. If not, it will be in next year's set of classes. Hopefully this year's
[01:16:22.220 --> 01:16:33.740]   set of classes. But VGG's simpler approach is not much less accurate. And for teaching
[01:16:33.740 --> 01:16:38.340]   purposes, we're going to be looking at something that is pretty state-of-the-art and is really
[01:16:38.340 --> 01:16:43.620]   easy for us to understand. So that's one of the reasons we're using VGG.
[01:16:43.620 --> 01:16:48.180]   Another reason we're using VGG is it's excellent for the kinds of problems that we were just
[01:16:48.180 --> 01:16:54.940]   talking about that Robin with his satellite imagery has, which is it's a great network
[01:16:54.940 --> 01:17:01.220]   for changing so that it works for your problem, even if your problem is a little different.
[01:17:01.220 --> 01:17:09.320]   So there's a number of reasons that VGG is a really great thing for us to be using.
[01:17:09.320 --> 01:17:16.460]   My strong preference is to start out by showing you how to do things that you can use tomorrow,
[01:17:16.460 --> 01:17:21.500]   rather than starting with the 1+1 and showing you how you can do things that are useful
[01:17:21.500 --> 01:17:24.340]   in 6 years' time after you've got your Ph.D.
[01:17:24.340 --> 01:17:30.940]   So I'm going to start out by showing you 7 lines of code that do everything you need.
[01:17:30.940 --> 01:17:36.060]   And to get to the punchline, the state-of-the-art for dogs vs cats in the academic literature
[01:17:36.060 --> 01:17:46.420]   is 80% accuracy. This gives you 97% accuracy. And you don't need to do anything else.
[01:17:46.420 --> 01:17:53.460]   For you after this class to see if you can get everything working, basically your job
[01:17:53.460 --> 01:18:01.460]   will be can you run these 7 lines of code. And if you can, then you can rerun it on your
[01:18:01.460 --> 01:18:05.980]   own dataset as long as you structure the directories the way that I just showed you.
[01:18:05.980 --> 01:18:11.180]   So what I'm going to do is I'm going to go through these 7 lines of code, or something
[01:18:11.180 --> 01:18:17.860]   very similar to them, line by line and show you some pictures of what we're doing along
[01:18:17.860 --> 01:18:24.140]   the way. I wanted to start by showing you the 7 lines of code though because we're going
[01:18:24.140 --> 01:18:27.900]   to be looking at all kinds of things along the way in order to really understand what's
[01:18:27.900 --> 01:18:35.020]   going on. And at some point you might start thinking, gosh there's a lot to do to do deep
[01:18:35.020 --> 01:18:40.460]   learning. But there's not. There's a lot to do to really explain and talk about and visualize
[01:18:40.460 --> 01:18:46.220]   and think about deep learning. But for you to actually do image classification, you just
[01:18:46.220 --> 01:19:02.620]   need these 7 lines of code.
[01:19:02.620 --> 01:19:08.140]   So what does it mean to train a model that's already trained? Yes, you're getting a little
[01:19:08.140 --> 01:19:12.740]   bit ahead of us, but it's great to answer these questions many times. So let's try and
[01:19:12.740 --> 01:19:20.320]   make a starting answer out of it. In this case, the VGG model has been trained to recognize
[01:19:20.320 --> 01:19:29.580]   photos of the 1000 types that are in the ImageNet competition. There's a number of reasons why
[01:19:29.580 --> 01:19:32.900]   that does not give us dogs versus cats.
[01:19:32.900 --> 01:19:41.340]   Reason #1 is that if we go into the animals section of ImageNet, here we are, animals,
[01:19:41.340 --> 01:19:56.460]   beings and beasts and brutes are domesticated, I guess. Dogs, hunting dogs, sporting dogs,
[01:19:56.460 --> 01:19:59.780]   pointers, visla.
[01:19:59.780 --> 01:20:10.140]   So they have 2,332 pictures of visla, also known as the Hungarian pointer. So you could
[01:20:10.140 --> 01:20:14.740]   go through and run it and go back and find all the vislas and the German short-somethings
[01:20:14.740 --> 01:20:20.180]   and the setters and say they're all dogs, but that's something you would have to do.
[01:20:20.180 --> 01:20:26.940]   So that's one shortcoming of the VGG approach compared to what we actually want. The second
[01:20:26.940 --> 01:20:33.860]   shortcoming is that sometimes it's going to get it wrong. It might get it wrong for really
[01:20:33.860 --> 01:20:40.340]   good reasons. For example, maybe this one comes back with snow. But in fact it's going to
[01:20:40.340 --> 01:20:43.940]   come back not just with snow, but it's going to come back with a probability for every
[01:20:43.940 --> 01:20:49.740]   one of the 1000 categories. So it will be probability of 0.0003 that it's a mushroom
[01:20:49.740 --> 01:20:59.140]   and 0.0002 that it's an airport and 0.4 that it's snow and 0.3 that it's a German shepherd.
[01:20:59.140 --> 01:21:06.140]   And so we want to take advantage of all of that information as well. So what this actually
[01:21:06.140 --> 01:21:10.620]   does is it does something called fine-tuning, which we're about to learn a lot about. And
[01:21:10.620 --> 01:21:15.620]   what fine-tuning does is it takes that pre-trained image model and says, "Use everything you
[01:21:15.620 --> 01:21:22.900]   know about the 1000 categories to figure out which one are cats and which one are dogs."
[01:21:22.900 --> 01:21:26.960]   That's a great question, and we're going to go back and talk about that a second time
[01:21:26.960 --> 01:21:29.100]   when we get there.
[01:21:29.100 --> 01:21:34.160]   So this code is going to work for any image recognition task with any number of categories
[01:21:34.160 --> 01:21:41.500]   regardless of whether those categories are in ImageNet or not. And really the only image
[01:21:41.500 --> 01:21:45.300]   kind of processing image recognition that they're not going to do is something where
[01:21:45.300 --> 01:21:53.740]   you want to recognize lots of objects. This is specifically for recognizing A+.
[01:21:53.740 --> 01:22:04.580]   So let's see how it works. So the VGG object, let's run this. VGG is not defined, so I need
[01:22:04.580 --> 01:22:17.320]   to from VGG import VGG 16. When something's running, it has a little star. You will probably
[01:22:17.320 --> 01:22:21.780]   get this warning that cuDNN is more recent than the one Theano officially supports.
[01:22:21.780 --> 01:22:26.540]   So this is a good time to talk about some of the layers that we have going on. In this
[01:22:26.540 --> 01:22:42.660]   example we're using our VGG 16 class. It is sitting on top of, as we will see this in
[01:22:42.660 --> 01:22:47.860]   detail, Keras, which is the main deep learning library we're using and we'll talk a lot about.
[01:22:47.860 --> 01:22:54.580]   Keras is sitting on top of Theano, which we'll be talking about quite a bit, but less than
[01:22:54.580 --> 01:23:08.580]   Keras. Theano is the thing that takes Python code and turns it into compiled GPU code. Theano
[01:23:08.580 --> 01:23:18.540]   is sitting on top of a number of things, broadly speaking, NVIDIA's CUDA programming environment.
[01:23:18.540 --> 01:23:31.900]   And part of CUDA is the CUDA deep neural network library, cuDNN. For most important things
[01:23:31.900 --> 01:23:39.540]   in deep learning, Theano is simply calling a function inside cuDNN. So one of the things
[01:23:39.540 --> 01:23:45.540]   that we've set up for you in the AMIs and the scripts is to get all of this stuff stuck
[01:23:45.540 --> 01:23:46.540]   together and working.
[01:23:46.540 --> 01:24:05.100]   Keras is all written in pure Python, and what it does is it takes your deep learning architectures
[01:24:05.100 --> 01:24:12.160]   and code and turns it into, in our case, Theano code, and it can also turn it into TensorFlow
[01:24:12.160 --> 01:24:23.180]   code. TensorFlow and Theano are very similar. They're both libraries that sit on top of
[01:24:23.180 --> 01:24:34.180]   CUDA and provide a kind of Python to GPU mapping, and lots of libraries on top of that. TensorFlow
[01:24:34.180 --> 01:24:40.420]   comes out of Google, and it is particularly good for stuff that Google really cares about,
[01:24:40.420 --> 01:24:45.260]   and in particular, running things on lots and lots of GPUs.
[01:24:45.260 --> 01:24:50.720]   One of the things you'll hear a lot is you can't do anything with deep learning unless
[01:24:50.720 --> 01:24:56.780]   you have shitloads of data and shitloads of GPUs. That is totally, totally wrong, as you'll
[01:24:56.780 --> 01:25:03.300]   see throughout this course. It is true if you want to win ImageNet next year, you will
[01:25:03.300 --> 01:25:09.180]   need lots and lots of GPUs because you will be competing for that last 0.1% against Google
[01:25:09.180 --> 01:25:14.180]   and against Microsoft and against Baidu. However, if you're trying to recognize 10 different
[01:25:14.180 --> 01:25:19.740]   skin lesions, like the folks that I showed you, they were the first people to try to
[01:25:19.740 --> 01:25:27.260]   do that with deep learning, and they quadrupled the previous state of the art using one GPU
[01:25:27.260 --> 01:25:30.620]   and a very small amount of data that they had hand collected.
[01:25:30.620 --> 01:25:36.640]   So the reason you see a lot of this stuff about lots of GPUs and lots of data is it's
[01:25:36.640 --> 01:25:40.460]   part of trying to make neural networks call rather than uncall. It's trying to make it
[01:25:40.460 --> 01:25:46.500]   exclusive rather than inclusive. It's like unless you're us, you're not in the club.
[01:25:46.500 --> 01:25:52.780]   I really don't want you to go in for that kind of thing. You will find again and again
[01:25:52.780 --> 01:25:59.220]   it's not true. As I've just shown you, in fact, with seven lines of code, you can turn
[01:25:59.220 --> 01:26:05.260]   the state of the art from a 20% error rate to a 3% error rate, and it takes about five
[01:26:05.260 --> 01:26:11.780]   minutes to run on a single GPU which costs 90 cents an hour.
[01:26:11.780 --> 01:26:22.620]   I am not going to be talking much about TensorFlow in this course because it's still very early,
[01:26:22.620 --> 01:26:29.180]   it's still very new, it does some cool things but not the kind of cool things that uncool
[01:26:29.180 --> 01:26:36.860]   people need access to. Theano, on the other hand, has been around quite a lot longer.
[01:26:36.860 --> 01:26:44.500]   It's much easier to use. It does not do multi-GPUs well, but it does everything else well.
[01:26:44.500 --> 01:26:53.340]   If you build something in Keras and you get to a point where you're like, okay, this is
[01:26:53.340 --> 01:26:58.460]   working great, we've got a 400% improvement in the state of the art, I want the extra
[01:26:58.460 --> 01:27:05.940]   5% that comes from running this on eight GPUs. It's a simple configuration change to change
[01:27:05.940 --> 01:27:13.420]   the back-end to TensorFlow, and specifically I want to show you that configuration change.
[01:27:13.420 --> 01:27:17.940]   You'll find in your home directory, so for those of you that haven't used Bash before,
[01:27:17.940 --> 01:27:22.620]   when you see tilde, that just means your home directory. In your home directory there is
[01:27:22.620 --> 01:27:32.500]   a .keras folder, and in there there is a keras.json file, and this is the configuration. And you'll
[01:27:32.500 --> 01:27:43.740]   see here backend, theano, so if you change this to say TensorFlow and rerun it, it's
[01:27:43.740 --> 01:27:51.380]   now using TensorFlow. And TensorFlow will use all of your GPUs. If you do that, I also suggest
[01:27:51.380 --> 01:27:58.820]   changing this thing here that says th, which stands for theano, to tf that stands for TensorFlow.
[01:27:58.820 --> 01:28:04.500]   We may talk about that in the next course, it's a pretty minor detail.
[01:28:04.500 --> 01:28:13.140]   The other configuration file to be aware of is the theano-rc. You'll find a lot of unix-y
[01:28:13.140 --> 01:28:25.780]   things are something-rc. I want to point out that there's a really important line here
[01:28:25.780 --> 01:28:33.820]   which is device=. This is either GPU or CPU. If you're using a T2 instance, you will find
[01:28:33.820 --> 01:28:40.020]   that the AMI we've created has changed the G to a C. That's because the T2 instance does
[01:28:40.020 --> 01:28:45.980]   not support GPU. So if you want to switch from GPU to CPU, just change the G to a C or C to
[01:28:45.980 --> 01:28:53.380]   a G. So those are the two configuration pieces that you may need to know about. For this
[01:28:53.380 --> 01:28:57.060]   class, you won't really need to know about those because everything's been set up for
[01:28:57.060 --> 01:29:04.300]   you, but I'd like to show you what's going on behind the scenes.
[01:29:04.300 --> 01:29:12.840]   So this warning that cuDNN is too recent, if you see any problems, try updating theano
[01:29:12.840 --> 01:29:18.380]   with ngrading cuDNN. I haven't found any problems, so you can ignore that warning. It just means
[01:29:18.380 --> 01:29:28.420]   that we're using a more up-to-date version of cuDNN than the theano authors have tested.
[01:29:28.420 --> 01:29:37.200]   We create our VGG object. In doing so, there's a whole bunch of stuff going on behind the
[01:29:37.200 --> 01:29:43.100]   scenes. We're going to look at all of it. By the end of the next lesson, you will understand
[01:29:43.100 --> 01:29:47.620]   every line of code in our VGG script.
[01:29:47.620 --> 01:30:08.500]   For now, I would just point out that you can look at it because you downloaded it, and inside it, you'll see there is 100 lines of code. So it's not very big at all. So we're going to understand all of it by the end of the next class.
[01:30:08.500 --> 01:30:13.860]   For now, let's treat it as a back box. There's a pre-trained network, it's called VGG16. We
[01:30:13.860 --> 01:30:21.260]   now have a VGG object which gives us access to that pre-trained network.
[01:30:21.260 --> 01:30:34.380]   With deep learning, we don't look at images or data items one at a time, we also don't
[01:30:34.380 --> 01:30:40.100]   look at them a whole data set at a time. We look at them a few at a time. And the number
[01:30:40.100 --> 01:30:45.100]   that we look at, or that little few that we look at at a time, we call either a batch
[01:30:45.100 --> 01:31:00.020]   or a mini-batch.
[01:31:00.020 --> 01:31:07.260]   A mini-batch is simply grabbing, in this case, images, a few images at a time, and the size
[01:31:07.260 --> 01:31:15.620]   of that is the size of the batch, and computing on all of those at once. Why don't we do one
[01:31:15.620 --> 01:31:20.140]   at a time?
[01:31:20.140 --> 01:31:27.020]   The reason that we don't do one at a time is because a GPU needs to do lots of things
[01:31:27.020 --> 01:31:31.740]   at once to be useful. It loves running on thousands and thousands of things at the same
[01:31:31.740 --> 01:31:35.460]   time, because it can do all of them at the same time. So a single image is not enough
[01:31:35.460 --> 01:31:39.180]   to keep your GPU busy and it's slow.
[01:31:39.180 --> 01:31:45.180]   Why not do all of it, the whole data set at once? Well first of all, your GPU only has
[01:31:45.180 --> 01:31:52.100]   a certain amount of memory, generally somewhere between about 2GB and about 12GB. And generally
[01:31:52.100 --> 01:31:58.900]   speaking, your data set is unlikely to fit in that memory. And secondly, there's just
[01:31:58.900 --> 01:32:01.980]   no need to do the whole lot. Generally, pretty much everything you want to do, we can do
[01:32:01.980 --> 01:32:08.620]   a small amount at a time. So in this case, I'm just going to show you how we can look
[01:32:08.620 --> 01:32:14.700]   at the result of this BGG model. And so we're just going to do 4 at a time. So there's a
[01:32:14.700 --> 01:32:21.460]   get batches command which basically says, in our BGG model, let's look inside the path
[01:32:21.460 --> 01:32:27.900]   that we've defined, and remember that path we made the sample path, and grab 4 at a time.
[01:32:27.900 --> 01:32:37.100]   So we've got an error, that's good. No such directory. Missing a trailing slash. So it's
[01:32:37.100 --> 01:32:42.140]   good to see these kind of errors, so we'll just go back to where we defined it, add our
[01:32:42.140 --> 01:32:50.140]   trailing slash, and go back down, and run it again.
[01:32:50.140 --> 01:32:55.340]   So we're in the sample, so there's 16 images. So let's grab one batch. And so that's going
[01:32:55.340 --> 01:33:07.060]   to grab 4 images and 4 labels. So here are the 4 images, and here are the 4 labels. And
[01:33:07.060 --> 01:33:18.580]   so you can see that it's labeling it 0, 1 if it's a dog, and it will be 1, 0 if it's
[01:33:18.580 --> 01:33:28.380]   a cat. So now that we've done that, so that's basically what our data looks like, we can
[01:33:28.380 --> 01:33:35.900]   call BGG.predict, passing in the images. And so that's now going to ignore the labels of
[01:33:35.900 --> 01:33:40.360]   what it actually is, and it's going to use this pretrained model and tell us what does
[01:33:40.360 --> 01:33:50.060]   it think the 4 things are. In this case, if we run it, it thinks they're a rottweiler,
[01:33:50.060 --> 01:33:55.620]   an Egyptian cat, a toy terrier, and a rottweiler. So you can see it's clearly made a mistake
[01:33:55.620 --> 01:34:01.020]   here. It's very rare that actually I find it makes a mistake, so I'm glad it did make one.
[01:34:01.020 --> 01:34:07.620]   And you can see it must have been confused by all the awkward stuff going on in the background.
[01:34:07.620 --> 01:34:12.440]   So it's also shown you for this one that's a toy terrier, here are the probabilities
[01:34:12.440 --> 01:34:18.800]   of each. It's only 24% sure that it's a toy terrier. So you can see that it does actually
[01:34:18.800 --> 01:34:24.260]   know that it's not a rottweiler, whereas the rottweiler is very sure it's a rottweiler.
[01:34:24.260 --> 01:34:27.980]   How come it's not so sure it's an Egyptian cat? Well that's because there's lots of cats
[01:34:27.980 --> 01:34:32.100]   that look a little bit like an Egyptian cat. It doesn't quite know which one it is. So
[01:34:32.100 --> 01:34:35.980]   we could have a look at all of those details and see exactly which other ones it thought
[01:34:35.980 --> 01:34:41.560]   it would be. And we'll be looking at that in the next lesson.
[01:34:41.560 --> 01:34:51.120]   So the final thing I'm going to do is to show you how we can take these probabilities and
[01:34:51.120 --> 01:34:56.580]   turn them into a dogs vs cats model. I'm going to do it quickly now and then I'm going to
[01:34:56.580 --> 01:35:01.900]   revisit this in the start of the next class since we're out of time.
[01:35:01.900 --> 01:35:08.500]   So to take that thousand probabilities, so we're just showing one probability from each,
[01:35:08.500 --> 01:35:11.580]   but there's actually a thousand probabilities for each. This is the probability that it's
[01:35:11.580 --> 01:35:15.720]   a tench, it's a goldfish, it's a great white shark, so on and so forth. To take those thousand
[01:35:15.720 --> 01:35:22.860]   probabilities and turn it into a dog vs a cat prediction, we basically do exactly what
[01:35:22.860 --> 01:35:30.300]   we did before, just to say get batches, that we call fine-tune. And what fine-tune is going
[01:35:30.300 --> 01:35:40.340]   to do is build a new model and replace the thousand categories with the two classes that
[01:35:40.340 --> 01:35:41.340]   it's found.
[01:35:41.340 --> 01:35:50.380]   And how does it know what the two classes are? Well that's because we have directories
[01:35:50.380 --> 01:35:57.520]   called cats and dogs. So the fine-tune command has now created a model that checks for cats
[01:35:57.520 --> 01:36:04.020]   and dogs. Just creating the model is not enough, we have to actually run it, train it. So if
[01:36:04.020 --> 01:36:12.300]   we then go .fit, it will then use that gradient descent method that I talked about earlier,
[01:36:12.300 --> 01:36:17.780]   that propagation, and it will attempt to make that model better and better at determining
[01:36:17.780 --> 01:36:19.500]   cats vs dogs.
[01:36:19.500 --> 01:36:26.140]   Now obviously doing it on just 16 data items is a) fast, but b) not very accurate. So I
[01:36:26.140 --> 01:36:30.980]   can run it a few times and you can see that the accuracy is actually getting higher and
[01:36:30.980 --> 01:36:36.540]   higher each time, but the validation accuracy is not getting much higher. And that's because
[01:36:36.540 --> 01:36:38.300]   I'm running it on the sample.
[01:36:38.300 --> 01:36:45.260]   So if I ran it on the full dataset, it would take about 5 minutes to run and you try it
[01:36:45.260 --> 01:36:49.300]   when you get home, give it a go and see what accuracy you get. If you want to make the
[01:36:49.300 --> 01:36:56.300]   accuracy higher, just rerun this cell a bunch of times.
[01:36:56.300 --> 01:37:03.300]   So that's the end of today's class. It's the class which is kind of like the opening of
[01:37:03.300 --> 01:37:07.900]   a novel when you have to introduce all of the characters and their backstories and stuff.
[01:37:07.900 --> 01:37:12.460]   So a little bit less deep learning goes on in the first class, a little bit more getting
[01:37:12.460 --> 01:37:20.440]   set up. Your first week is likely to be the most frustrating and challenging week because
[01:37:20.440 --> 01:37:25.140]   many of you will find you've got some kind of configuration problem or you don't understand
[01:37:25.140 --> 01:37:32.780]   how some piece of the stuff fits together. Don't worry, by the end of the 7 weeks, that
[01:37:32.780 --> 01:37:36.300]   stuff is all going to be straightforward and all of the interesting bits will be in the
[01:37:36.300 --> 01:37:37.300]   deep learning.
[01:37:37.300 --> 01:37:41.460]   So I think the more time you can put into this week, making sure that you get all of
[01:37:41.460 --> 01:37:46.540]   that infrastructure stuff working and comfortable with what it is, take all of the things I've
[01:37:46.540 --> 01:37:50.700]   introduced today, look at the video and go and Google all the stuff that you're not already
[01:37:50.700 --> 01:37:55.900]   familiar with, understand how it works, anything you're unclear about, ask us and your colleagues
[01:37:55.900 --> 01:38:01.620]   on the Slack channel, on the forums. Teaching is the best way to learn, so go to the wiki
[01:38:01.620 --> 01:38:06.540]   and try to explain the things you've learned. Make sure that you can run the code up to
[01:38:06.540 --> 01:38:12.260]   here that we've seen today. For those of you who are pretty familiar with most of this
[01:38:12.260 --> 01:38:17.460]   already, make sure that you can run this code on a different dataset and we'll talk about
[01:38:17.460 --> 01:38:21.780]   some possible different datasets that you can use tomorrow.
[01:38:21.780 --> 01:38:26.740]   Any of you that want to go further, please let Rachel or I know. We have lots of ideas
[01:38:26.740 --> 01:38:32.180]   for ways that you can extend this a long way. Thank you so much all for coming and I'll
[01:38:32.180 --> 01:38:35.580]   see you next week and talk to you during the week. Make sure that you've got your teammates'
[01:38:35.580 --> 01:38:38.500]   details so that you can all stay in touch. Thank you.
[01:38:38.500 --> 01:38:44.260]   [Applause]
[01:38:44.260 --> 01:38:54.260]   [BLANK_AUDIO]

