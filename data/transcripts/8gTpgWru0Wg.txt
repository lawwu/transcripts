
[00:00:00.000 --> 00:00:10.560]   AVAILABLE NOW: Building AI Agents with Cloud in Amazon Bedrock.
[00:00:10.560 --> 00:00:21.360]   Today, I am excited to explore how to create intelligent, autonomous AI systems that can
[00:00:21.360 --> 00:00:24.580]   transform your applications.
[00:00:24.580 --> 00:00:25.840]   My name is Dewan Lightfoot.
[00:00:25.840 --> 00:00:28.240]   I am a developer advocate at AWS.
[00:00:28.240 --> 00:00:30.080]   I am Banjo Abiyami.
[00:00:30.080 --> 00:00:32.080]   I am a systems architect at AWS.
[00:00:32.080 --> 00:00:33.400]   Hi, everyone.
[00:00:33.400 --> 00:00:34.580]   My name is Suman Devanath.
[00:00:34.580 --> 00:00:36.940]   I am a developer advocate at AWS.
[00:00:36.940 --> 00:00:41.920]   Now, this will be a hands-on keyboard event.
[00:00:41.920 --> 00:00:47.000]   So we have a live workshop where you can log into an environment and get started with some
[00:00:47.000 --> 00:00:48.000]   code.
[00:00:48.000 --> 00:00:53.080]   So, we are going to go through a few slides to kind of level set and get everyone on the
[00:00:53.080 --> 00:00:56.480]   same page, and then we will hop into the workshop.
[00:00:56.480 --> 00:01:02.320]   Now, this is Code with Cloud.
[00:01:02.320 --> 00:01:07.440]   And one of the things that I want to talk about is Anthropic on AWS.
[00:01:07.440 --> 00:01:15.820]   To do that, we have Amazon Bedrock, which is a fully managed service that provides you access
[00:01:15.820 --> 00:01:21.660]   to powerful foundational models, like those in the cloud family through a unified API.
[00:01:21.660 --> 00:01:29.660]   This gives you everything you need to not only build, but also scale your AI applications globally.
[00:01:29.660 --> 00:01:35.500]   And it does this by providing you with everything you need.
[00:01:35.500 --> 00:01:46.460]   Model choice, guardrails, as well as it gives you security at enterprise grade at default.
[00:01:46.460 --> 00:01:49.420]   Now, we're talking agents.
[00:01:49.420 --> 00:01:52.300]   That's what everyone is here to see.
[00:01:52.300 --> 00:01:55.420]   But we kind of need to level set what that really means.
[00:01:55.420 --> 00:01:59.260]   And at AWS, we explain it like this.
[00:01:59.260 --> 00:02:09.260]   An agent is an autonomous system that can reason, plan, and take multiple steps to perform an
[00:02:09.260 --> 00:02:11.260]   objective like humans.
[00:02:11.260 --> 00:02:19.100]   So if you have a task and you give it to an agent, the agent is able to take that task and say,
[00:02:19.100 --> 00:02:21.500]   "Here is the high-level objective.
[00:02:21.500 --> 00:02:24.620]   Let me create a plan of the steps that I need to take."
[00:02:25.340 --> 00:02:28.540]   Then it can take actions on those steps.
[00:02:28.540 --> 00:02:33.020]   And once those steps have been taken, the actions have been taken on those steps,
[00:02:33.020 --> 00:02:39.900]   then it can evaluate the results and reason on what needs to happen next until it actually achieves
[00:02:39.900 --> 00:02:40.700]   that objective.
[00:02:40.700 --> 00:02:46.060]   This is an agentic system that we'll be discussing today.
[00:02:46.060 --> 00:02:52.700]   Now, at AWS, we've also done something awesome that my colleague,
[00:02:52.700 --> 00:02:55.100]   Souman, is going to talk about at this time.
[00:02:55.100 --> 00:02:58.460]   Thank you so much, Duan.
[00:02:58.460 --> 00:03:04.700]   So taking one step further, what we have done, in fact, last week, last Friday,
[00:03:04.700 --> 00:03:11.020]   we have announced an open source SDK to build an agentic application called strands agent.
[00:03:11.020 --> 00:03:21.420]   So what this agent does is it's a very simple SDK which needs three things: models, tools, and prompt.
[00:03:22.220 --> 00:03:23.980]   It cannot go any simpler than that.
[00:03:23.980 --> 00:03:32.460]   It doesn't have any scaffolding that you don't have to guardrail your prompts, your
[00:03:32.460 --> 00:03:40.540]   backstory, goals, etc. What we believe in is that in today's world, the LLMs are pretty strong and we
[00:03:40.540 --> 00:03:47.500]   want to make use of the full strength of the model in the backend. So we are giving the better flexibility
[00:03:47.500 --> 00:03:52.540]   for the model to reason on behalf of us. And that's why, if you look at this architecture,
[00:03:52.540 --> 00:03:59.020]   it's very straightforward. You create a prompt or this is your question. You send it to the agent,
[00:03:59.020 --> 00:04:06.940]   which is the strands agent. And when you create an agent object, you will define the model and tools
[00:04:06.940 --> 00:04:14.780]   that we provide to you. You will see in the workshop when Banjo will go through a couple of the demos,
[00:04:14.780 --> 00:04:23.980]   you will see that the default model that we use is Claude 3.7, as of today. And the moment you have
[00:04:23.980 --> 00:04:32.220]   strands installed and configured, you get a bunch of tools inbuilt. So you don't have to write heavy lifting
[00:04:32.220 --> 00:04:39.740]   code to create a few of your basic needs. And the best part is not only for your testing
[00:04:39.740 --> 00:04:46.300]   and deployment in the test environment, you can actually deploy on the cloud. So assume that you
[00:04:46.300 --> 00:04:55.260]   have your workforce in EC2 or Lambda or ECS, you can just deploy your code with ease with the integrated
[00:04:55.260 --> 00:05:04.460]   support for all these services. So to get started, just take a snap of this. This contains the
[00:05:04.460 --> 00:05:13.020]   launch blog, as well as the documentation, which is nothing but strands agent.com and the GitHub.
[00:05:13.020 --> 00:05:23.020]   And this is an open source project, so feel free to give a star and just raise a PR. If you have
[00:05:23.020 --> 00:05:28.140]   anything interesting that you built or if you have any specific requirement which is not there,
[00:05:28.140 --> 00:05:36.860]   feel free to contribute. It's just three days old and we got many PR and feedback from the community,
[00:05:36.860 --> 00:05:41.660]   and we would love to work with all of you. All right. So the moment you're all waiting for,
[00:05:41.660 --> 00:05:47.340]   it's time to build. So we have pre-configured AWS accounts for you.
[00:05:47.340 --> 00:05:52.940]   VS code is also configured so there's nothing you need to download. Everything is done in the browser.
[00:05:52.940 --> 00:05:56.780]   So when you go to this URL, it's going to take you to our pop-up screen and you're going to
[00:05:56.780 --> 00:06:04.140]   sign in. It's going to ask you for a one-time password. That's the best way to log in. And once
[00:06:04.140 --> 00:06:08.060]   you do that, you're going to be able to have access to the AWS account as well as the VS code server we
[00:06:08.060 --> 00:06:12.860]   spun up. So we're going to take a few minutes to get set up. I always say this is the hardest part
[00:06:12.860 --> 00:06:18.300]   of the workshop. So Tumon and Duan are going to be walking through. Ask any questions, raise your hand,
[00:06:18.300 --> 00:06:24.300]   and I'll also walk through it. But take some minutes to get started and let's start building.
[00:06:24.300 --> 00:06:28.780]   So when you log in, you'll get to a screen like this. So I'll give a couple more minutes to get to
[00:06:28.780 --> 00:06:33.020]   the screen and I'll walk through setting up bedrock so we can have access to the models and then to our
[00:06:33.020 --> 00:06:39.660]   VS code server. While people are waiting, I have a video to highlight what strands can do so I can
[00:06:39.660 --> 00:06:45.660]   just show that in the meantime. So in this example, we actually have a strands agent that's actually
[00:06:45.660 --> 00:06:51.580]   going to create a math video for this. So it's actually pretty cool. So let's see what happens here.
[00:06:51.580 --> 00:06:59.900]   So it's running an MCP server. It's going to start that. It's going to actually create an animation
[00:06:59.900 --> 00:07:06.620]   video for us. So it's going to create a maxim scene to draw the cubic function, 2x cubed. Yeah,
[00:07:06.620 --> 00:07:13.180]   something hard that you might have to do in latex, scientific. Like this is very annoying. But we'll see
[00:07:13.180 --> 00:07:16.700]   how the MCP server is actually going to build it and actually make a video to highlight it.
[00:07:16.700 --> 00:07:24.540]   How many of you have heard of 3, blue, one, brown? So that is what you are going to see now. So we
[00:07:24.540 --> 00:07:31.100]   have created an MCP server which can create the video that you see in 3, blue, one, brown. So we have
[00:07:31.100 --> 00:07:37.500]   created a quadratic equation and we wanted to plot that within the range of minus 3 to 3. And this is
[00:07:37.500 --> 00:07:45.820]   powered by cloud 3.7 and strands. So we'll push that code in the GitHub repo which we have shared earlier.
[00:07:45.820 --> 00:07:51.020]   Let's see what we have here. But this is just a testimony of how you can get started quickly
[00:07:51.020 --> 00:07:53.660]   with the out-of-the-box tools and just a few lines of code.
[00:07:53.660 --> 00:08:00.380]   Thank you. So the first thing to do is make sure you log into this AWS account. So you should
[00:08:00.380 --> 00:08:04.940]   not be using your own AWS account. We have already provisioned one with all the resources needed.
[00:08:04.940 --> 00:08:12.060]   It's open AWS console. And it will open up a new account, new like this. You should see this workstop
[00:08:12.060 --> 00:08:15.340]   participant role. So you should not be using your own AWS account if you haven't.
[00:08:15.340 --> 00:08:20.140]   From here we're going to type bedrock, Amazon bedrock.
[00:08:20.140 --> 00:08:28.060]   So when we get to the Amazon bedrock console screen, we're going to want to enable the models so we can
[00:08:28.060 --> 00:08:36.140]   use them in our lab. So give it a second. I'm going to scroll down to this model access button.
[00:08:36.140 --> 00:08:40.860]   And then I click the modify model access.
[00:08:43.420 --> 00:08:47.260]   And we've got some new models, but they have not enabled them yet. So we're just going to use
[00:08:47.260 --> 00:08:54.780]   Claude V7, 3.5 Haiku, and 3.5 Sonnet. So enable those.
[00:08:54.780 --> 00:08:56.140]   Hey, you got the four already.
[00:08:56.140 --> 00:09:00.780]   We got four already, yes. But I don't think it's enabled in this account yet. So we've got to use the
[00:09:00.780 --> 00:09:06.460]   older models. So I'm going to press next. Once we request access, submit.
[00:09:07.900 --> 00:09:11.260]   But again, this code, all the code is open source. The workshop is open source,
[00:09:11.260 --> 00:09:13.500]   and we can share the link so you can run this on yourself. So
[00:09:13.500 --> 00:09:20.460]   Module 1 is the one we're doing today. So we're going to show you how Strand Agent works and how
[00:09:20.460 --> 00:09:26.780]   you can actually build agentic workflows with it. So the first thing you do is install it. So just
[00:09:26.780 --> 00:09:32.300]   doing pip install strand agents and strand agent tools gets you what you need. And have some utility
[00:09:32.300 --> 00:09:35.820]   things, UV to download MCP servers. So I'm going to copy that command.
[00:09:35.820 --> 00:09:40.380]   Paste.
[00:09:40.380 --> 00:09:46.060]   All right. Already installed. Great. So.
[00:09:46.060 --> 00:09:52.860]   And then the cool thing with Claude Code, you actually can use it with Amazon Bedrock. So
[00:09:52.860 --> 00:09:57.340]   if you have an AWS account, you have Bedrock, you can use Claude Code without using the Entropic
[00:09:57.340 --> 00:10:02.060]   key signing in. Everything is just down to Bedrock. That's by using the export Claude Code
[00:10:02.060 --> 00:10:06.300]   environment variable. So let me go ahead and do that.
[00:10:06.300 --> 00:10:20.380]   All right. So Claude gets started. Research preview. I'm going to press dark mode. Of course.
[00:10:20.380 --> 00:10:27.180]   All right. Cool. So use recommended settings. Yes. Proceed. All right. Claude Code's ready to go.
[00:10:27.180 --> 00:10:32.300]   So all I did was just export that command because it's already used in Bedrock. Everything that's
[00:10:32.300 --> 00:10:38.700]   ready to go is already in my environment. And you all can see this, right? This is a good screen. Yeah. Cool.
[00:10:38.700 --> 00:10:50.700]   All right. So the first exercise of the workshop was actually going to use a weather count. Every AI
[00:10:50.700 --> 00:10:54.940]   thing has to start weather first. So, you know, well, we added two tools to this one. The one that can
[00:10:54.940 --> 00:10:59.660]   actually get the weather and actually count how many words are in the response just to show
[00:10:59.660 --> 00:11:05.980]   how easy it is to use different tools using strands. And we're actually going to use Claude Code to explain
[00:11:05.980 --> 00:11:12.780]   how this code works as well before I dive into it. So I'm going to open this up.
[00:11:14.780 --> 00:11:19.180]   paste. Can you explain the structure of the strand agent weather word count file?
[00:11:19.180 --> 00:11:24.780]   All right. So it's going to be able to see what happens. Use the tokens. Let me open the file while it does that.
[00:11:24.780 --> 00:11:31.500]   And we'll see what Claude says. Let me make this bigger.
[00:11:35.100 --> 00:11:41.420]   All right. So demonstrate a simple agent, implementation the strand framework, an agent file,
[00:11:41.420 --> 00:11:47.900]   import necessary, word count tools, using Claude 3.5, actually the query. So let's walk through the code
[00:11:47.900 --> 00:11:54.940]   in more detail. So we actually have a system prompt. And we're saying, you know, find the weather. And it
[00:11:54.940 --> 00:12:01.580]   actually puts the API in the system prompt, hdpweather.gov. So there's no API key needed for this. So I can just
[00:12:01.580 --> 00:12:06.860]   query this and get the actual weather of what the place is and provide it in a human readable way.
[00:12:06.860 --> 00:12:13.340]   And the cool thing about this, strands has this HTTP request tool already built into the framework.
[00:12:13.340 --> 00:12:18.300]   So it's going to be able to just make that request for you automatically. You just provide URL. It's
[00:12:18.300 --> 00:12:24.460]   able to call that and get the actual data from that. And then you can use the cool thing about strands
[00:12:24.460 --> 00:12:29.580]   also is you can change the different models you can use. You can use LLM. You can use Ollama. You can use
[00:12:29.580 --> 00:12:35.740]   Bedrock. Bedrock to default. So I just changed the Claude 3.5 just to be faster here. And then the cool
[00:12:35.740 --> 00:12:40.860]   thing about strands is that's the system prompt, the big system prompt we put up there, which tools
[00:12:40.860 --> 00:12:47.100]   we're going to use, the word count tool. Now what I really like about the tool decorator is I just
[00:12:47.100 --> 00:12:52.060]   define a function and just put the return value. There's no crazy thing, no adding. I just put this tool
[00:12:52.060 --> 00:12:57.580]   decorator and it handles the rest. So as a developer building functions, I want to put all this extra stuff in
[00:12:57.580 --> 00:13:02.940]   there, make it as simple as possible to have a tool. So that's a really big plus to the strands framework.
[00:13:02.940 --> 00:13:08.780]   And then from there I can just say, what's the weather like in Seattle? Let's change it. San Francisco.
[00:13:10.300 --> 00:13:28.860]   All right, so we can see how it's going here. First I've got the coordinates for San Francisco. You can
[00:13:28.860 --> 00:13:34.220]   see the HTTP request tool. Now it's going to use the HTTP request tool to find that weather. It gets the San
[00:13:34.220 --> 00:13:40.540]   San Francisco, 65, sunny, west, winds, few days, highlight. Now it uses the word count tool, 110
[00:13:40.540 --> 00:13:45.660]   words. So we've got about 44 lines of code. We're able to make that API request. We have the agent.
[00:13:45.660 --> 00:13:51.980]   It's going to have multiple tools done. So I'll pause here for a second just to have any other questions
[00:13:51.980 --> 00:13:58.220]   with strands because everybody's going through it. So strands is an open source SDK for building agents. So
[00:13:58.220 --> 00:14:02.460]   there are a lot of agentic frameworks, but strand is its own one. And you can see that you really
[00:14:02.460 --> 00:14:07.420]   just need a system prompt, the tools, and a model, and it can execute that loop. So yeah, it is similar
[00:14:07.420 --> 00:14:12.380]   to other agentic frameworks, but I believe it's much easier to get started without the boilerplate and extra
[00:14:12.380 --> 00:14:18.940]   stuff that you've seen in other frameworks. All right. One more question and we'll move on to the next part.
[00:14:18.940 --> 00:14:24.780]   Thank you. So I have a code-related question. So how are you passing the latitude, longitude,
[00:14:24.780 --> 00:14:29.180]   and zip code inside the string? Right. So the cool thing is that we're
[00:14:29.180 --> 00:14:35.180]   letting the model decide how to do that. It uses this HTTP request thing and it understands what the
[00:14:35.180 --> 00:14:41.500]   latitude and longitude is of San Francisco and is able to pass that to this API endpoint or use API zip code.
[00:14:41.500 --> 00:14:47.980]   So it understands what the API is based on the system prompt and the model is figuring it out by itself.
[00:14:47.980 --> 00:14:53.420]   So we're handing a lot of the infrastructure you might see in other agent frameworks to say you've got to do this,
[00:14:53.420 --> 00:14:56.940]   you've got to do this. We're letting the model decide to do that because the model is the much more capable
[00:14:56.940 --> 00:15:00.940]   than they were two years ago when you saw the first type of agentic framework coming out.
[00:15:00.940 --> 00:15:08.300]   So the strands tools, like I see that you're importing two tools, which is like word count
[00:15:08.300 --> 00:15:14.140]   and HTTP request. So how many tools are there like? Yeah, yeah. So there's some built-in tools
[00:15:14.140 --> 00:15:18.700]   in the strand framework like HTTP request. But then I also just made my own tool, which is literally this
[00:15:18.700 --> 00:15:23.580]   one line of code, return this length. So it's very easy to make your own custom tool. You just put this
[00:15:23.580 --> 00:15:30.220]   tool decorator and that's it. So very streamlined. All right. So we're going to move on to the next exercise.
[00:15:30.220 --> 00:15:37.900]   So the next exercise is fun one, MCP servers. So you know, MCP is the hottest thing, you know. So
[00:15:37.900 --> 00:15:45.900]   what's really cool about Stranded has built-in MCC support and AWS, we actually have official AWS
[00:15:45.900 --> 00:15:50.940]   MCP servers. So I'm going to highlight the documentation lookup because AWS docs will be very
[00:15:50.940 --> 00:15:55.020]   long, a lot of different things. So if I just have one endpoint that just grab that information and pass it
[00:15:55.020 --> 00:15:59.500]   to the model, it's going to be able to understand how to build. And then an architecture diagram.
[00:15:59.500 --> 00:16:04.540]   So making AWS diagrams. So there are two MCP, there's a whole bunch of them listed here,
[00:16:04.540 --> 00:16:09.900]   but I'm going to highlight these to an example. So let's go back. And we can also ask Claude
[00:16:09.900 --> 00:16:25.420]   Claude code to explain it as well. So I have to explain how the MCP diag one works. So let me open that up while it's waiting.
[00:16:26.380 --> 00:16:38.860]   Claude code is documenting. It's looking at what to do.
[00:16:48.060 --> 00:17:07.020]   So while Claude code is going, I'll explain what's happening. That's just finished. Cool. All right.
[00:17:07.020 --> 00:17:15.180]   Import the strand. Still going. All right. So the cool thing about MCP server is we can actually just pull it in with one line.
[00:17:15.180 --> 00:17:20.220]   We just the command UVX. This is the Python material for downloading things.
[00:17:20.220 --> 00:17:24.700]   So we're going to point it to the MCP server and it will download it locally. So I'm passing in
[00:17:24.700 --> 00:17:31.100]   the documentation MCP server and I'm passing in the diagram MCP server. And then, you know, Claude's even
[00:17:31.100 --> 00:17:36.380]   saying the same thing. Connect to the MCP diagram one. Configure using bedrock. Again, I can choose
[00:17:36.380 --> 00:17:41.100]   different models on bedrock to pass in. And then I'm giving a system prompt. You're an expert
[00:17:41.100 --> 00:17:45.020]   certified solutions architect. Your role is to help customers understand best practices, query
[00:17:45.020 --> 00:17:50.220]   documentation, generate diagrams, tell the customer the full path of the diagram when you create it.
[00:17:50.220 --> 00:17:55.420]   Just so we know where it is. And then again, we just say, pass in multiple MCP servers with the
[00:17:55.420 --> 00:18:02.140]   diagram client, the docs client. We get all the tools based in those MCP servers. And then again, you know,
[00:18:02.140 --> 00:18:06.780]   we have the tools, we have the model and the system prompt. All you need to have the stands agent.
[00:18:06.780 --> 00:18:12.140]   And then we give it like, get the documentation for AWS Lambda, then create a diagram of a website
[00:18:12.140 --> 00:18:18.300]   that uses Lambda for a static website hosted on S3. So that's the task I give it. Let's see how it executes
[00:18:18.300 --> 00:18:32.940]   All right. So download the MCP servers. I already downloaded them already. And I was processing now. It breaks
[00:18:32.940 --> 00:18:37.980]   it down into steps. So first I'll search the AWS documentation. Then I'll read the document. Then I'll
[00:18:37.980 --> 00:18:44.060]   create a diagram illustrating architecture. So you can actually see its thought process. It makes an HTTP call to
[00:18:44.060 --> 00:18:50.460]   get the search. It finds the Lambda welcome page to get the information. It queried the documentation.
[00:18:50.460 --> 00:18:53.340]   Now it's going to draw the diagram. Let's see.
[00:18:53.340 --> 00:19:02.220]   It listed the icons. So what icons are available for it. Now it's actually generating the diagram. So
[00:19:02.220 --> 00:19:07.020]   excellent. It failed there, but it understood that. And it explained, let me correct the cloud icon.
[00:19:07.020 --> 00:19:12.460]   Now generated it. Explained what's happening. And it made this new diagram saved here. So I should be able
[00:19:12.460 --> 00:19:22.140]   to open it up. Generated diagrams. And ta-da! It made a new diagram for me. So. Whoops.
[00:19:22.140 --> 00:19:28.940]   Yeah. It's going to be different every time when you, of course,
[00:19:28.940 --> 00:19:33.980]   based on how much context you give it. But yeah. I'm able to make that diagram. And just about,
[00:19:33.980 --> 00:19:40.060]   you know, 40 lines of code. I have two MCP servers. I put my system prompt. Picking a different model.
[00:19:40.060 --> 00:19:45.100]   And I'm able to create that agentic workflow very quickly and very easily without any too much headache.
[00:19:45.100 --> 00:19:52.220]   So I'm going to pause here on any talks about MCP servers connecting me with strange agents.
[00:19:52.220 --> 00:20:02.700]   Is there a pattern through API Gateway to host a MCP server with Lambda? Like the server side events.
[00:20:02.700 --> 00:20:05.980]   Is there something that allows? Yeah. Yeah. Now because MCP supports the
[00:20:05.980 --> 00:20:10.300]   HTTP streaming server side event, you can have it in a Lambda function and do that. There are some,
[00:20:10.300 --> 00:20:14.060]   I believe there are some open source code that demonstrates how to do that. One of my colleagues
[00:20:14.060 --> 00:20:17.980]   have done that. So yeah, it's totally possible to do that use case. Because right now I'm just
[00:20:17.980 --> 00:20:22.140]   running the MCP server locally. But if you wanted to have it in the cloud, like a Lambda function,
[00:20:22.140 --> 00:20:25.180]   totally possible use case. You'd have to change how this is set up.
[00:20:28.220 --> 00:20:36.780]   All right. So the last exercise was we're actually going to create a new agent using cloud code to
[00:20:36.780 --> 00:20:41.820]   understand how it does without just looking at the code we have already and being able to
[00:20:41.820 --> 00:20:48.620]   understand which CDK. I'm going to make a CDK agent. So CDK is a cloud development kit. So it's a way to
[00:20:48.620 --> 00:20:54.140]   create AWS infrastructure through code. Normally, if you want to create AWS infrastructure, you might use
[00:20:54.140 --> 00:20:59.740]   something like CloudFormation, which is a YAML-based way. But if it's a developer, CDK is more preferred
[00:20:59.740 --> 00:21:03.740]   for that because you can integrate it to Python TypeScript code. So I'm going to show an example of
[00:21:03.740 --> 00:21:10.780]   how we can use cloud code to actually create a new strand agent for us. So I'm going to make this new
[00:21:10.780 --> 00:21:25.420]   file here. Oops. All right. So I created a brand new file. Nothing in it. And then I'm going to ask
[00:21:25.420 --> 00:21:31.820]   cloud code, you know, update the CDK agent to create a strand agent connecting to an MCP server. Look at the
[00:21:31.820 --> 00:21:36.300]   other files to understand how to do this. So I'm not giving you the documentation. I'm just going to say,
[00:21:36.300 --> 00:21:41.180]   you know, use the knowledge you have already to understand how to make it. So let me,
[00:21:41.180 --> 00:21:50.380]   let me get into the repo and then clod
[00:21:50.380 --> 00:22:03.340]   and ask it.
[00:22:03.340 --> 00:22:12.380]   So yeah, so now cloud code, they're going to look through, see the plan of attack it does. So let's,
[00:22:12.380 --> 00:22:13.820]   let's see what it's doing. All right.
[00:22:16.620 --> 00:22:21.980]   I'll update the CDK agent to strand agent connected to MCP server. You know, it looks at the other one.
[00:22:21.980 --> 00:22:28.300]   There's no one line of code there. I read the other word count one. All right. It finds the MCP doc one.
[00:22:28.300 --> 00:22:33.340]   It examines it. Cross it off the list. All right. On to the next one. Create a stand agent. It put all
[00:22:33.340 --> 00:22:39.180]   the code for that. It asks me, do I want to make this edit? So say yes, make the edit. It's adding the code to me.
[00:22:42.780 --> 00:22:48.140]   All right. Configure straight agent, quick MCP client, configure system prompt. It's done it.
[00:22:48.140 --> 00:22:53.260]   Perfect. So I'm going to close out of it. And what I like about cloud code actually
[00:22:53.260 --> 00:22:58.220]   tells us how much it costs when you end it. So the total cost, how long the API took, you know,
[00:22:58.220 --> 00:23:03.820]   how many code changes, how, which models it use. It used cloud 3.5 site haiku, use click full site
[00:23:03.820 --> 00:23:08.940]   sign it to understand what the best way is. So using cloud code of bedrock, that's an easy way to get
[00:23:08.940 --> 00:23:13.900]   started in building applications like this. And it's now natively inside VS code, which is very exciting.
[00:23:13.900 --> 00:23:20.060]   So let's see if the code actually works. So I'm just going to run it. Let's see your expert AWS CDK expert.
[00:23:20.060 --> 00:23:25.740]   How can I get a simple S3 bucket with CDK? Give us something simple. Let's see how it works.
[00:23:26.300 --> 00:23:43.660]   All right. So I was making a TypeScript example. I'll provide step-by-step guidance. It wrote the code for me.
[00:23:43.660 --> 00:23:54.620]   It's doing that security, Texas, add a CNN nag rule. So it really understands what CDK is. It's putting all
[00:23:54.620 --> 00:24:01.580]   this extra stuff there. And yeah, it even explained that. So cloud code is able to understand how strand
[00:24:01.580 --> 00:24:05.980]   agent works, create a new agent based on that, create a template on that. And it was very easy to
[00:24:05.980 --> 00:24:11.420]   understand. So by providing enough context, cloud code is able to understand what to do, create this agent.
[00:24:11.420 --> 00:24:15.980]   And it's pretty good job. So I'm very impressed with using cloud code and bedrock powering. That's
[00:24:15.980 --> 00:24:20.540]   also amazing. But that was kind of the workshop through and through to kind of show you what strands
[00:24:20.540 --> 00:24:26.220]   can do from a simple weather agent to connecting to MCP servers and then also making your own agents.
[00:24:26.220 --> 00:24:30.380]   I'm going to pause here for any questions or if you want to see a demonstration of something cool,
[00:24:30.380 --> 00:24:34.940]   happy to try it out and see what cloud can do. Sorry, I just have to ask like,
[00:24:34.940 --> 00:24:40.300]   what are some of the use cases for like using MCP? Like, I know I will be building agents that
[00:24:40.300 --> 00:24:45.820]   probably connect to the outer world like through APIs and all. Like, maybe I don't know a lot about
[00:24:45.820 --> 00:24:49.580]   MCP, but like what are some of the use cases you can like use MCPs for?
[00:24:49.580 --> 00:24:53.340]   Right. So a great question. What are the use cases for MCP? So by default,
[00:24:53.340 --> 00:24:59.500]   the agent doesn't have enough information to connect to external API. So you saw in the example,
[00:24:59.500 --> 00:25:04.300]   we created an AWS diagram. If I did that without an MCP server, the model would not know how to make
[00:25:04.300 --> 00:25:09.420]   the AWS diagram and won't know how to look up the AWS documentation. So providing extra context to the
[00:25:09.420 --> 00:25:14.940]   model to do extra action. So when it comes to using large-angle model, context is really that empowers
[00:25:14.940 --> 00:25:20.460]   what's going to go on. MCP provides a structured way to grab that information so it can take action,
[00:25:20.460 --> 00:25:27.660]   read documentation, connect to external applications. So MCP is really kind of the USB-C, they call it, of
[00:25:27.660 --> 00:25:32.380]   connecting the LLM. So for me, it's a great way to just connect the external applications, get different
[00:25:32.380 --> 00:25:33.420]   context for your model.
[00:25:41.420 --> 00:25:46.540]   And I'll show you some highlights of the AWS MCP servers just so you can get an example of what we have.
[00:25:46.540 --> 00:25:56.220]   So there are official lists of AWS MCP servers that do a bunch of different things. So I'll
[00:25:56.220 --> 00:26:02.220]   go through some examples. Show the documentation one. Bedrock knowledge base, if you have a bunch of
[00:26:02.220 --> 00:26:08.780]   PDFs or documents you want to give to an LLM. Cost analysis, so you want to do AWS cost analysis,
[00:26:08.780 --> 00:26:12.940]   if you want to get another example, the MCP server could be useful for you.
[00:26:12.940 --> 00:26:19.420]   Amazon Nova Canvas, if you want to draw images, Nova Canvas MVC server. The diagram one that we use
[00:26:19.420 --> 00:26:24.940]   today, you can also draw AWS architecture diagrams, cloud formation. So there's a bunch of different
[00:26:24.940 --> 00:26:31.740]   ones. And Terraform, if you use Terraform, front-end code, you want to specialize in React or using AWS
[00:26:31.740 --> 00:26:38.620]   Amplify, etc. So there's a whole source of MCP servers. So one big use case is I want
[00:26:38.620 --> 00:26:43.260]   my model to understand these things. You have a bunch of documentation, Postgres database,
[00:26:43.260 --> 00:26:48.860]   Amazon Neptune server, like so. This is really the power of MCP. So there's so many integrations
[00:26:48.860 --> 00:26:55.420]   you can have to give that model extra abilities to do. We do have AWS credits for you. So if you want
[00:26:55.420 --> 00:27:01.500]   to give us some feedback and surveys, I want you to fill this out. You'll get $25 of AWS credits to use,
[00:27:01.500 --> 00:27:06.060]   so you can play around, try some things out. But thank you for coming and let's go build.
[00:27:06.060 --> 00:27:07.060]   Thank you very much.
[00:27:07.060 --> 00:27:08.060]   Thank you very much.
[00:27:08.060 --> 00:27:09.060]   Thank you very much.
[00:27:09.060 --> 00:27:10.060]   Thank you very much.
[00:27:10.060 --> 00:27:11.060]   Thank you very much.
[00:27:11.060 --> 00:27:12.060]   Thank you.
[00:27:12.060 --> 00:27:42.040]   Thank you.

