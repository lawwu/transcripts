
[00:00:00.000 --> 00:00:10.040]   Hi, everyone. I'm Obi Fernandez, and I'm going to be talking to you today about some of the
[00:00:10.040 --> 00:00:16.720]   awesome things we're doing at Shopify, leveraging the power of Claude and Claude Code as part
[00:00:16.720 --> 00:00:23.120]   of our massive, in a way. I'll talk about that in a second. First of all, I just want
[00:00:23.120 --> 00:00:27.960]   to introduce myself. My name is Obi Fernandez. I'm a Principal Engineer in our Augmented
[00:00:27.960 --> 00:00:33.660]   Engineering Group. I work on everything that has to do with augmented engineering, in other
[00:00:33.660 --> 00:00:39.720]   words, using AI to improve developer experience at Shopify. I'm also the author of a pretty
[00:00:39.720 --> 00:00:44.100]   interesting book that you might like called Patterns of Application Development Using AI.
[00:00:44.100 --> 00:00:50.160]   So I hope that you look that up if you get a chance. Today we're going to be talking about
[00:00:50.160 --> 00:00:57.840]   the challenges of scale at Shopify engineering. We are a fairly large organization, probably
[00:00:57.840 --> 00:01:03.540]   one of the largest Ruby on Rails shops in the world. Our main application, we've been working
[00:01:03.540 --> 00:01:09.240]   on for almost 20 years, and has millions upon millions of lines of code. There's probably
[00:01:09.240 --> 00:01:17.240]   about 5,000 repos in our organization last time I checked. And we're generating about half
[00:01:17.240 --> 00:01:25.240]   a million PRs a year at last count, which is a significant amount of stuff to take into account
[00:01:25.240 --> 00:01:34.940]   when you're doing anything with AI, in terms of your context and whatnot. Our core challenge
[00:01:34.940 --> 00:01:41.940]   is how do we maintain productivity? Or rather, that's what my group focuses on. And I'm here
[00:01:41.940 --> 00:01:53.640]   to kind of tell you some of the solutions we've developed and how those interact with Cloud.
[00:01:53.640 --> 00:01:58.040]   The key, really, to understanding kind of the point of what I'm presenting, is to understand
[00:01:58.040 --> 00:02:05.640]   that there's two very, very different ways of using AI. One, which we've been immersed in
[00:02:05.640 --> 00:02:11.840]   throughout this conference today, are agentic tools. When we're talking about how to leverage AI
[00:02:11.840 --> 00:02:19.940]   as assistance and tooling, there's this agentic approach, which are ideal for scenarios that require
[00:02:19.940 --> 00:02:28.640]   adaptive decision-making, iteration, and autonomy. They shine when the tasks that you're trying to accomplish
[00:02:28.640 --> 00:02:36.840]   with AI help are exploratory or ambiguous in some way. And you're relying on the LLM's reasoning
[00:02:36.840 --> 00:02:44.340]   and judgment because your path to the solution is not known in advance. It might not be known in advance
[00:02:44.340 --> 00:02:49.840]   because it's a complex domain that you're dealing with that has factors that are changing all the time.
[00:02:49.840 --> 00:02:56.640]   It might be very, very complicated and just kind of beyond what you know. Or it might be like something as simple
[00:02:56.640 --> 00:03:02.240]   as a feature development where you're going to do some exploratory work to figure out how to implement
[00:03:02.240 --> 00:03:09.640]   that feature. Those kinds of use cases, as we've seen again and again today in the various sessions,
[00:03:09.640 --> 00:03:17.840]   are perfect for tools like Cloud Code. Anything that involves ongoing adaptation, debugging and iteration,
[00:03:17.840 --> 00:03:31.040]   is perfectly fantastic to give that to an agentic tool and see what it can do. In contrast, structured
[00:03:31.040 --> 00:03:37.840]   workflow orchestration, including what we can do with this open source tool that I'm going to present to
[00:03:37.840 --> 00:03:45.840]   you in this presentation, which we call Roast, are better for tasks that have predictable, well-defined steps.
[00:03:45.840 --> 00:03:58.840]   Cases where you seek consistency, repeatability and clear oversight. You want to leverage AI and this kind of work
[00:03:58.840 --> 00:04:05.440]   for intelligent completion of components of that bigger workflow. So far, I don't think I'm saying anything
[00:04:05.440 --> 00:04:14.440]   that is super exotic or wild. It's really the difference between non-deterministic and deterministic kind of behavior.
[00:04:14.440 --> 00:04:20.440]   And it turns out that like peanut butter and chocolate, you know, these make a great combination.
[00:04:20.440 --> 00:04:30.440]   Sometimes you want one, sometimes you want the other. In examples of what these structured workflows are great for are things like migrating legacy code bases.
[00:04:30.440 --> 00:04:41.440]   So, for instance, going from Python 2 to Python 3, from going whatever your current, you know, JavaScript implementation is based on, to whatever the new flavor of the month is.
[00:04:41.440 --> 00:04:55.440]   Or, as is the case with a lot of things that my team deals with, refactoring large systems, where it isn't really an exploratory task. Like, we know what we want to do. Maybe we're addressing performance.
[00:04:55.440 --> 00:05:05.440]   Maybe we're addressing technical debt that we understand kind of what the basis is. So, we know that we want to go through a certain amount of steps.
[00:05:05.440 --> 00:05:22.440]   Specifically, the kinds of things that we do at Shopify using Roast, which is really what we extracted this open source library out of, started with automated testing generation and test optimization.
[00:05:22.440 --> 00:05:35.440]   So, we looked at our over half a million tests associated with our main monolith and said, we would really like to address some of the coverage gaps in this code base. So, how do we go about doing that?
[00:05:35.440 --> 00:05:43.440]   Of course, one approach would be to simply open up that project in cloud code and say, hey, I want to address coverage gaps in this place.
[00:05:43.440 --> 00:05:57.440]   However, in practice, it's really helpful to break down that problem in the way that you would do it manually and say, okay, well, what would I do if I was going to work on test coverage?
[00:05:57.440 --> 00:06:06.440]   Well, first of all, I need to know what the test coverage is. If we know that every time we're going to do a series of steps, that calls for a structured workflow.
[00:06:06.440 --> 00:06:12.440]   For instance, running the coverage tool, running the test, you know, to generate the report of what needs to be covered.
[00:06:12.440 --> 00:06:21.440]   So, taking a step back for a second, we've been using cloud code for a while. We were one of the early shops that actually adopted it.
[00:06:21.440 --> 00:06:28.440]   As soon as it launched, there was interest in using it. And as soon as people started using it, we started seeing a lot of excitement in our Slack, right?
[00:06:28.440 --> 00:06:35.440]   So, I copied some of the earliest comments I could find there from March, you know, from some of our folks.
[00:06:35.440 --> 00:06:47.440]   And I pulled this graph from our AI proxy that cloud code runs through. And I think it's actually a fairly impressive amount of usage.
[00:06:47.440 --> 00:07:01.440]   We have at peak now about 500 daily active users, and that number is growing rapidly. And as of lately, we had 250,000 requests per second at peak, which is an impressive amount, I believe.
[00:07:01.440 --> 00:07:13.440]   And in fact, Roast itself, which is this open source framework that I was telling you about, is called Roast because it helps you set your money on fire.
[00:07:13.440 --> 00:07:22.440]   Yeah, think about it. So, anyway, what does it look like? I let this video kind of stay here at a workflow definition.
[00:07:22.440 --> 00:07:38.440]   So, this is a workflow orchestration tool. There's nothing super, super exotic about it. Probably one of the most interesting things about it is that it's implemented in Ruby, which is a bit of an oddity in this world where everyone uses Python and TypeScript, unfortunately.
[00:07:38.440 --> 00:07:50.440]   So, you don't need to implement anything in Ruby to use Roast for your own things. This can actually help you interleave prompt-oriented
[00:07:50.440 --> 00:08:07.440]   kind of tasks with bash scripts or, you know, whatever you want to invoke. So, anyway, why did we go through the trouble of writing Roast and open sourcing it on my team? Well, the thing is, our illustrious CEO,
[00:08:07.440 --> 00:08:26.440]   Toby Lutke has instilled throughout the years a culture of tinkering in the company. So, even without AI, we have a culture where people are constantly working on homegrown projects, little skunk works, little research, you know, things within their departments.
[00:08:26.440 --> 00:08:55.440]   And this is not only limited to engineering, it's across the board, you know, I've seen people in sales and support and things like that working on their own tooling. AI exploded that. So, you know, as soon as, you know, vibe coding became a thing, curse, you know, different kinds of tools came about and were available, like cloud code, and all the different kinds of, you know, chat completion, all of a sudden, everyone was coding across the company. And specifically, when it came to anything
[00:08:55.440 --> 00:09:25.420]   when it came to anything that looks like a structured workflow or essentially a script that puts together a number of prompts or chains them together, I think that it's probably safe to say that there's hundreds of different ways that this has been implemented across your company. And in fact, I see some of you nodding, like, if you work at big companies, you probably have seen this, like, constant reinventing of the wheel. You know, some people are using, you know, One Frameworks. Some people are using LangChain. Some people are just writing their own
[00:09:25.420 --> 00:09:39.420]   scripts. They're using their own scripts, et cetera, et cetera, et cetera. That's cool and all, but it's better, you know, if you start identifying the common needs across the organization and you put something together to really help them out. So, that's where Roast came from.
[00:09:39.420 --> 00:10:07.420]   And I want to tell you about the relationship with Cloud Code and Roast because it's a bi-directional thing, which is really, really cool. So, like I said earlier, you could try to get Cloud Code to execute a workflow, a predefined workflow. You could set up commands. You could set up a bunch of Cloud MD files. All that's well and good, and I'm not telling you -- I'm not here to tell you, hey, don't try to do that. It's just that, no matter how good the state-of-the-art models get at following instructions, there's still
[00:10:07.420 --> 00:10:35.420]   inherently non-deterministic. And you have something else which is the accumulation of entropy. And what I mean by that is that at every step of a given workflow that you just give an agent to work on independently, errors and, you know, misdirection and lack of, you know, problems with judgment, mistakes, add up, right? I'm sure if you've done any amount of prompt chaining you've seen this.
[00:10:35.420 --> 00:11:05.400]   Like, basically, something goes slightly wrong that makes the next step work a little bit worse or the model has to do more work to recover. It's not ideal. What we're finding is that interleaving, non-deterministic kinds of structured workflow with -- sorry, non-deterministic agentic workflows with deterministic kind of structured workflows and scripts is actually the perfect combination. So, what I mean by that is that you take a
[00:11:05.400 --> 00:11:20.400]   take a workflow, a big workflow, like let's say optimizing a test suite and you break it down into component parts and you minimize the amount of instructions that you have to give the agent to work on at any given step.
[00:11:20.400 --> 00:11:50.380]   So, that looks like giving Claude code roast workflows on the one side. So, on the left side of the slide here, what I'm describing is like basically you tell Claude, hey, I want to work on optimizing my tests, but I have a workflow tool that handles the grading. So, go ahead and call roast test grade with this file or this directory and then take its recommendations and work on them. So, that's one way of using roast.
[00:11:50.380 --> 00:12:20.360]   roast as a tool for Claude code. On the other side, roast includes a coding agent tool that you can add to your workflows as part of its configuration, which wraps Claude code. So, you could kick off a workflow in an automated fashion that, let's say, grades a test. And as part of the steps in that workflow, you can kick off Claude code in SDK mode and provide something that you want the agent to do.
[00:12:20.360 --> 00:12:27.360]   that you want the application to work on, but on a narrower scope than to giving it the whole thing.
[00:12:27.360 --> 00:12:50.340]   I have already talked about test grading, but to give you another example, the main application that we use at Shopify, like I said before, is a big Ruby on Rails monolith. Ruby is a dynamic language that doesn't natively have typing. So, we use an add-on typing system called Sorbet. Sorbet is
[00:12:50.340 --> 00:13:20.320]   is not something that is super, super well-known by the models. It certainly has a little bit of knowledge of it, but the kinds of tools that you invoke when you're doing type checking and preparation of type files and things like that is not something that is, let's call it, quote, unquote, intuitive to the models. Very, very helpful to break anything up that has to do with type checking or improving the application of types.
[00:13:20.320 --> 00:13:27.320]   types in our code base into these roast workflows where we actually interleave calls to the Sorbet tools that are predefined.
[00:13:27.320 --> 00:13:43.320]   that are predefined, like we're always going to run the type checking in this way with a command line and then we interleave that with giving the results of the type checking to Claude and saying, hey, please address the deficiencies that we found in this manual step.
[00:13:43.320 --> 00:13:58.320]   This is not a super compelling video. I didn't have a ton of time to prepare this talk, but basically, if the video starts here, what you'll see is the result of running one of these workflows to generate tests.
[00:13:58.320 --> 00:14:17.320]   So, it gets stuck here running coding agent. I'm talking to the Claude code team about maybe giving us some ability to output what the coding agent is doing, but we see that it's generating tests. I'm actually flipping over and running the test to verify that they run or rather to show you that they run.
[00:14:17.320 --> 00:14:35.320]   But this is kind of what it looks like at scale. It's a bit messy. I should add, if you want to try roast, it is a very early version. It does work. It has a cool set of tools. It has cool features like being able to save your session every time you run a workflow.
[00:14:35.320 --> 00:14:53.320]   So, if any of you have tried to do workflow kinds of things, one of the key benefits of using a tool like Roast is that, for instance, if you have a five-step workflow, you don't have to run the first four steps over and over again just to debug the fifth step.
[00:14:53.320 --> 00:15:00.320]   You can just go ahead and replay from the fourth step afterwards and then, you know, work on it. Big, big time saver.
[00:15:00.320 --> 00:15:10.320]   We also do things like incorporate tool function caching. A lot of times when you're developing these workflows, you're kind of working on the same dataset.
[00:15:10.320 --> 00:15:21.320]   If you're only working on an agentic tool, you kind of have to give it the whole thing and let it run from the beginning and do all the tool things that it's going to do, all the function calling.
[00:15:21.320 --> 00:15:33.320]   If you're using a tool like Roast, you can do that and have all your function, you know, calls cached at the Roast level so that they just execute super, super fast.
[00:15:37.320 --> 00:15:45.320]   I mentioned before, but just to bring it home, we are using Cloud SDK as a tool for Roast.
[00:15:45.320 --> 00:15:59.320]   So, specifically, the kinds of things that we're using that for is that the configured Roast workflow one-shots a code migration, for instance, because it's kind of like we know exactly what we want to do.
[00:15:59.320 --> 00:16:03.320]   We don't want to beat around the bush or have to discuss what it is we're going to do with Cloud.
[00:16:03.320 --> 00:16:09.320]   So, we're just going to go ahead and do that just using regular chat completion style prompting.
[00:16:09.320 --> 00:16:23.320]   And then, once we have a starting place, we hand that over to Cloud using the SDK command line and say, hey, run the test for this, and then, if it's broken, fix it, iterate on doing it.
[00:16:23.320 --> 00:16:35.320]   Again, these are things that are not necessarily that useful to the individual developer, like as they're going about their day, probably they're just going to use Cloud code.
[00:16:35.320 --> 00:16:46.320]   But if you're doing this at scale or as part of repeatable processes or as part of reacting to PRs or anything like that, you know, as part of data pipelines, it becomes super, super useful.
[00:16:46.320 --> 00:16:53.320]   I want to leave some time for questions, so I'm just going to move on a little bit faster.
[00:16:53.320 --> 00:17:05.320]   I wanted to mention that from experience, one of the things that's a little bit tricky when using Cloud code SDK is kind of figuring out what tools you need.
[00:17:05.320 --> 00:17:18.320]   However, an option that doesn't, I think, get enough love or get mentioned, especially when you're prototyping, is you can just say dangerously skip permissions, which just kind of lets it do whatever it wants.
[00:17:18.320 --> 00:17:25.320]   And, you know, when you're prototyping and figuring out how, you know, how you're going to use your coding agent, that's often very useful.
[00:17:25.320 --> 00:17:26.320]   Very useful.
[00:17:26.320 --> 00:17:38.320]   And as I was kind of giving some initial versions of this talk to my colleagues, they said, hey, it would probably be useful to put an example prompt of what it looks like when you include a coding agent in your workflow.
[00:17:38.320 --> 00:17:41.320]   So I put an example prompt in there.
[00:17:41.320 --> 00:17:47.320]   Use your code agent tool function to raise the branch coverage level of the following test above 90%.
[00:17:47.320 --> 00:17:58.320]   After each modification run, rake, test with coverage, you know, path to the test, et cetera, you get the picture.
[00:17:58.320 --> 00:18:02.320]   So, finally, hopefully you've liked this introduction.
[00:18:02.320 --> 00:18:14.320]   I know that maybe to some of you this might seem a little bit boring, but to us kind of making that discovery that interleaving these deterministic and non-deterministic kinds of processes together
[00:18:14.320 --> 00:18:20.320]   and leveraging the power of cloud code was actually a magical combination.
[00:18:20.320 --> 00:18:23.320]   It's taking off like wildfire within Shopify.
[00:18:23.320 --> 00:18:26.320]   You know, this is something we just launched.
[00:18:26.320 --> 00:18:35.320]   We've had it internally within our development kind of environment for test grading and optimization probably for five or six weeks now.
[00:18:35.320 --> 00:18:41.320]   And we launched it as open source, I think, two or three weeks ago, and it's starting to take off like wildfire at this point.
[00:18:41.320 --> 00:18:44.320]   Now that people realize, hey, there's a standardized solution.
[00:18:44.320 --> 00:18:49.320]   Also, because of time pressure, I wasn't able to show you all the features of Roast.
[00:18:49.320 --> 00:19:00.320]   It actually has a lot of cool things like just being able to declare inline prompts within your workflows, being able to declare inline bash commands.
[00:19:00.320 --> 00:19:04.320]   And it has a lot of convention-oriented things.
[00:19:04.320 --> 00:19:07.320]   Raise your hand if you've ever used Ruby on Rails or you like Ruby on Rails.
[00:19:07.320 --> 00:19:08.320]   Yay!
[00:19:08.320 --> 00:19:09.320]   All right.
[00:19:09.320 --> 00:19:10.320]   We've got some people in the house.
[00:19:10.320 --> 00:19:12.320]   I'm a Rails guy.
[00:19:12.320 --> 00:19:15.320]   I wrote the book The Rails Way back in the day.
[00:19:15.320 --> 00:19:17.320]   And I really like Ruby on Rails.
[00:19:17.320 --> 00:19:19.320]   And it takes a convention-oriented approach.
[00:19:19.320 --> 00:19:21.320]   That's kind of what you get with Roast as well.
[00:19:21.320 --> 00:19:32.320]   So, it has things like the ability to define your prompts and then put an output template alongside it where, you know, you're able to transform the output using ERB.
[00:19:32.320 --> 00:19:33.320]   Very, very Rails-like.
[00:19:33.320 --> 00:19:36.320]   So, if you like Ruby on Rails, I think you'll like Roast.
[00:19:36.320 --> 00:19:39.320]   It looks like we have about four minutes for questions.
[00:19:39.320 --> 00:19:52.320]   So, if anyone wants to step up to the mic, give you a chance.
[00:19:52.320 --> 00:19:59.320]   Have you tried agent generating Python code to engage agent?
[00:19:59.320 --> 00:20:04.320]   Well, first of all, no, because I don't write Python in principle.
[00:20:04.320 --> 00:20:10.320]   But have I tried agent generated code to invoke an agent?
[00:20:10.320 --> 00:20:11.320]   Correct.
[00:20:11.320 --> 00:20:12.320]   Yeah.
[00:20:12.320 --> 00:20:24.320]   So, basically using Python either in your interpreter or in code execution to orchestrate sub-agents and through that do the same things as you do, like migrations and test coverage and whatnot.
[00:20:24.320 --> 00:20:25.320]   No.
[00:20:25.320 --> 00:20:35.320]   And if I understand the thrust of your question correctly, I'm not sure that we would in the context of doing Roast.
[00:20:35.320 --> 00:20:43.320]   So, the direction that we're going with Roast is the introduction of things that you would normally associate with workflows.
[00:20:43.320 --> 00:20:54.320]   So, the ability to put like control flow, conditionals, branching, looping, things like that, which are kind of quality of life if you're a workflow developer.
[00:20:54.320 --> 00:21:00.320]   What makes it unique, though, is that this is very much written for the AI age and for LLMs.
[00:21:00.320 --> 00:21:13.320]   So, for instance, your conditionals allow you to put in a prompt or a bash script or a step, you know, like a full-featured, let's call it a full-featured prompt versus an inline prompt.
[00:21:13.320 --> 00:21:20.320]   And the results of invoking that prompt can be coerced into like, for instance, a true or a false.
[00:21:20.320 --> 00:21:29.320]   Or if it's in the context of something that expects a collection to iterate over, the result of the prompt is coerced into a list and then iterates over it.
[00:21:29.320 --> 00:21:33.320]   So, I know that you asked about code generation.
[00:21:33.320 --> 00:21:34.320]   That's a cool thing.
[00:21:34.320 --> 00:21:38.320]   I might actually have to think about that and see if it fits into the picture.
[00:21:38.320 --> 00:21:39.320]   Cool. Thanks.
[00:21:39.320 --> 00:21:40.320]   All right.
[00:21:40.320 --> 00:21:41.320]   Thank you very much.
[00:21:41.320 --> 00:21:42.320]   Thank you very much.
[00:21:42.320 --> 00:21:43.320]   Thank you very much.
[00:21:43.320 --> 00:21:44.320]   Thank you very much.
[00:21:44.320 --> 00:21:44.320]   Thank you very much.
[00:21:44.320 --> 00:21:45.320]   Thank you very much.
[00:21:45.320 --> 00:21:46.320]   Thank you.
[00:21:46.320 --> 00:21:47.320]   Thank you very much.
[00:21:47.320 --> 00:21:48.320]   Thank you.
[00:21:48.320 --> 00:21:48.320]   Thank you.
[00:21:48.320 --> 00:21:49.320]   Thank you.
[00:21:49.320 --> 00:21:49.320]   Thank you.
[00:21:49.320 --> 00:21:50.320]   Thank you.
[00:21:50.320 --> 00:21:50.820]   you
[00:21:50.820 --> 00:21:51.320]   you
[00:21:51.320 --> 00:21:51.820]   you
[00:21:51.820 --> 00:21:52.320]   you
[00:21:52.320 --> 00:21:52.640]   Bye.

