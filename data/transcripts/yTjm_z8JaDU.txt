
[00:00:00.000 --> 00:00:02.080]   Go first, then.
[00:00:02.080 --> 00:00:03.860]   Nope.
[00:00:03.860 --> 00:00:09.000]   All right, so I've been thinking a lot about Q&A evals,
[00:00:09.000 --> 00:00:11.620]   questions I'm answering, especially for long context.
[00:00:11.620 --> 00:00:15.320]   So I've gone through maybe about 12, 18 papers.
[00:00:15.320 --> 00:00:19.080]   I wanted to share with you what I thought
[00:00:19.080 --> 00:00:21.240]   was really good from these papers as well as some
[00:00:21.240 --> 00:00:23.620]   of the key highlights and how I thought about it.
[00:00:23.620 --> 00:00:26.500]   I think first we'll start with narrative Q&A.
[00:00:26.500 --> 00:00:27.920]   And don't worry, I will actually try
[00:00:27.920 --> 00:00:30.920]   to extract all the links for these five papers
[00:00:30.920 --> 00:00:32.020]   and I'll share it.
[00:00:32.020 --> 00:00:34.040]   So don't try to look for it, just focus
[00:00:34.040 --> 00:00:37.460]   on what was important in here.
[00:00:37.460 --> 00:00:40.400]   And I can't monitor the chat, so yeah.
[00:00:40.400 --> 00:00:41.780]   Just stop me anytime.
[00:00:41.780 --> 00:00:43.400]   So this is the first paper.
[00:00:43.400 --> 00:00:47.720]   So you might think, Eugene, it's from 2017.
[00:00:47.720 --> 00:00:48.980]   Is it still relevant?
[00:00:48.980 --> 00:00:52.060]   I personally think this is the OG.
[00:00:52.060 --> 00:00:56.900]   This is a really, really good paper from DeepMind.
[00:00:56.900 --> 00:00:57.960]   So let's go through it.
[00:00:57.960 --> 00:01:03.020]   For each paper, we'll talk about the data set, the methodology, and then how it helps.
[00:01:03.020 --> 00:01:06.140]   So this data set consists of stories, right?
[00:01:06.140 --> 00:01:08.860]   So it's both books and movie scripts.
[00:01:08.860 --> 00:01:14.680]   And it's with human written questions based on human abstractive summaries.
[00:01:14.680 --> 00:01:16.420]   So what does this mean?
[00:01:16.420 --> 00:01:20.800]   Essentially, from the book and from the movie, we'll generate an abstract summary.
[00:01:20.800 --> 00:01:25.740]   Then, based on the summary, solely on the summary, we try to generate a question.
[00:01:25.740 --> 00:01:37.900]   What this means is that we do not deliberately generate questions that are just extractive from the text, whereby you just answer solely based on the text.
[00:01:37.900 --> 00:01:46.400]   It requires further thinking because it's based on the abstract and therefore requires evidence across the entire book.
[00:01:47.140 --> 00:01:49.100]   So, for example, here's a question, right?
[00:01:49.100 --> 00:01:51.420]   How is Oscar related to Dana?
[00:01:51.420 --> 00:01:53.260]   The answer is that it's her son.
[00:01:53.260 --> 00:01:54.480]   So here's the summary snippet.
[00:01:54.480 --> 00:01:56.380]   Peter's former girlfriend had a son, Dana.
[00:01:56.380 --> 00:02:00.200]   And then, you know, throughout the book, this is the movie.
[00:02:00.200 --> 00:02:01.520]   That's a good looking kid you got there.
[00:02:01.520 --> 00:02:04.920]   Like, based on this, you have to make the inference that this is the son.
[00:02:04.920 --> 00:02:11.640]   And, you know, they were already thinking about this in 2017, before HIVT could do even anything like this.
[00:02:11.640 --> 00:02:22.500]   So the data set 150, I mean, 1,500 stories from Project Gutenberg and movie scripts, script from the web.
[00:02:24.860 --> 00:02:35.920]   So they ask annotators to provide them with the summaries, essentially what I just mentioned, so that they don't just pick localized questions that can be identified from the local question itself.
[00:02:35.920 --> 00:02:39.660]   There are a few things here that we don't really like, but couldn't, can't be helped.
[00:02:39.660 --> 00:02:41.620]   This was probably stay out of the eye at that point in time.
[00:02:41.620 --> 00:02:43.460]   They use blue, meaty, and rouge metric.
[00:02:43.460 --> 00:02:47.300]   And they provide two golden references for each of these.
[00:02:47.300 --> 00:02:53.320]   We'll see that this actually doesn't work very well in the future papers we go through.
[00:02:53.320 --> 00:02:57.180]   Yeah, so that's the, oh, go, go for it.
[00:02:57.180 --> 00:03:00.120]   Why we don't like these metrics, blue and rouge and stuff?
[00:03:00.120 --> 00:03:01.480]   That's a good question.
[00:03:01.480 --> 00:03:10.060]   What we found is that they don't really correlate well with human judgments of whether an answer is good or not.
[00:03:10.060 --> 00:03:12.800]   Because it's purely engram based.
[00:03:14.080 --> 00:03:14.840]   I see.
[00:03:14.840 --> 00:03:18.680]   So how are you judging whether answers are good or not?
[00:03:18.680 --> 00:03:20.840]   Is it like a factual QA?
[00:03:20.840 --> 00:03:27.640]   Or is it like, you know, this is something that is like the right tone of what I would want an answer to be?
[00:03:27.640 --> 00:03:33.420]   How I think about it is mostly factual, summarization, inferential.
[00:03:33.420 --> 00:03:38.340]   We don't really go into the, I don't really think about the tone or the style.
[00:03:38.680 --> 00:03:45.160]   I think right now, what I think is probably going to be good, there's probably going to be two sets of metrics.
[00:03:45.160 --> 00:03:48.460]   There's going to be reference-free metrics and reference-based.
[00:03:48.460 --> 00:03:49.140]   What does this mean?
[00:03:49.140 --> 00:03:52.960]   Reference-based means that you have a right answer, right?
[00:03:52.960 --> 00:03:56.560]   You have the right answer, and you're just checking to see if it matches the right answer a lot.
[00:03:56.560 --> 00:03:57.820]   I think that's very straightforward.
[00:03:57.820 --> 00:04:03.580]   Reference-free metric is that there may be no right answer, but you just want to check whether it's good enough a lot.
[00:04:03.580 --> 00:04:08.560]   So an example of a reference-based metric is this, right?
[00:04:08.560 --> 00:04:10.440]   How are they related?
[00:04:10.440 --> 00:04:11.040]   It's her son.
[00:04:11.040 --> 00:04:20.300]   Maybe if the answer is it's her child or saying something like, oh, she is his mom.
[00:04:22.580 --> 00:04:31.440]   If the answer is not, even if the answer is not in the right way, if you use an LLM evaluator, it's able to say that, hey, no, this is a hit.
[00:04:31.440 --> 00:04:40.460]   An example of a reference-free metric could be a summarization whereby we already know LLMs already surpass human performance in terms of summarization.
[00:04:41.140 --> 00:04:44.720]   So it could be that here's a summary, and then here's the text.
[00:04:44.720 --> 00:04:49.440]   Is this summary a faithful representation of the text?
[00:04:49.440 --> 00:05:00.460]   So for those, there's an example in that, one of the future papers, one of the papers I'll be covering, that actually talks about this reference-free metric for evaluating faithfulness.
[00:05:00.460 --> 00:05:05.020]   Did I answer the question?
[00:05:05.020 --> 00:05:12.520]   So this paper is in the realm of fiction.
[00:05:12.520 --> 00:05:14.160]   Now let's go into non-fiction.
[00:05:14.160 --> 00:05:17.140]   Here's another paper that I quite like.
[00:05:17.140 --> 00:05:25.500]   Data set of information-seeking papers, anchored in research papers, by Allen Institute for AI.
[00:05:25.500 --> 00:05:28.820]   Their approach is also very interesting.
[00:05:30.880 --> 00:05:38.580]   They have academics, read, title, and abstract, only title and abstract, and then ask questions off the paper.
[00:05:38.580 --> 00:05:39.620]   That's it.
[00:05:39.620 --> 00:05:40.800]   Right?
[00:05:40.800 --> 00:05:53.080]   So it's a very similar approach whereby they force annotators to only look at limited data and then try to see if they can ask the question or not.
[00:05:53.080 --> 00:06:01.820]   And of course, the reason is because when you give annotators the full text and you ask them to generate questions, they often will generate questions that can be answered just within one or two words.
[00:06:01.820 --> 00:06:09.240]   But by forcing annotators to only look at the summary data, you actually force them to generate questions that are more open-ended.
[00:06:09.680 --> 00:06:14.320]   And in this case, this specific data set actually includes the evidence to arrive at that.
[00:06:14.320 --> 00:06:25.260]   And if you think about it, including the evidence, this evidence can be used in a retrieval evaluation pipeline, which is, did our retrieval find the right evidence for this question?
[00:06:25.260 --> 00:06:27.620]   So this is quite useful.
[00:06:27.620 --> 00:06:29.720]   5,000 papers.
[00:06:30.720 --> 00:06:35.780]   No, 5,000 questions on 1,500 papers on NLP, on NLP papers.
[00:06:35.780 --> 00:06:40.120]   And I think they actually collected these questions themselves, the authors.
[00:06:40.120 --> 00:06:44.420]   So 55% of the questions require evidence for multiple paragraphs.
[00:06:44.420 --> 00:06:55.520]   And this is the only, this is why when you ask a question from the abstract, the abstract, because it condenses data from multiple paragraphs, you actually have to answer questions from those.
[00:06:55.700 --> 00:07:00.660]   And 13 of them are actually super challenging, requiring answers from tables and figures.
[00:07:00.660 --> 00:07:06.660]   So I think that's probably the main thing I want to answer.
[00:07:06.660 --> 00:07:12.400]   So again, annotators, they don't just generate questions that cannot be answered, right?
[00:07:12.400 --> 00:07:15.860]   First, they generate questions, then they try to answer this.
[00:07:15.860 --> 00:07:21.480]   So if the question is answerable, they select the minimal set of evidence snippets to try to answer it.
[00:07:21.480 --> 00:07:24.400]   And of course, if the question is not answerable, they just throw it out.
[00:07:24.780 --> 00:07:33.120]   So in a sense, I think this data set is fairly carefully curated to ensure that all the answers actually can be answered, even though they took their approach whereby they focus on the summary first.
[00:07:33.120 --> 00:07:39.200]   And then there's a couple of questions that you can see here.
[00:07:39.200 --> 00:07:48.980]   You can see that even when you do this, a lot of the questions are going to be extractive, which is you just extract from the text.
[00:07:49.920 --> 00:07:56.700]   What we really want to aim on is for the abstractive answers, which requires some form of reasoning.
[00:07:56.700 --> 00:08:00.320]   And I think that's what this methodology is.
[00:08:00.320 --> 00:08:05.080]   And of course, there's a yes or no and unanswerable questions.
[00:08:05.080 --> 00:08:05.900]   They just skip it.
[00:08:05.900 --> 00:08:11.240]   Yeah, that's all I want to share about this.
[00:08:11.980 --> 00:08:15.720]   Next, I want to talk about L-eval, which is long e-val.
[00:08:15.720 --> 00:08:20.220]   This is slightly more recent, 2023.
[00:08:20.220 --> 00:08:26.260]   Discarding unanswerable questions seems like part of the reason LLM's answers.
[00:08:26.260 --> 00:08:26.900]   Yeah.
[00:08:28.100 --> 00:08:35.140]   I think it's important in the sense that we just need to make sure that those questions we don't mark it against the LLM or that we don't force the LLM to make up bullshit.
[00:08:35.140 --> 00:08:38.260]   So it's 20 sub-pass.
[00:08:38.260 --> 00:08:40.120]   They have 500 long documents.
[00:08:40.120 --> 00:08:42.960]   And these documents range from 3K to 200K.
[00:08:42.960 --> 00:08:45.940]   What we're really more interested in is in the 20K.
[00:08:46.900 --> 00:08:52.000]   But beyond the data set that they have here, here's the data set.
[00:08:52.000 --> 00:08:53.080]   The data set is really interesting.
[00:08:53.080 --> 00:08:57.560]   They almost created a lot of new data sets themselves where they script Coursera.
[00:08:57.560 --> 00:09:03.260]   This is, I think, a sci-fi citation, science fiction.
[00:09:03.260 --> 00:09:05.160]   Science fiction data set, right?
[00:09:05.160 --> 00:09:08.920]   It's a science fiction data set of true-false questions.
[00:09:08.920 --> 00:09:11.120]   And then they have a code data set.
[00:09:11.120 --> 00:09:15.760]   And then there's a long context question answering data set based on investor relations.
[00:09:15.760 --> 00:09:16.700]   So it's finance.
[00:09:16.700 --> 00:09:24.140]   So it's a really mixed bag from educational fiction and long context.
[00:09:24.140 --> 00:09:32.600]   So then, of course, they also combine several publicly available data sets.
[00:09:32.600 --> 00:09:35.400]   Now, what's really interesting here is this finding.
[00:09:35.400 --> 00:09:39.560]   Of course, they use an LLM as a judge.
[00:09:39.560 --> 00:09:40.580]   I mean, who doesn't nowadays?
[00:09:40.580 --> 00:09:45.460]   But what they found was this.
[00:09:45.680 --> 00:09:48.740]   Oh, no, where is it?
[00:09:48.740 --> 00:09:53.120]   Sorry, it's a little bit messy.
[00:09:53.120 --> 00:10:02.560]   So what they had to do was this, which is length instruction enhanced evaluation.
[00:10:02.560 --> 00:10:09.780]   So the problem with a lot of the N-gram-based benchmarks is that it's very much reliant on length.
[00:10:09.780 --> 00:10:17.340]   All the N-gram-based benchmarks are based on some recall and some precision approach, which you need some kind of denominator.
[00:10:17.560 --> 00:10:21.000]   And usually the denominator is the number of tokens in the answer, right?
[00:10:21.000 --> 00:10:25.000]   And therefore, longer answers will therefore be penalized.
[00:10:25.000 --> 00:10:33.700]   So what they found is that they try to constrain the LLMs to the number of words in the answer.
[00:10:34.440 --> 00:10:44.780]   And they found that when they did this, firstly, all the automated metrics, this is a key point, failed to correlate with human judgment.
[00:10:45.880 --> 00:10:49.840]   And compared, and of course, LLM judges are more accurate and robust to length.
[00:10:49.840 --> 00:11:00.480]   They also showed that with this length instruction enhanced evaluation, they found that they were able to improve.
[00:11:02.040 --> 00:11:09.000]   With the length instructions, they were able to improve the rouge by 0.5 to 0.8.
[00:11:09.000 --> 00:11:12.360]   And, you know, the data of the GPT-4 evaluator.
[00:11:12.360 --> 00:11:18.420]   Essentially, what it means is that when you try different pipelines or different models to try to get your answers,
[00:11:18.420 --> 00:11:27.020]   you want to try to make sure that the answers, it's not unfairly biasing a certain LLM that has longer answers.
[00:11:27.900 --> 00:11:32.400]   So I think this is also a pretty standard now, but it's a good reminder and they show data on that.
[00:11:32.400 --> 00:11:39.380]   The next one, I mean, since Swix likes fiction so much, there's another fiction paper.
[00:11:39.380 --> 00:11:47.120]   So this is novel QA, question answering documents, exceeding 200K documents.
[00:11:47.120 --> 00:11:49.600]   So this is based on English documents, right?
[00:11:49.600 --> 00:11:54.920]   And they have a mix of various complexity, et cetera.
[00:11:57.600 --> 00:12:07.880]   So what is really interesting here is they use, based on English, but they also try to, and they also, they have golden answers, which is great.
[00:12:07.880 --> 00:12:10.680]   Having these reference answers is really important.
[00:12:10.680 --> 00:12:18.120]   But what is really interesting is the, how they try to create the data set, which is multi-hop, single-hop, and detailed answers.
[00:12:18.120 --> 00:12:25.620]   So single-hop means you need to find, you locate some evidence somewhere and you need to connect it with another evidence somewhere.
[00:12:26.380 --> 00:12:28.440]   Multi-hop means you need to jump all over the place.
[00:12:28.440 --> 00:12:31.580]   So this is actually pretty challenging, I think.
[00:12:31.580 --> 00:12:36.880]   And I think a lot of regular Q&A, if you're asking questions of your documents or of your book, et cetera,
[00:12:36.880 --> 00:12:39.960]   these are the kind of very difficult questions you're asking.
[00:12:39.960 --> 00:12:49.540]   You're probably not asking for extractive questions, like what did Tom do or where did Dumbledore destroy the first Horcrux?
[00:12:49.720 --> 00:12:57.380]   Like even where did he destroy the first Horcrux, you actually need to do a lot of abstractive and reasoning thinking behind that.
[00:12:57.380 --> 00:13:06.000]   So what is really interesting is that they tried to show what happens with the loss-in-the-middle phenomena, and that's the data set.
[00:13:06.000 --> 00:13:07.880]   That's the graph I want to focus on here.
[00:13:07.880 --> 00:13:11.180]   Also in normal Q&A, they actually have two kinds of answers.
[00:13:11.180 --> 00:13:14.280]   The first answer is multiple choice.
[00:13:14.280 --> 00:13:19.000]   And you can see over here, the answer is multiple choice.
[00:13:19.000 --> 00:13:20.660]   And then the second answer is generative.
[00:13:20.660 --> 00:13:26.280]   For the answer, the model actually has to choose some kind of answer.
[00:13:26.280 --> 00:13:33.220]   And you can see, this is probably not the best graph, but essentially both of these are multiple choice.
[00:13:33.860 --> 00:13:35.420]   Do you try and match it with the answer?
[00:13:35.420 --> 00:13:39.760]   They reference L-Eval, they reference Bamboo and Long Bench.
[00:13:39.760 --> 00:13:43.800]   We won't have time to go through a lot of these, but L-Eval, which is the paper that we just mentioned,
[00:13:43.800 --> 00:13:50.240]   they actually reuse the same length instruction enhanced evaluation based on that.
[00:13:50.240 --> 00:13:55.700]   So token size, 200k tokens, this exceeds what Claude is able to do.
[00:13:55.700 --> 00:13:57.860]   But we don't know what Claude's tokenizer is.
[00:13:58.160 --> 00:14:03.980]   Anyway, so this data set, now over here, they are very explicit on how they constructed a data set,
[00:14:03.980 --> 00:14:07.140]   which is very helpful if you want to construct a data set yourself.
[00:14:07.140 --> 00:14:09.360]   Essentially, you need a few columns.
[00:14:09.360 --> 00:14:11.240]   You need the question, obviously, and the answer.
[00:14:11.240 --> 00:14:15.600]   You also need the golden reference answer, right?
[00:14:15.600 --> 00:14:18.000]   The gold answer and the evidence.
[00:14:18.340 --> 00:14:22.800]   So now evidence, you can probably just say the evidence is probably the entire document up to the point that I read.
[00:14:22.800 --> 00:14:27.520]   Or you can actually go the extra mile by saying that these are the paragraphs where the evidence is or the spans.
[00:14:27.520 --> 00:14:32.100]   And you can also try to label the questions to try to help you understand,
[00:14:32.100 --> 00:14:36.640]   hey, is my pipeline performing better on the more complex questions, multi-hop questions,
[00:14:36.640 --> 00:14:38.880]   abstractive summarization questions, et cetera.
[00:14:39.400 --> 00:14:48.820]   I kind of ignore the multiple choice answers because that's not very representative if you're trying to build a chatbot on top of long context.
[00:14:48.820 --> 00:14:54.820]   So very interestingly, they use public domain novels from Project Gutenberg.
[00:14:54.820 --> 00:14:56.720]   They also purchase e-books.
[00:14:56.720 --> 00:15:02.420]   I'm not sure what it means to purchase the e-book and then release it as part of a golden data set.
[00:15:02.480 --> 00:15:07.360]   I don't know if you purchase the e-book, you actually have the copyright and the license to do that, to share it out.
[00:15:07.360 --> 00:15:09.000]   But I know that's what they did.
[00:15:09.000 --> 00:15:10.740]   I don't want to question that.
[00:15:10.740 --> 00:15:16.240]   So here's how the distribution of the questions look like.
[00:15:16.240 --> 00:15:18.220]   Multi-hop, which is the most challenging one.
[00:15:18.220 --> 00:15:20.800]   Single-hop and then followed by detail, which is just really extractive.
[00:15:20.800 --> 00:15:26.600]   Now, there's three really interesting.
[00:15:26.960 --> 00:15:32.860]   I'm not sure if I would agree with their interpretation of it.
[00:15:32.860 --> 00:15:35.780]   So what they found over here, oh, sorry.
[00:15:35.780 --> 00:15:44.720]   Figure three is that accuracy drops beyond 100k tokens.
[00:15:44.720 --> 00:15:50.540]   So once your data is in, beyond 100k, accuracy drops.
[00:15:50.540 --> 00:15:52.720]   So that's what the graph on the left shows.
[00:15:52.720 --> 00:15:54.700]   I think that's somewhat clear.
[00:15:55.020 --> 00:16:00.780]   It feels like, I think they're right to say that, okay, if you average all the three numbers, you do see a stepwise drop.
[00:16:00.780 --> 00:16:07.820]   Now, figure 3b, this is the one that's actually really interesting.
[00:16:07.820 --> 00:16:16.300]   In a sense, what they say is that if I give it some text and the answer is in some percentile of the text,
[00:16:16.360 --> 00:16:21.400]   the answer is in the first 10% or the answer is the last 90% or the last answer is right in the middle.
[00:16:21.400 --> 00:16:26.400]   What this graph says is that there is no loss in the middle effect.
[00:16:26.400 --> 00:16:32.340]   Regardless of where the actual answer, the actual evidence is, there's actually no loss in the middle effect.
[00:16:32.840 --> 00:16:35.280]   And this is actually, this actually suggests a hint.
[00:16:35.280 --> 00:16:50.680]   If you are trying to build such a benchmark yourself, you want your benchmark to be positionally robust in the sense that you want to ask questions that can be answered by the first quarter of the book, the half of the book, the third of the book, and at the end of the book.
[00:16:51.640 --> 00:16:57.020]   You don't want to just formulate questions that are either just all at the start or all in the middle.
[00:16:57.020 --> 00:17:03.020]   You want to have this concept of positional robustness to understand, hey, where does my pipeline start to fail?
[00:17:03.020 --> 00:17:07.180]   According to this graph, they say that it does not fail.
[00:17:07.180 --> 00:17:17.560]   But now let's look at figure 7, which is in the appendix, where they split this up into two stages.
[00:17:18.040 --> 00:17:24.980]   The first one on top is when the, and maybe let's just focus on the GPT-4 and Claude 2.1 numbers.
[00:17:24.980 --> 00:17:30.340]   The first one on top is when the context length is below 100k.
[00:17:30.340 --> 00:17:36.100]   So you can see when the context length is below 100k, there may be some kind of loss in the middle effect.
[00:17:36.100 --> 00:17:42.420]   If you look at this GPT, if you really squint at this GPT-4 graph, and maybe this intern LLM graph.
[00:17:43.380 --> 00:17:49.120]   But when the context length exceeds 100k, you start to see it's really just dropping throughout all the way.
[00:17:49.120 --> 00:17:52.160]   So I think maybe there's two stories here.
[00:17:52.160 --> 00:17:56.800]   When the context length is medium, look at us, 100k context is already considered medium now.
[00:17:56.800 --> 00:18:00.660]   When the context length is medium, maybe the loss in the middle effect is present.
[00:18:01.100 --> 00:18:07.800]   When the context length is long, I guess the longest one they have here, which is more than 100k,
[00:18:07.800 --> 00:18:12.600]   you start to see that long context start to drop off.
[00:18:12.600 --> 00:18:15.920]   So that's a nuanced finding that they found here.
[00:18:15.920 --> 00:18:19.760]   Now the last one, I know I'm going super fast.
[00:18:20.360 --> 00:18:23.660]   I will just want to finish this and maybe in just three minutes, and then we can go into questions.
[00:18:23.660 --> 00:18:31.120]   The last one is especially interesting because it goes into multi-document Q&A.
[00:18:31.120 --> 00:18:39.000]   Up to so far, we've always only been focusing on a single document, a single movie script, a single book, a single paper.
[00:18:39.440 --> 00:18:43.500]   But what if the answer requires multiple documents?
[00:18:43.500 --> 00:18:44.820]   So here's the answer.
[00:18:44.820 --> 00:18:47.700]   List the current assets of each of the above companies in order.
[00:18:47.700 --> 00:18:51.560]   So you do need to go through multiple documents to try to answer this.
[00:18:51.560 --> 00:18:52.860]   And it depends.
[00:18:52.860 --> 00:18:56.500]   Different documents could have different contexts, could have different styles of writing.
[00:18:56.500 --> 00:18:59.320]   How is the LLM able to deal with this?
[00:18:59.320 --> 00:19:04.240]   So I won't go through this very much.
[00:19:04.240 --> 00:19:07.160]   This is the long benchmark, L-O-O-N-G.
[00:19:07.800 --> 00:19:10.860]   Pretty interesting because it also means dragon in Chinese.
[00:19:10.860 --> 00:19:14.260]   Maybe that's what they intend to do.
[00:19:14.260 --> 00:19:21.140]   And you can see these are the different tasks that you try to look at, which is given multiple docs, can you pick the right one?
[00:19:21.140 --> 00:19:23.920]   Given multiple docs, can you do some kind of comparison?
[00:19:23.920 --> 00:19:26.560]   Hey, is Ali Baba better than Pai Tu or Tencent?
[00:19:26.560 --> 00:19:27.180]   Comparison.
[00:19:27.180 --> 00:19:31.960]   Given multiple docs, can you do clustering and do some kind of summarization on top of that?
[00:19:31.960 --> 00:19:35.720]   And then given multiple docs, can you just do some kind of chain of reasoning across the docs?
[00:19:36.160 --> 00:19:45.600]   But one thing that's really interesting in this is not just how the benchmark was built, but this result that they have in this paper, in this graph over here.
[00:19:46.600 --> 00:19:50.820]   So this paper, I don't know, again, this is a question that I often debate.
[00:19:50.820 --> 00:19:53.980]   I don't know what the right answer is and I'm curious to hear what people think.
[00:19:53.980 --> 00:20:00.480]   The blue line, the blue round line with the blue dots, this is the baseline accuracy.
[00:20:00.480 --> 00:20:03.200]   And you can see baseline accuracy just keeps dropping.
[00:20:03.200 --> 00:20:03.760]   It's fine.
[00:20:04.080 --> 00:20:06.740]   So this is the top five, GPT-40 and QAN 272B.
[00:20:06.740 --> 00:20:14.640]   Now, the other lines, the other colors, these are when you use OpenAI embeddings and get the top 10 documents.
[00:20:14.640 --> 00:20:21.240]   And when you use, I can't remember what BGE stands for, but it's another embedding model and use the top five.
[00:20:21.240 --> 00:20:24.880]   Top five and of course, OpenAI top five and OpenAI top 10.
[00:20:26.000 --> 00:20:26.940]   What do you see here?
[00:20:26.940 --> 00:20:28.820]   Can anyone just shout out?
[00:20:28.820 --> 00:20:29.820]   What's the big trend here?
[00:20:29.820 --> 00:20:34.700]   Longer context, lower?
[00:20:34.700 --> 00:20:35.760]   Yes.
[00:20:35.760 --> 00:20:37.260]   Yes.
[00:20:37.260 --> 00:20:39.140]   What is the other big trend?
[00:20:39.140 --> 00:20:43.540]   The other big trend is maybe we don't need RAG.
[00:20:45.280 --> 00:20:54.900]   I know maybe that is controversial, but you can see that using RAG, you always get lower accuracy.
[00:20:54.900 --> 00:21:04.620]   Now, this, I don't know if it's controversial or not, but if you think about it, if you think about it two years into the future,
[00:21:04.620 --> 00:21:08.080]   will models have standard half a million or one million contacts?
[00:21:08.080 --> 00:21:09.680]   I think that's very likely, yes.
[00:21:09.680 --> 00:21:13.600]   Will pre-cash cost drop further?
[00:21:13.600 --> 00:21:14.980]   I think the answer is yes.
[00:21:14.980 --> 00:21:18.180]   Will long contacts capability increase?
[00:21:18.180 --> 00:21:19.600]   I think the answer is probably yes.
[00:21:19.600 --> 00:21:21.800]   So it doesn't mean that we don't need RAG.
[00:21:21.800 --> 00:21:27.400]   It means that if your single document, if you have a single document or single book,
[00:21:27.400 --> 00:21:30.140]   or even maybe a Game of Thrones style, that length of book,
[00:21:30.140 --> 00:21:33.480]   maybe you just need the whole thing in the context and you maybe don't need RAG.
[00:21:33.480 --> 00:21:36.540]   Now, you still need RAG if you're trying to query on the Library of Congress,
[00:21:36.540 --> 00:21:39.440]   which is all the financial reports.
[00:21:39.800 --> 00:21:44.600]   But from this example here, you can see that at 50K or 100K or even 200K,
[00:21:44.600 --> 00:21:50.420]   RAG actually didn't help, but it actually hurt.
[00:21:52.340 --> 00:21:53.780]   So that's all I had to share.
[00:21:53.780 --> 00:21:54.380]   Any questions?
[00:21:54.380 --> 00:21:56.840]   Quick question on this last one, actually.
[00:21:56.840 --> 00:22:01.700]   So is this a single document or is this multiple documents?
[00:22:01.700 --> 00:22:05.460]   I suspect this is multiple documents because their data sets are all multiple documents.
[00:22:08.120 --> 00:22:12.500]   So in the long context, they're just throwing in multiple documents?
[00:22:12.500 --> 00:22:13.400]   Yeah.
[00:22:13.400 --> 00:22:14.860]   All the documents.
[00:22:14.860 --> 00:22:24.020]   I suspect it's multiple documents.
[00:22:24.020 --> 00:22:25.340]   Yeah.
[00:22:25.400 --> 00:22:42.320]   So one thing that I ran into in the past with long context evals was so I was working on like a legal long context QA task and they had overfit on trying to fine tune a menstrual model.
[00:22:42.980 --> 00:22:55.120]   And it was really good at documents at the start, the middle and the end, but not at different quartiles because they tried to fix this long context QA by training on facts that were injected in the middle.
[00:22:55.300 --> 00:22:58.480]   And then we had overfit to that.
[00:22:58.480 --> 00:23:12.960]   But then what happened was when we did chain of thought questions with multiple documents, we noticed that it would just chain of thought through the whole context and be like, okay, I need this source and then I will do that.
[00:23:12.960 --> 00:23:17.160]   So giving in multiple kind of had an internal chain of thought even when not prompted.
[00:23:17.160 --> 00:23:22.480]   But then when we did it on one large document, it still wouldn't work well.
[00:23:22.480 --> 00:23:29.320]   So interesting little like note that we had on this specific thing because we tried, let's just throw in the whole couple documents.
[00:23:29.320 --> 00:23:40.360]   And it was, you know, I think it was 32K context, but that could still fit multiple, multiple documents and it could reason through, okay, I need to look at this subsection because now it has internal breaks, right?
[00:23:40.360 --> 00:23:45.320]   So it could easily find, okay, I need like, you know, 17th document is here and then it would look into that.
[00:23:45.320 --> 00:23:49.340]   But if we gave one document that was 32K, it wouldn't do any well.
[00:23:49.340 --> 00:23:51.740]   So interesting little note on this even.
[00:23:52.240 --> 00:23:53.980]   Yeah, I think maybe that's how the fine tuning was done.
[00:23:53.980 --> 00:23:56.160]   Yeah.
[00:23:56.160 --> 00:24:06.200]   So the question I always ask myself and I mean, not to be spicy here, but the question I always ask myself is a reg or not.
[00:24:06.200 --> 00:24:09.760]   So now here's the practical considerations, right?
[00:24:09.760 --> 00:24:11.740]   If you want to build a reg, you need to eval the reg.
[00:24:11.740 --> 00:24:15.540]   And building the reg, evaluating the reg, maybe that's two headcount.
[00:24:16.260 --> 00:24:18.140]   And we know evaluation is really hard, right?
[00:24:18.140 --> 00:24:22.460]   Evaluation and retrieval is especially hard because it's always the cold start problem.
[00:24:22.460 --> 00:24:28.960]   If you're asking a question of a document base, everyone has their own document base and there's only one person who's answering document base.
[00:24:28.960 --> 00:24:29.500]   It's really hard.
[00:24:29.920 --> 00:24:38.960]   Unlike if you're doing recommendation systems or search, you have free data coming from everywhere where customers are just saying yes or no, whether I like this product that you've written or not.
[00:24:39.520 --> 00:24:43.820]   But for evaluation or retrieval, I think it's really, really, really hard and really expensive.
[00:24:44.240 --> 00:24:53.220]   So as far as I can, as much as I would like to not build a reg and evaluate the retrieval component of the reg, I try to do that.
[00:24:53.220 --> 00:24:58.020]   Now, if anyone here wants to tell me, Eugene, you're wrong, I would love to hear it.
[00:24:58.020 --> 00:25:02.100]   And feel free to ping me on Discord or Twitter anywhere.
[00:25:02.100 --> 00:25:06.440]   But in my mind, I think evaluation retrieval is actually extremely hard, especially in reg, right?
[00:25:06.440 --> 00:25:09.560]   Because you're retrieving the documents and then you're summarizing into an answer.
[00:25:09.560 --> 00:25:14.680]   The user will never give you feedback on whether the documents you have retrieved are actually useful or not.
[00:25:14.680 --> 00:25:17.660]   There's no built-in data flyer will feedback you.
[00:25:17.660 --> 00:25:20.180]   The user will only say the answer is good or not.
[00:25:20.180 --> 00:25:25.800]   But you actually don't, unless you actually have a dedicated team that actually says, this document is good, this document is not good.
[00:25:25.800 --> 00:25:26.800]   It's really hard.
[00:25:26.800 --> 00:25:29.420]   And how would they actually know whether a document is good or not?
[00:25:29.420 --> 00:25:33.560]   Unless they have absolute, firstly, they will never build track.
[00:25:33.560 --> 00:25:35.220]   You'll never build measure recall.
[00:25:35.220 --> 00:25:38.940]   The best that you can do is measure precision, but precision is also pretty, it's not bad.
[00:25:39.360 --> 00:25:41.100]   It's actually, it goes a long way.
[00:25:41.100 --> 00:25:47.740]   So that's how this last graph here is really making me think a lot about this.
[00:25:47.740 --> 00:25:50.360]   And yeah, so I'll stop here.
[00:25:50.360 --> 00:25:53.320]   I have two quick comments on that.
[00:25:53.320 --> 00:25:57.140]   One is, I wonder how other models will shape up.
[00:25:57.140 --> 00:26:02.360]   Like we have LamaGuard as a hallucination detection model, which you can implement live.
[00:26:02.540 --> 00:26:03.540]   And then it's great now.
[00:26:03.540 --> 00:26:04.240]   Yeah.
[00:26:04.240 --> 00:26:09.800]   So will there be a sort of, you know, rag checker type model that we can implement in systems?
[00:26:09.800 --> 00:26:12.460]   And how much will systems have an effect to this, right?
[00:26:12.460 --> 00:26:16.960]   Models that are specialized at this sort of QA task of, is this the correct document?
[00:26:17.200 --> 00:26:21.600]   And it's past just embedding and similarity search.
[00:26:21.600 --> 00:26:26.960]   But, you know, can we have a quick, small model that just references documents and sees if we can optimize them?
[00:26:26.960 --> 00:26:31.840]   Similar to how we currently have like, you know, rag with re-rank or hide embedding, stuff like that.
[00:26:31.840 --> 00:26:34.180]   Will we just have models that abstract this away?
[00:26:34.940 --> 00:26:48.180]   And then the other point is, in two pretty large use cases that I built in medical and legal, we actually had it pretty easy to have a human in the loop for feedback for if documents are suggested.
[00:26:48.180 --> 00:26:53.040]   So, for example, for lawyers, we had a quick QA sort of chatbot.
[00:26:53.660 --> 00:27:03.240]   And what happened was, if we, you know, automatically just had an output, basically everyone would just take the LLM's word, even if it was incorrect.
[00:27:03.240 --> 00:27:10.180]   So we had to scale back and be like, okay, what we ended up on was a sort of fill-in-the-blank multiple-choice style output.
[00:27:10.180 --> 00:27:16.000]   So you would have a reference document, you would have a subset, and then you would have to fill in sort of what would happen.
[00:27:16.000 --> 00:27:19.680]   This was kind of our middle ground to make sure that there was a human in the loop.
[00:27:19.800 --> 00:27:24.960]   Because if you just have, you know, is this correct? Check or X is what we did.
[00:27:24.960 --> 00:27:32.160]   Everyone would just press the check, and we had like 90-something percent success rate on just, yep, this is right, and people wouldn't really check the document.
[00:27:32.160 --> 00:27:40.100]   But if we gave them a snippet, and then they had to kind of find the result, they could either, you know, leave a comment that this is not, like the result isn't here,
[00:27:40.100 --> 00:27:47.400]   which we had like a significant greater than 10% of the time, or they could get the reference there, and it was still like highly impactful.
[00:27:47.900 --> 00:27:52.280]   I know we kind of used that data to build our own guardrail for the system, but I don't know.
[00:27:52.280 --> 00:27:56.920]   I found that there were pretty clever ways to get these human in the loop of, do we have the right document?
[00:27:56.920 --> 00:28:03.680]   And we actually did it from a guardrail of just, we can't have people just accept every AI response, because models were pretty shit.
[00:28:03.680 --> 00:28:08.900]   We didn't have great LM as a judge, but that was just one use case we came around for that.
[00:28:09.520 --> 00:28:18.680]   That's pretty cool, Vibu. I hope you have nothing on plan next Saturday and Sunday, because that's the only thing that we'll be talking about when I'm in SF next week.
[00:28:18.680 --> 00:28:25.000]   Yeah, I don't know if I can actually get regular non-paying users to do this.
[00:28:25.000 --> 00:28:29.980]   You can imagine, you know, I'm just reading my book. Do I actually want to provide the right data?
[00:28:30.620 --> 00:28:33.420]   I don't know. But okay, over to whoever's next.
[00:28:33.420 --> 00:28:36.240]   Okay. Six, you want to go next? I got next.
[00:28:36.240 --> 00:28:38.460]   Ted, question. Open.
[00:28:38.460 --> 00:28:40.620]   Yeah, I think Vibu's next, but yeah, go ahead, Ted.
[00:28:41.440 --> 00:28:55.000]   Yeah, just a quick question, Eugene. I'm curious if you've looked at, like, there was the writing in the margins papers, one that I know about, and, you know, sort of like trying to improve rag instead of just doing vanilla rag.
[00:28:55.000 --> 00:29:04.040]   I think Sam actually got his folks to present the writing in the margins paper. So yeah, I'm familiar with that. I'm familiar with that.
[00:29:04.700 --> 00:29:11.300]   I have not invested too much time experimenting and implementing that. But yes, I'm aware of that. Thank you.
[00:29:11.300 --> 00:29:18.040]   Also, it's another note when you bring up, do we need rag or all the context? So once again, shout out, Sam.
[00:29:18.040 --> 00:29:25.900]   Ryder team shipped their new model this week. One thing I gave feedback was, if I like to just share my screen right now.
[00:29:25.900 --> 00:29:37.300]   Sorry, Sam, I'm calling you out live. But, so, where is this? Is this the right tab? This is the right tab.
[00:29:37.300 --> 00:29:45.380]   Basically, they mentioned that, you know, it takes 22 seconds to process a million tokens.
[00:29:45.860 --> 00:29:51.620]   And my question is basically, like, how many people know how long any other model takes to process a million tokens, right?
[00:29:51.620 --> 00:29:59.120]   Like, as you go to, let's say I want 10 million tokens in context, you know, does this scale to now 10x longer?
[00:29:59.120 --> 00:30:06.440]   Is it, like, over two to three minutes per query? And, yeah, do people really, like, people are used to pretty quick answers, right?
[00:30:06.460 --> 00:30:15.900]   But when I'm building a rag system, like, sure, we have agentic stuff, but, like, are we okay with 22 million seconds for a million tokens?
[00:30:15.900 --> 00:30:22.020]   And if you're saying this, is this, like, a good thing? Like, is 22 seconds quick? How long are other models?
[00:30:22.020 --> 00:30:28.900]   I don't know this, and I thought I would go through it. But, yeah, I feel like it's also just another consideration, right?
[00:30:28.900 --> 00:30:39.440]   But, like, as we throw more tokens, yeah, these things take a while. Like, we're used to that instant response. And, yeah, I don't know, just something to know if we just do long context.
[00:30:39.440 --> 00:30:42.360]   I'm assuming you guys do it.
[00:30:42.360 --> 00:30:57.860]   This was surprisingly difficult to find comparisons on. I was trying to build, like, a little, like, homegrown benchmarking thing to test other models, but I couldn't, I didn't have, like, the API levels or the, like, credits to be able to actually make it work.
[00:30:57.920 --> 00:31:03.720]   I could test it on, like, some of the smaller models, because I could get my context window limitations up higher.
[00:31:03.720 --> 00:31:13.780]   But it was, yeah, it's actually not a solved problem yet of, like, testing models on million token requests right now.
[00:31:13.780 --> 00:31:24.900]   Yeah, a lot of it also just meant, like, matters on, you know, are you doing your own inference? What hardware? Is the API provider optimizing for throughput? Time the first token?
[00:31:25.940 --> 00:31:33.880]   So, I guess there's, like, yeah, it's just another parameter to think about. If you're doing long context versus RAG, we don't think much about what goes into RAG, right?
[00:31:33.880 --> 00:31:42.160]   They're just short responses. But, yeah, now if you're doing something like this, you know, you got to think about, oh, shit, I have millions of tokens per call.
[00:31:42.160 --> 00:31:43.940]   How do I optimize on this?
[00:31:45.240 --> 00:31:50.780]   But, yeah, that's enough of my writer thing. But check out the model. It seems cool. I haven't tried it.
[00:31:52.880 --> 00:31:54.540]   Thanks, FeeBoo. Your check is in the mail.
[00:31:54.540 --> 00:31:59.840]   Definitely not sponsored. But they have sick merch.
[00:31:59.840 --> 00:32:03.160]   Swix, you want to go next? Should I go next?
[00:32:03.160 --> 00:32:07.960]   I thought we said it was you, but I'm easygoing.
[00:32:07.960 --> 00:32:12.040]   Okay, I'm struggling on my screen share. There we go. We're good.
[00:32:12.660 --> 00:32:12.880]   Okay.
[00:32:12.880 --> 00:32:14.940]   No, no, I got it. It works now.
[00:32:14.940 --> 00:32:22.900]   Okay, so I think I shared the paper at the beginning of the call. I'll share it again real quick.
[00:32:25.460 --> 00:32:45.820]   So basically, this is a little survey paper. Something that I was kind of annoyed by is how before, here we go, we used to kind of have the default be that, you know, big companies make big model.
[00:32:45.820 --> 00:32:51.820]   Big model is fast and smart. And also, is my screen share working? It wasn't working on this before.
[00:32:51.820 --> 00:32:52.080]   Yes.
[00:32:52.260 --> 00:33:04.680]   Okay, sick. So before, you know, models would get smarter, faster, cheaper, and that's great. Like stuff is getting cheaper for us. Now that we have reasoning models, well, they've kind of passed the cost on to us, right?
[00:33:04.680 --> 00:33:13.420]   Now I have to pay more for simple reasoning tokens, even though I have basic questions. And I don't want to pay more. I want the big open AI Gemini to pay that cost, right?
[00:33:13.420 --> 00:33:25.180]   And I also don't like how stuff gets slower. So I was like, someone needs to figure out, like, we got to stop throwing reasoning models at everything. We still want great next token predictors.
[00:33:25.840 --> 00:33:43.000]   And like, too many people are using reasoning models for the wrong thing. So like last week, this reasoning survey paper came out. It wasn't the best, but you know, it'll be a good little fill in. So basically, they're trying to coin this term of reasoning economy.
[00:33:43.760 --> 00:33:50.720]   When should we use reasoning models? And they're just like an overview of what are different techniques for post-training reasoning, pre-training reasoning.
[00:33:50.720 --> 00:33:57.360]   So like chain of thought is a version of this. And then how do these systems perform? How can we prune out chain of thought?
[00:33:57.360 --> 00:34:03.760]   And they just like, this is kind of the first reasoning paper that we found here. So I figured we might as well go through it a little bit.
[00:34:03.760 --> 00:34:18.520]   So they kind of have these two systems of reasoning where they're system one and system two. System one is like computationally efficient, but suboptimal, where we have, let's see, what is this again?
[00:34:18.520 --> 00:34:32.620]   Oh, they also have a GitHub repo where they're tracking all this, but I forgot what system one, system two was system two. Oh, so it's like reasoning models and then regular text decoding models, right?
[00:34:32.620 --> 00:34:50.140]   So they kind of start out by saying like, there are some inefficiencies in this, right? We have models wasting tokens. We have like fake thinking where models are just outputting tokens. There's problems in RL where we've RL models and now they're over optimizing on length.
[00:34:50.140 --> 00:34:58.860]   Chain of thought can like help, but it's not a training time. So how do we kind of like look at what's going on here?
[00:35:00.140 --> 00:35:09.480]   There's the two stages, right? There's post-training and then there's the test time. So test time thinking is like, you know, MCTC, Monte Carlo Tree Search MCTS.
[00:35:09.480 --> 00:35:20.960]   There's techniques like you could do speculative decoding, have a little model do stuff fast and then have a big model check it. You could do chain of thought. You could run multiple queries and kind of condense them.
[00:35:20.960 --> 00:35:31.620]   They also have the agent concept where you can have like an agentic model. Then there's the post-training stage where you could do this natively in the model. You can have SFT to kind of do reasoning.
[00:35:31.960 --> 00:35:43.280]   And then they show, you know, like you can have a thousand samples of reasoning data, a thousand sample reasoning data set kind of train in reasoning. You could do proper RL. They dissect a lot of DeepSeq R1 in this paper.
[00:35:43.860 --> 00:35:54.360]   And then there's inefficiencies, right? So RL, you have a length bias. You have deceptive behaviors when you're doing RL. We don't know how to optimize all this or test time when you're doing it.
[00:35:54.360 --> 00:36:09.700]   That inference, you know, we're doing like inefficient usage of computation. So for example, there's a paper that cites, they do up to a thousand to 10,000 parallel calls of Lama 8B. And they're like, yeah, you know, we don't need 10,000 Lama 8B calls for one question.
[00:36:11.160 --> 00:36:22.700]   Then there's like, okay, how do we address these changes, right? So there's the architecture level. What are people working on for model level stuff for reasoning? Those algorithmic stuff, there's the data that goes into it.
[00:36:22.700 --> 00:36:34.440]   And then for the inference side, you know, there's stuff where you can force in an adaptive budget. So for example, you can give in a token that says, how much budget do you want in this question? And then the model learns to follow it.
[00:36:34.700 --> 00:36:45.800]   There's basic routers where you can route to a small, medium, high model, and they sort of cite how O3 does this. So there's O3 mini, O3 high, regular O3. You can have a router.
[00:36:45.800 --> 00:36:54.480]   There's agents. There's the decoding side. So you can do this at inference time. There's different techniques you can do. And they just kind of go through all this.
[00:36:54.480 --> 00:37:03.740]   Let's continue on through here. So this is kind of, you know, a bit of background. What's going on here? What are some of the issues? What are the methods?
[00:37:03.740 --> 00:37:12.360]   So post-training, yeah, we have SFT. You can do SFT and get basic reasoning. They have this cool little diagram chart here.
[00:37:12.360 --> 00:37:23.940]   It kind of shows different processes that we can do, right? So for the reasoning in training time, we can do post-training and we can do test time models.
[00:37:23.940 --> 00:37:34.040]   So we can do SFT, RL. There's parallel methods where you can kind of, you know, shoot out a bunch of models, shoot out a bunch of queries, condense them down in a sort of pipeline.
[00:37:34.500 --> 00:37:41.160]   Then there's, and they show kind of papers that do this, how they perform, how we can prune out chain of thought, how we can make it more efficient.
[00:37:41.160 --> 00:37:45.180]   There's sequential methods. So this is kind of like your pipeline approach, you know.
[00:37:45.920 --> 00:37:51.860]   You have human in the loop. You have guardrails. You have different tool usage. There's different sequential methods.
[00:37:51.860 --> 00:38:01.740]   For post-training, there's stuff like length biases. So, you know, models, there's overly cautious language models.
[00:38:01.920 --> 00:38:06.920]   There's fake thinking that comes in when you do RL. This is just because we don't have the best RL methods.
[00:38:06.920 --> 00:38:17.840]   Then inefficient model usage. So unreasonable algorithmic section, you know, they don't always choose the right algorithm to use.
[00:38:17.840 --> 00:38:24.720]   Are we using the right pipeline for the right task? So are we sending the right queries to the right models?
[00:38:25.540 --> 00:38:31.920]   Unreasonable compute allocation. Of course, you know, this is basically, do you need the biggest model for the basic task?
[00:38:31.920 --> 00:38:39.560]   And can you optimize little models? Then we've got on the other side, you know, the data.
[00:38:39.560 --> 00:38:42.820]   So how can we improve data? They've got algorithmic changes.
[00:38:42.820 --> 00:38:54.360]   So you can have a length penalty while training, procedure reward where you can, they kind of break down what are the two types of ways to affect length output
[00:38:54.360 --> 00:39:00.200]   and reasoning. So there's, you know, end output where you can kind of judge what is the end output?
[00:39:00.200 --> 00:39:02.680]   Is the math correct? Is the code correct? Does it compile?
[00:39:02.680 --> 00:39:06.760]   And then there's also a process of what is the process code? How do we affect that?
[00:39:06.760 --> 00:39:12.300]   Long to short RL, adaptive budget aware tuning. So this is kind of fine tuning with a budget.
[00:39:12.300 --> 00:39:15.540]   Then on the architect, there's also a chain of thought compression.
[00:39:15.540 --> 00:39:22.440]   So explicit and implicit. Explicit is where you directly prune 70% of the wrong chain of thought.
[00:39:22.740 --> 00:39:25.300]   And then, you know, you train on more efficient chain of thought.
[00:39:25.300 --> 00:39:34.240]   Implicit is where in the model itself, the architecture makes it such that different queries go through more efficient parts of the architecture.
[00:39:36.340 --> 00:39:42.120]   There's recurrent layers that you can kind of, you know, you can recurrently keep this memory state to do this.
[00:39:42.120 --> 00:39:47.540]   There's dynamic depth, model routing, multimodal stuff, knowledge distillation.
[00:39:47.540 --> 00:39:51.740]   So they kind of talk about how you can basically distill out reasoning.
[00:39:52.220 --> 00:39:57.520]   So DeepSeq did this with base quant models, llama models, and how effective that can be.
[00:39:57.520 --> 00:40:00.080]   Then improvement in test time.
[00:40:00.080 --> 00:40:08.060]   So on the input side, you know, you tell it, budget allocation, there's adaptive decoding algorithm, so kind of speculative decoding.
[00:40:08.460 --> 00:40:16.640]   On the output side, early stopping, search with pruning, constrained decoding, basically fun little chart of different stuff.
[00:40:16.640 --> 00:40:20.100]   If you're interested in any of this, they have a bunch of papers linked.
[00:40:21.540 --> 00:40:27.820]   Okay, so they start off with, you know, DeepSeq showed that you don't need to do SFT.
[00:40:27.820 --> 00:40:30.540]   You can perform RL.
[00:40:30.540 --> 00:40:34.200]   They did find that SFT still accelerates stuff.
[00:40:34.200 --> 00:40:38.420]   So in the final run, they did a little bit of SFT before their RL.
[00:40:38.420 --> 00:40:46.840]   The core focus of RL currently lies in the design of reward signals.
[00:40:47.000 --> 00:40:48.260]   So there's two type of rewards.
[00:40:48.260 --> 00:40:51.800]   There's process reward models and outcome reward models.
[00:40:51.800 --> 00:40:56.480]   Process kind of enables more fine-grained learning signals guiding the LLMs.
[00:40:56.480 --> 00:40:59.200]   And then there's the outcome, right?
[00:40:59.200 --> 00:41:01.560]   This is kind of where you look at what is the final thing.
[00:41:01.560 --> 00:41:03.140]   So is the math correct and whatnot?
[00:41:03.140 --> 00:41:09.480]   ORM provides supervision signal at outcome level.
[00:41:09.480 --> 00:41:12.200]   Then they kind of talk about the test time.
[00:41:12.200 --> 00:41:15.180]   So they show how, like, you know, one is kind of still pretty strong.
[00:41:15.320 --> 00:41:27.500]   So even though you can, like, instead of looking at the process and kind of, like, pruning the chain of thought itself, if you only do ORM, so if you only do RL on outputs, you still have really good capabilities, right?
[00:41:27.500 --> 00:41:31.160]   Like, DeepSeq still had this aha moment, and it's still doing good reasoning.
[00:41:32.660 --> 00:41:35.220]   Test time methods are kind of, you know, parallel methods.
[00:41:35.220 --> 00:41:40.040]   So parallel is you have LLMs generate several calls, sequential methods.
[00:41:40.040 --> 00:41:44.500]   So it's just kind of your free of thought, chain of thought, MCTS, beam search.
[00:41:45.880 --> 00:41:54.120]   And then their kind of, like, takeaway here is that, yeah, you know, the full potential reasoning is not achieved.
[00:41:54.120 --> 00:41:56.120]   They have cool statistics here.
[00:41:58.460 --> 00:42:06.540]   Then in section three, we talk about, like, inefficiencies in this model training.
[00:42:06.540 --> 00:42:11.380]   So there's inefficient model behaviors from post-training, right?
[00:42:11.380 --> 00:42:18.520]   So first one is basically a length bias where you can have reasoning that's overly cautious, and this affects simple questions, right?
[00:42:18.520 --> 00:42:25.140]   So LLMs trained with RL tend to produce longer responses than SFT, that makes sense.
[00:42:25.140 --> 00:42:27.520]   Now, there's two questions that they have.
[00:42:27.520 --> 00:42:35.240]   So what are the reasons for longer responses, and does this increased length indicate a bias or enhancement of model capabilities?
[00:42:35.240 --> 00:42:52.140]   So overly cautious reasoning models, you know, model excessively has unnecessary verification steps and redundant reasoning on easy-to-handle questions for meaningless paraphrases and deviations.
[00:42:52.140 --> 00:42:53.400]   We don't want that.
[00:42:53.400 --> 00:42:55.480]   Deceptive behaviors.
[00:42:55.480 --> 00:43:01.080]   There was some work done that, you know, models don't output the real thinking that they're doing.
[00:43:01.380 --> 00:43:08.740]   Fake thinking happens where, you know, a model is just outputting tokens, even though we can see that it has the answer pretty early on.
[00:43:08.740 --> 00:43:11.220]   That's kind of section 3.1.
[00:43:11.220 --> 00:43:13.840]   So what's happening inefficiently?
[00:43:13.840 --> 00:43:16.240]   Then there's the test time inefficient stuff, right?
[00:43:16.240 --> 00:43:18.780]   So are we using the right hyperparameters?
[00:43:18.780 --> 00:43:20.400]   Do we have the right pipelines?
[00:43:20.400 --> 00:43:23.860]   Are we kind of at test time doing the right thing?
[00:43:23.860 --> 00:43:26.720]   Unreasonable computation allocation.
[00:43:26.720 --> 00:43:31.280]   So, you know, this is that example of scaling computation.
[00:43:31.280 --> 00:43:37.620]   So scaling LAMA 3AB instructs generating 100,000 to 10,000 samples for simple questions.
[00:43:37.620 --> 00:43:41.000]   There's reasoning boundaries.
[00:43:41.000 --> 00:43:50.400]   But basically, they want to say that they emphasize the importance of adaptive computation allocation based on task complexity.
[00:43:50.400 --> 00:43:59.220]   So for more complex tasks, we should have, you know, a better way to allocate resources.
[00:43:59.220 --> 00:44:00.580]   Okay.
[00:44:00.580 --> 00:44:03.560]   Section 4 is kind of on two things.
[00:44:03.560 --> 00:44:05.020]   So part one is the data.
[00:44:05.020 --> 00:44:07.980]   So what is the data that's used for reasoning?
[00:44:08.740 --> 00:44:13.820]   Basically, there's explicitly encoding in desired reasoning patterns is one way.
[00:44:13.820 --> 00:44:15.980]   And we can do this with even basic SFT.
[00:44:15.980 --> 00:44:25.260]   So there was that paper where they showed, you know, a thousand diverse SFT samples can do basic reasoning that's on par with O1 preview at the time.
[00:44:25.260 --> 00:44:30.680]   But what's most important is quality, diversity, and difficulty of this data.
[00:44:30.680 --> 00:44:33.580]   Then there's kind of the algorithms that approach this.
[00:44:33.660 --> 00:44:35.820]   So they have this long to short RL.
[00:44:35.820 --> 00:44:45.500]   These are strategies like, you know, where you have model merging of different models that try different things, shortest rejection, sampling, DPO, optimization.
[00:44:45.500 --> 00:44:54.520]   This one kind of showed that you can have about a 30 to 40 percent drop in tokens with no accuracy drop.
[00:44:54.520 --> 00:44:58.260]   Budget aware tuning was another one where they shaved off.
[00:44:58.260 --> 00:45:00.000]   Where's budget aware?
[00:45:00.060 --> 00:45:09.060]   So budget aware tuning, this is another approach where a budget prediction allocation was implemented.
[00:45:09.060 --> 00:45:16.420]   This approach achieved a 67 percent reduction in response length with only a 3 percent loss in accuracy.
[00:45:16.420 --> 00:45:21.860]   They kind of have a little cute little diagram of these different things.
[00:45:21.860 --> 00:45:28.920]   So how they're budget aware is basically, you know, similar to O1, you have easy, middle, hard stuff.
[00:45:28.920 --> 00:45:32.480]   You have an output allocation that you want towards this question.
[00:45:32.480 --> 00:45:37.360]   Shave off a bunch of response output tokens and 3 percent loss.
[00:45:37.360 --> 00:45:39.700]   Chain of thought compression is another one.
[00:45:39.700 --> 00:45:41.460]   You've got explicit and implicit.
[00:45:42.600 --> 00:45:48.120]   Kind of as they seem, implicit is where you implicitly compress out.
[00:45:48.120 --> 00:45:56.460]   Explicit, sorry, implicit is model based where, you know, you have an architecture that kind of tries to optimize this.
[00:45:56.460 --> 00:45:58.960]   Explicit is where you where you do it out.
[00:46:00.340 --> 00:46:02.340]   Both of these work.
[00:46:02.340 --> 00:46:06.560]   There's different benefits to both and they just have papers that you could follow along with.
[00:46:06.560 --> 00:46:12.660]   OK, architecture wise, there's system one and system two cooperation.
[00:46:12.660 --> 00:46:22.040]   So this is where you kind of have this routing layer where you can have a system where you have something like O1 where you have three distinct thinking models.
[00:46:22.040 --> 00:46:22.260]   Right.
[00:46:22.260 --> 00:46:23.480]   O1 low, middle, high.
[00:46:24.000 --> 00:46:26.020]   You kind of have this model routing.
[00:46:26.020 --> 00:46:28.220]   There's model to model collaboration.
[00:46:28.220 --> 00:46:31.140]   So you have pipelines that have different models.
[00:46:31.140 --> 00:46:34.960]   This is stuff where you have things like speculative decoding.
[00:46:34.960 --> 00:46:42.180]   So speculative decoding, there's first a small model that generates candidate tokens, then a big model that verifies them in parallel.
[00:46:42.180 --> 00:46:44.880]   This has two to three X speed up.
[00:46:44.880 --> 00:46:47.840]   Then they have the whole topic of knowledge distillation.
[00:46:47.840 --> 00:46:50.260]   So you have a big model, you distill it down.
[00:46:51.120 --> 00:47:01.680]   And then, you know, DeepSeq R1 outperforms applying RL on base model to Quen 2.532B where you can distill out and do RL.
[00:47:01.680 --> 00:47:02.860]   That was very effective.
[00:47:02.860 --> 00:47:06.100]   Then they have like more architecture, architecture stuff.
[00:47:06.100 --> 00:47:12.820]   So you've got adaptive active parameters.
[00:47:13.660 --> 00:47:20.880]   So this is more so like where you can have a recurrent layer and you can sort of add different depth to different queries.
[00:47:20.880 --> 00:47:24.600]   So the model itself has different depth that different queries are passed through.
[00:47:24.600 --> 00:47:27.040]   There's different research going on in this.
[00:47:27.040 --> 00:47:29.460]   Dynamic depth.
[00:47:29.460 --> 00:47:31.660]   What else have we got?
[00:47:32.600 --> 00:47:34.780]   Then we've got test time.
[00:47:34.780 --> 00:47:42.240]   So inference time, how do we add inference time outside of the model, outside of RL, how do we adapt how much compute is spent?
[00:47:42.240 --> 00:47:45.120]   So you've got adaptive budget decoding.
[00:47:45.120 --> 00:47:47.860]   So this is stuff where you've got like budget prediction.
[00:47:47.860 --> 00:47:56.460]   Budget prediction is where, you know, we basically train in something where you tell or you basically tell it, you know, I want this many tokens to be produced.
[00:47:56.940 --> 00:47:58.420]   How well does that do?
[00:47:58.420 --> 00:48:00.620]   There's budget constraint generation.
[00:48:00.620 --> 00:48:03.740]   There's early stopping, search with pruning.
[00:48:03.740 --> 00:48:06.820]   There's adaptive selection.
[00:48:06.820 --> 00:48:08.540]   What else?
[00:48:08.540 --> 00:48:13.980]   Early stopping, pruning, constraint decoding.
[00:48:13.980 --> 00:48:18.860]   And then that's kind of like survey of what's happened so far.
[00:48:18.860 --> 00:48:23.260]   Then they go into discussion of like what else is still not being done.
[00:48:23.260 --> 00:48:26.480]   So then there's this topic of multimodal reasoning, right?
[00:48:26.560 --> 00:48:32.740]   Right now, language models, language reasoning models, they call LRMs, they're only text.
[00:48:32.740 --> 00:48:37.740]   So what happens when we have multimodal reasoning models, like vision models that also reason?
[00:48:37.740 --> 00:48:40.360]   How are we optimizing for that?
[00:48:40.360 --> 00:48:48.800]   In their survey currently for multimodal reasoning models, all they're doing is like current architecture level stuff.
[00:48:48.980 --> 00:49:05.440]   So model architecture optimization, so lightweight vision encoders, vision token compression, vision language productors, smaller language models, efficient structures, efficient vision technique adaptation, VIT quantization.
[00:49:06.160 --> 00:49:10.920]   So, you know, evaluation of this like isn't really being optimized.
[00:49:12.340 --> 00:49:14.720]   Then there's efficient agentic reasoning.
[00:49:14.720 --> 00:49:21.180]   So stuff like deep research, how do we efficiently do agentic reasoning?
[00:49:21.180 --> 00:49:23.300]   They bring up some benchmarks.
[00:49:23.520 --> 00:49:27.200]   So like DNA bench is one, humanity last exam.
[00:49:27.200 --> 00:49:30.900]   How do we sort of start to efficiently benchmark these things, right?
[00:49:30.900 --> 00:49:35.400]   And then are we optimizing for the outcome versus process efficiency?
[00:49:35.400 --> 00:49:38.760]   And then there's different benchmarks that they bring up for these.
[00:49:40.700 --> 00:49:42.980]   This is kind of like the Mechinterp side.
[00:49:42.980 --> 00:49:48.460]   So Anthropic is doing some interesting work on what's actually happening during this reasoning.
[00:49:48.460 --> 00:49:53.300]   And then that's kind of it, you know, they kind of bring up, here's a bunch of sources.
[00:49:53.300 --> 00:49:54.740]   Here's different stuff on reasoning.
[00:49:54.740 --> 00:49:56.660]   Here's how we can optimize different things.
[00:49:56.660 --> 00:50:02.820]   And they've got a bit of different sorts, but not the deepest paper, you know, 15 minute overview.
[00:50:02.820 --> 00:50:07.340]   That's some stuff happening in reasoning model optimization.
[00:50:08.300 --> 00:50:12.740]   Okay, I want to give Suik's five, six minutes, but any one, two questions?
[00:50:12.740 --> 00:50:20.660]   Not from me.
[00:50:20.660 --> 00:50:22.380]   There's not much time or so.
[00:50:22.380 --> 00:50:22.720]   Yeah.
[00:50:22.720 --> 00:50:25.160]   Okay, Suik's passed to you.
[00:50:25.160 --> 00:50:27.080]   Okay.
[00:50:27.080 --> 00:50:31.640]   Today we cover a one-day-old paper.
[00:50:31.640 --> 00:50:37.640]   So very of the moment.
[00:50:37.840 --> 00:50:38.700]   Can you see my screen?
[00:50:38.700 --> 00:50:39.340]   Yes, you can.
[00:50:39.340 --> 00:50:41.120]   So this is the leaderboard illusion.
[00:50:41.120 --> 00:50:47.960]   I think basically it is Cohere not doing well on LM Arena and then Cohere saying this is fucked up.
[00:50:47.960 --> 00:50:50.460]   But they are correct.
[00:50:50.460 --> 00:50:59.460]   I mean, this is open secret for a long time that you can somewhat game LM Arena and it is somewhat pay-to-play.
[00:51:01.520 --> 00:51:06.120]   But it is, I think I'm not as negative as some of the others.
[00:51:06.120 --> 00:51:08.300]   I think this is just capitalism at work.
[00:51:08.300 --> 00:51:21.220]   Anyway, I do also probably think that it was a bad idea for LM Arena to announce that they are becoming a company at the exact same time that people are questioning their commercial business model.
[00:51:22.600 --> 00:51:24.700]   And this is the result.
[00:51:24.700 --> 00:51:28.540]   This could be the end of them if they don't handle it very well.
[00:51:28.540 --> 00:51:32.580]   So Cohere says four things.
[00:51:34.880 --> 00:51:40.280]   One, this is the most obvious one that was obviously going on.
[00:51:40.280 --> 00:51:46.500]   At some point in time, Gemini had like three or four different variations on LM Arena at any one point in time.
[00:51:46.500 --> 00:51:48.340]   And then they just released whatever score is the highest.
[00:51:48.340 --> 00:51:53.040]   Therefore, on a normal distribution, you would just get a very skewed like p-hack.
[00:51:53.160 --> 00:51:59.420]   This is literally just p-hacking of results, which is not fair to everyone else who does not have that capability.
[00:51:59.420 --> 00:52:02.620]   And basically, they were alleging that only four labs had access to that.
[00:52:02.620 --> 00:52:09.900]   I know this from off-the-record stuff as well from other people who are trying to submit things to LM Arena.
[00:52:11.520 --> 00:52:14.840]   They also were able to, they also like sold data access.
[00:52:14.840 --> 00:52:24.120]   They, I think there's some arguments about like the kinds of battles that LM Arena was exposing to.
[00:52:24.120 --> 00:52:32.900]   And then the, and then they also, they also accused LM Arena of silently removing models, even though there were some official removed models as well.
[00:52:32.900 --> 00:52:35.180]   So about 66% were silently removed.
[00:52:35.180 --> 00:52:40.760]   So I think this graphic is just really good overview of what the accusations were.
[00:52:40.760 --> 00:52:42.840]   They have some evidence about it.
[00:52:42.840 --> 00:52:44.420]   I think some of them are stronger than others.
[00:52:44.420 --> 00:52:51.320]   But I just would highlight for folks the, the, the conclusions as well.
[00:52:51.320 --> 00:52:57.600]   Because I think like the, the sensitive thing about this is that Cohera itself is a pretty large lab.
[00:52:57.600 --> 00:53:06.660]   And for them to criticize LM Arena, which is basically two Stanford, two UC Berkeley guys, is, you know, punching down.
[00:53:06.660 --> 00:53:10.000]   So they, but they obviously, LM Arena has a lot of influence.
[00:53:10.000 --> 00:53:16.380]   So I think they, the important thing is to have constructive suggestions around what to do, given that LM Arena is a thing, right?
[00:53:16.380 --> 00:53:21.460]   Like I think in, in a fair world, maybe a lot of people would rather that LM Arena just doesn't exist.
[00:53:21.720 --> 00:53:25.300]   But now that it does exist and people do use it, what do we do about it?
[00:53:25.300 --> 00:53:33.680]   So they, they had some really good suggestions, I thought, which was, don't allow people to retract scores that do, do badly.
[00:53:33.680 --> 00:53:36.620]   It's like, you know, just because you did badly, you don't get to hide it.
[00:53:38.380 --> 00:53:46.220]   Two, limit, limit, limit model submissions, so that you don't get to spam models and only promote the best ones.
[00:53:46.220 --> 00:53:53.340]   Three, have equal levels of model removals of, between closed source and open source.
[00:53:53.340 --> 00:53:54.800]   So don't favor closed source.
[00:53:54.800 --> 00:53:57.040]   Four, implement fair sampling.
[00:53:57.040 --> 00:53:57.920]   I love this one.
[00:53:58.080 --> 00:54:00.060]   Okay, so this is very fun, right?
[00:54:00.060 --> 00:54:14.300]   So LM Arena is a, is a sampling problem, meaning they, they, they have to like find workloads and then like sort of match them up and, and try to, try to arrive at some reasonable ELO number.
[00:54:14.300 --> 00:54:23.560]   It turns out that the authors of LM Arena originally had a methodology which was more like active learning and they abandoned it.
[00:54:23.560 --> 00:54:26.360]   So I really like the sentence.
[00:54:26.360 --> 00:54:34.440]   This formulation avoids simply favoring large proprietary providers and instead effectively prioritizes under-evaluated and high-variance pairs.
[00:54:34.440 --> 00:54:39.940]   And this, this word, high-variance pairs, made me realize like, oh yeah, I mean, that's obviously what you should focus on.
[00:54:39.940 --> 00:54:52.640]   This is very active learning in the sense of like, okay, if, if you have a lot of, if you have a lot of, if you have a place with a lot of disagreements, you should focus your battles on those pairs to lower the variance by increasing the, the sample size.
[00:54:52.640 --> 00:54:59.980]   And, and apparently they had a paper on this and they ended up not doing it.
[00:54:59.980 --> 00:55:01.380]   So it's kind of interesting there.
[00:55:01.380 --> 00:55:04.560]   And then finally, provide transparency.
[00:55:04.560 --> 00:55:05.500]   This is fine.
[00:55:05.500 --> 00:55:06.060]   This is normal.
[00:55:07.020 --> 00:55:07.420]   Yeah.
[00:55:07.420 --> 00:55:10.340]   Any questions or debates about this one?
[00:55:10.340 --> 00:55:14.260]   What's the Lama T?
[00:55:14.260 --> 00:55:15.600]   What happened with Lama 4?
[00:55:15.600 --> 00:55:18.780]   I think they published this before Lama 4.
[00:55:18.780 --> 00:55:20.260]   I don't think, I don't think Lama 4 was discussed.
[00:55:20.260 --> 00:55:23.440]   Oh, yeah, there you go.
[00:55:23.440 --> 00:55:24.920]   Oh, in the lead up to Lama 4.
[00:55:24.920 --> 00:55:28.100]   But I don't think, I don't think they had the Lama chat issue.
[00:55:28.100 --> 00:55:32.780]   That first paragraph is crazy though.
[00:55:32.780 --> 00:55:34.120]   27 variants.
[00:55:35.800 --> 00:55:36.160]   Yeah.
[00:55:36.160 --> 00:55:39.480]   I think it's interesting.
[00:55:39.480 --> 00:55:45.980]   Like they say substantially higher sampling rates for OpenAI, Google, XAI and Meta.
[00:55:45.980 --> 00:55:50.400]   So one, two, three, four, but XAI is like a lot lower than the other two.
[00:55:50.400 --> 00:55:51.960]   And then Meta is even lower than that.
[00:55:51.960 --> 00:55:54.600]   Amazon, I think decently, nicely treated.
[00:55:54.600 --> 00:56:01.800]   But yeah, I mean, so, you know, I think now it's kosher to say that the ones that were treated the worst was RECA.
[00:56:02.360 --> 00:56:04.140]   And I heard about it directly from RECA.
[00:56:04.140 --> 00:56:08.420]   So it's very sad.
[00:56:08.420 --> 00:56:11.480]   Yeah.
[00:56:11.480 --> 00:56:14.560]   At the top level, they also put out the most, right?
[00:56:14.560 --> 00:56:17.420]   Google OpenAI have the most models compared to Meta.
[00:56:17.420 --> 00:56:21.940]   Yeah, but RECA had trouble submitting RECA 2 and RECA 3.
[00:56:24.940 --> 00:56:34.080]   So yeah, that's, I think this is a useful pushback on LM Arena.
[00:56:34.080 --> 00:56:35.540]   And I really liked that.
[00:56:35.540 --> 00:56:43.980]   I thought it was very classy that they, first, they actually shared this with the LM Arena team before publishing this paper, which I thought is just responsible disclosure.
[00:56:45.460 --> 00:56:45.900]   Cool.
[00:56:45.900 --> 00:56:47.220]   That's a short paper.
[00:56:47.220 --> 00:56:48.980]   I thought it was very interesting.
[00:56:48.980 --> 00:56:53.680]   Senpai actually said like, oh yeah, LM Arena is dead to me.
[00:56:53.680 --> 00:56:55.340]   Now OpenRouter is my best friend.
[00:56:55.340 --> 00:57:03.100]   So now the same dynamics are going to apply to OpenRouter because that's how these things work.
[00:57:04.680 --> 00:57:13.720]   So yeah, so now he's talking about OpenRouter rankings and basically this favors cost is my general takeaway.
[00:57:13.720 --> 00:57:27.660]   So when Gemini launched, Gemini 2 flashed launch and it was free, suddenly it shot out to, you know, one of the most popular APIs, which is not a surprise because it's free.
[00:57:29.860 --> 00:57:30.300]   Yeah.
[00:57:30.300 --> 00:57:34.660]   Cool.
[00:57:34.660 --> 00:57:35.560]   Okay.
[00:57:35.560 --> 00:57:36.980]   Did people have questions?
[00:57:36.980 --> 00:57:38.320]   I'm not seeing the chat.
[00:57:38.320 --> 00:57:41.960]   Cool.
[00:57:41.960 --> 00:57:42.400]   All right.
[00:57:42.400 --> 00:57:43.860]   I think that's it.
[00:57:43.860 --> 00:57:44.660]   We're out of time.
[00:57:44.660 --> 00:57:52.460]   I'm happy to talk about AI News another time, but there was somebody who had a question about the search on AI News.
[00:57:52.460 --> 00:57:55.960]   And basically it is all pre-built.
[00:57:55.960 --> 00:57:59.100]   That's why it's fast because there's no compute.
[00:57:59.100 --> 00:58:02.560]   Everything's pre-indexed.
[00:58:02.560 --> 00:58:04.200]   So if I do like...
[00:58:04.200 --> 00:58:17.100]   I mean, doesn't, isn't that search whereby you type a keyword and it was actually able to do the lexical side?
[00:58:17.100 --> 00:58:18.100]   Yeah.
[00:58:18.100 --> 00:58:18.580]   Yeah.
[00:58:18.580 --> 00:58:20.320]   I don't think, I don't think, I don't know.
[00:58:20.320 --> 00:58:23.700]   Someone was impressed by that, but I don't think it's particularly much to it.
[00:58:23.700 --> 00:58:25.900]   Like I have a year's worth of content in here.
[00:58:25.900 --> 00:58:27.040]   It's not that much.
[00:58:27.040 --> 00:58:30.340]   You know, everything can fit in a JSON file.
[00:58:30.340 --> 00:58:35.800]   Seems like we didn't have time to discuss what people are next week, but I think it's the Lama series, right?
[00:58:35.800 --> 00:58:36.260]   Yeah.
[00:58:36.260 --> 00:58:37.280]   The Lama series.
[00:58:39.980 --> 00:58:40.740]   So, okay.
[00:58:40.740 --> 00:58:42.380]   Next week we're talking Lama.
[00:58:42.380 --> 00:58:43.800]   Thank you, Rafa.
[00:58:43.800 --> 00:58:45.600]   I thought I could confirm with him, but...
[00:58:45.600 --> 00:58:46.760]   Yeah, most likely.
[00:58:46.760 --> 00:58:49.200]   I'll never talk this in a while.
[00:58:49.200 --> 00:58:49.520]   Okay.
[00:58:49.520 --> 00:58:51.120]   Either it's Tom or Vibu, I guess.
[00:58:51.120 --> 00:58:51.640]   No, I'm kidding.
[00:58:51.640 --> 00:58:54.380]   Okay.
[00:58:54.380 --> 00:58:55.100]   Take care.
[00:58:55.100 --> 00:58:55.540]   Thank you, Rafa.
[00:58:55.540 --> 00:58:56.120]   Bye.

