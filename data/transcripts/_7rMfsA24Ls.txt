
[00:00:00.880 --> 00:00:06.680]   Hi, everybody and welcome to deep learning foundations to stable diffusion.
[00:00:06.680 --> 00:00:12.000]   Hopefully it's not too confusing that this is described here as lesson nine.
[00:00:12.000 --> 00:00:16.120]   That's because strictly speaking, we treat this as part two of the
[00:00:16.120 --> 00:00:18.720]   practical deep learning for coders series.
[00:00:18.720 --> 00:00:24.200]   Um, so that part one had eight lessons.
[00:00:24.200 --> 00:00:28.840]   So this is lesson nine, but don't worry, you didn't miss anything.
[00:00:28.880 --> 00:00:31.640]   It's the first lesson of, of part two.
[00:00:31.640 --> 00:00:37.040]   Um, which is called deep learning foundations to stable diffusion.
[00:00:37.040 --> 00:00:40.720]   And maybe rather than calling it practical deep learning for coders, we should
[00:00:40.720 --> 00:00:44.640]   call this, um, impractical deep learning for coders in the sense that we are
[00:00:44.640 --> 00:00:48.880]   certainly not going to be spending all of our time seeing exactly how to do
[00:00:48.880 --> 00:00:50.960]   important things with, with deep learning.
[00:00:50.960 --> 00:00:55.840]   Um, but we'll be doing a whole lot of fun things, generative,
[00:00:55.840 --> 00:01:00.600]   modally fun things, and also a whole lot of understanding lots of details,
[00:01:00.600 --> 00:01:06.520]   which you won't necessarily need to know, um, um, to use this stuff.
[00:01:06.520 --> 00:01:11.200]   Um, but if you want to become a researcher, um, or if you want to like
[00:01:11.200 --> 00:01:14.520]   put something in production, which has got like some kind of complex
[00:01:14.520 --> 00:01:18.080]   customization requirements, stuff like that, um, then it is going to be very
[00:01:18.080 --> 00:01:20.560]   helpful to learn the details we'll be talking about.
[00:01:21.520 --> 00:01:27.040]   Um, so here in lesson nine, there's kind of going to be two parts to it.
[00:01:27.040 --> 00:01:32.760]   One is just a quick, uh, run through quick ish run through of, of, of using
[00:01:32.760 --> 00:01:38.240]   stable diffusion, um, because we're all dying to play with it.
[00:01:38.240 --> 00:01:39.040]   Right.
[00:01:39.040 --> 00:01:47.240]   And then, um, the other thing that I'll be doing is describing in some detail.
[00:01:47.240 --> 00:01:48.440]   What's going on?
[00:01:48.440 --> 00:01:49.200]   How is it working?
[00:01:50.280 --> 00:01:55.880]   Um, there'll be a whole lot of hand waving either way, because it's
[00:01:55.880 --> 00:02:01.280]   going to take us a few lessons to describe everything from scratch.
[00:02:01.280 --> 00:02:04.480]   Um, but hopefully, you know, you'll get a, you'll feel like you'll come away
[00:02:04.480 --> 00:02:07.720]   from this, with this lesson, with a reasonable, you know, intuitive
[00:02:07.720 --> 00:02:09.920]   understanding at least of how, how this is all working.
[00:02:09.920 --> 00:02:14.080]   Um, assumptions.
[00:02:14.080 --> 00:02:18.760]   Um, well, I'm going to try to explain everything.
[00:02:19.400 --> 00:02:22.200]   Like everything, I'm going to try to explain everything.
[00:02:22.200 --> 00:02:30.120]   So like, if you haven't done deep learning before, um, this is going to be very hard.
[00:02:30.120 --> 00:02:33.360]   Um, but I will at least be trying to say like, this is roughly what's going
[00:02:33.360 --> 00:02:35.080]   on and where you can find out more.
[00:02:35.080 --> 00:02:39.880]   Having said that, um, I would strongly suggest doing part one, um, before
[00:02:39.880 --> 00:02:43.800]   doing this course, unless you really want to throw yourself in the deep, deep end
[00:02:43.800 --> 00:02:45.880]   and give yourself quite, quite the test.
[00:02:46.400 --> 00:02:50.080]   Um, if you haven't done part one of practical deep learning for coders, but
[00:02:50.080 --> 00:02:53.600]   you're, you know, reasonably comfortable with deep learning basics, you could like
[00:02:53.600 --> 00:02:56.960]   write a basic SG SGD loop in Python.
[00:02:56.960 --> 00:03:03.560]   Um, and you know, you know how to use ideally PyTorch, but TensorFlow is
[00:03:03.560 --> 00:03:04.720]   probably okay as well.
[00:03:04.720 --> 00:03:11.960]   Um, and you kind of know the basic ideas of how to create, um, you know, what
[00:03:11.960 --> 00:03:14.800]   an embedding is, and you could create one of those and scratch stuff like that.
[00:03:15.720 --> 00:03:17.880]   Um, you know, you'll probably be fine.
[00:03:17.880 --> 00:03:22.600]   Uh, generally speaking for these courses, I find most people tend to watch the
[00:03:22.600 --> 00:03:27.280]   videos a few times, um, and often the second time through folks will like pause
[00:03:27.280 --> 00:03:29.320]   and look things up, they don't know and check things out.
[00:03:29.320 --> 00:03:35.640]   Um, generally speaking, you know, we expect people to be spending about
[00:03:35.640 --> 00:03:38.240]   10 hours of work on each video.
[00:03:38.240 --> 00:03:41.600]   Um, having said that some people spend a hell of a lot more and go very deep.
[00:03:41.600 --> 00:03:45.960]   Some people will spend a whole year, you know, sabbatical studying practical deep
[00:03:45.960 --> 00:03:49.760]   learning for coders in order to really fully understand everything.
[00:03:49.760 --> 00:03:52.320]   So really it's up to you as to how deep you go.
[00:03:52.320 --> 00:03:53.360]   Okay.
[00:03:53.360 --> 00:03:58.800]   Um, so with that said, um, let's jump into it.
[00:03:58.800 --> 00:04:04.200]   And as I said, the first part we're going to be playing around with, um, stable
[00:04:04.200 --> 00:04:11.920]   diffusion and I, you know, try to, you know, prepare this as late as possible.
[00:04:11.920 --> 00:04:13.040]   So it wouldn't be out of date.
[00:04:13.040 --> 00:04:19.560]   Um, unfortunately, um, as of 12 hours ago, it is now out of date.
[00:04:19.560 --> 00:04:23.400]   Um, and this is one of the big issues with the bit I'm about to describe, which
[00:04:23.400 --> 00:04:26.960]   is like how to play with stable diffusion and exactly how do the details work?
[00:04:26.960 --> 00:04:33.560]   Which is, um, it's moving so quickly that all of the details I'm going to describe
[00:04:33.560 --> 00:04:36.240]   to you today and all of the software I'm going to show you today, by the time you
[00:04:36.240 --> 00:04:38.880]   watch this, if you're watching it, so what was it up to now?
[00:04:38.880 --> 00:04:41.200]   It's a 11th of October.
[00:04:41.200 --> 00:04:44.960]   So if you're watching this in like December of 2022 or watching this in
[00:04:44.960 --> 00:04:48.960]   2023, the details will have changed.
[00:04:48.960 --> 00:04:56.000]   Um, so, so what's happened today in the last 24 hours is two, um, papers have come
[00:04:56.000 --> 00:04:56.360]   out.
[00:04:56.360 --> 00:05:00.720]   Uh, so what I was going to be telling you today is for example, to do a stable
[00:05:00.720 --> 00:05:05.360]   diffusion generative model, um, the number of steps required has gone down
[00:05:05.360 --> 00:05:08.800]   from a thousand to about 40 or 50.
[00:05:08.800 --> 00:05:15.120]   Um, but then as of, yeah, uh, last night, uh, papers just come out and saying it's
[00:05:15.120 --> 00:05:18.520]   now down to four and it's 256 times faster.
[00:05:18.520 --> 00:05:23.440]   And then another paper has come out with a separate, I think, orthogonal approach.
[00:05:23.440 --> 00:05:30.680]   Um, which makes it another, um, uh, let's see, 10 to 10.
[00:05:30.680 --> 00:05:31.840]   To 20 times faster.
[00:05:31.840 --> 00:05:35.040]   So things are very exciting.
[00:05:35.040 --> 00:05:37.680]   Um, things are moving very quickly.
[00:05:37.680 --> 00:05:45.320]   Now, having said that, don't worry, because after this lesson, we're going to
[00:05:45.320 --> 00:05:49.080]   be going from the foundations, which means we're going to be learning all the things
[00:05:49.080 --> 00:05:54.080]   of how these are built up and those don't change much at all.
[00:05:54.080 --> 00:05:58.480]   And in fact, a lot of what we'll be seeing is extremely similar to another
[00:05:58.480 --> 00:06:02.440]   course we did in 2019, um, cause the foundations don't change.
[00:06:02.440 --> 00:06:08.240]   And once you know, the foundations, um, these kinds of details about the, you
[00:06:08.240 --> 00:06:11.320]   know, that you'll find in these papers, you'll be like, Oh, I see.
[00:06:11.320 --> 00:06:13.120]   They did all these things the same way as usual.
[00:06:13.120 --> 00:06:14.280]   And they made this little change.
[00:06:14.280 --> 00:06:19.240]   Um, so that's why we do things from the foundations so that you can keep up
[00:06:19.240 --> 00:06:25.360]   with the research, do your own research, um, by taking advantage of this
[00:06:25.360 --> 00:06:29.080]   foundational knowledge, which, you know, all these papers are building on top of.
[00:06:29.080 --> 00:06:35.320]   So anyway, I guess I should apologize that even as I record this, um, the, you
[00:06:35.320 --> 00:06:38.080]   know, the notebook is now one day out of date.
[00:06:38.080 --> 00:06:45.520]   So in part one, you know, you might remember, we saw this stuff of Dali
[00:06:45.520 --> 00:06:52.200]   to the illustrations of Twitter by Twitter bios, um, which really, uh, pretty cool.
[00:06:52.720 --> 00:06:59.360]   Um, so, you know, the cool thing is that we're now at a point we can build this
[00:06:59.360 --> 00:07:02.760]   stuff, ourself and run this stuff ourself.
[00:07:02.760 --> 00:07:04.680]   We won't actually be doing it using this particular model.
[00:07:04.680 --> 00:07:07.200]   Dali too, we'll be using a different model, stable diffusion.
[00:07:07.200 --> 00:07:13.200]   Um, but, uh, has very similar kind of outputs, but we can go even further now.
[00:07:13.200 --> 00:07:19.480]   Um, so, uh, one of our wonderful alumni, Alon actually recently started
[00:07:19.480 --> 00:07:24.360]   a new company called, I don't know who said it, Struma, um, where you can use
[00:07:24.360 --> 00:07:29.600]   something that we'll be learning about, um, today called dream booth, um, to put
[00:07:29.600 --> 00:07:33.920]   any object, person, whatever, uh, into an image.
[00:07:33.920 --> 00:07:40.080]   And so he was kind enough to do a quick dream booth run for me and added
[00:07:40.080 --> 00:07:45.120]   these, uh, various pictures of me, um, using his service.
[00:07:45.120 --> 00:07:46.720]   So here's a fun service you can try.
[00:07:47.080 --> 00:07:54.400]   Um, uh, one crazy one he tried was me as a dwarf, which I got to say
[00:07:54.400 --> 00:07:55.880]   actually worked pretty well.
[00:07:55.880 --> 00:07:58.360]   This, this half looks like me, I reckon.
[00:07:58.360 --> 00:08:01.120]   And then the bottom bit is the dwarf version.
[00:08:01.120 --> 00:08:06.080]   Uh, so thank you, Alon and congratulations on your great progress since
[00:08:06.080 --> 00:08:07.840]   completing the first AI course.
[00:08:07.840 --> 00:08:11.200]   Um, uh, yeah, I love it.
[00:08:12.080 --> 00:08:22.640]   Um, so something that's a bit different about, uh, this compared to previous
[00:08:22.640 --> 00:08:29.720]   courses, a lot of previous courses is, um, uh, it's, this is no longer just
[00:08:29.720 --> 00:08:34.080]   a me thing, um, because this, um, is moving so quickly.
[00:08:34.080 --> 00:08:39.520]   I've needed to get a lot of help, um, to, to even vaguely get, get up to date
[00:08:39.520 --> 00:08:45.480]   and stay up to date, um, so everything I'll be showing you today, uh, is, is
[00:08:45.480 --> 00:08:50.520]   very heavily influenced by extremely high levels of input from these, um,
[00:08:50.520 --> 00:08:53.840]   amazing folks, all of whom are fast AI alumni.
[00:08:53.840 --> 00:09:02.040]   Um, so Jonathan Whittaker, who, um, I saw in our chat, um, is, was basically
[00:09:02.040 --> 00:09:08.440]   the first guy to, to create detailed educational material about stable
[00:09:08.440 --> 00:09:13.840]   diffusion and has been in the generative model space, uh, well, for a long
[00:09:13.840 --> 00:09:17.640]   time by staple diffusion standards, I guess.
[00:09:17.640 --> 00:09:26.520]   Um, so, uh, was seen, um, has been an extraordinary contributor to all things.
[00:09:26.520 --> 00:09:32.640]   Fast AI, um, uh, Pedro came to San Francisco for the last time.
[00:09:32.640 --> 00:09:39.320]   We did a part two course in 2019 and, um, uh, took what he learned there and made
[00:09:39.320 --> 00:09:43.600]   his amazing camera plus software dramatically better and had it highlighted
[00:09:43.600 --> 00:09:47.040]   by apple, um, for the extraordinary machine learning stuff added.
[00:09:47.040 --> 00:09:50.520]   And he's now at hugging face, working on the software that
[00:09:50.520 --> 00:09:52.040]   we'll be using a lot diffusers.
[00:09:52.040 --> 00:09:56.440]   And then to teach everybody in the forum, the fast AI community probably
[00:09:56.440 --> 00:10:03.040]   already knows, um, now at stability, uh, AI, um, working on stable diffusion,
[00:10:03.040 --> 00:10:07.720]   um, models, um, his expertise, particularly as in medical applications.
[00:10:07.720 --> 00:10:15.440]   Uh, so really, um, folks from all the key groups pretty much, um, around
[00:10:15.440 --> 00:10:20.720]   stable diffusion and stuff are, uh, are working on this together.
[00:10:20.720 --> 00:10:26.160]   And, um, you'll also find some of these folks have recorded additional
[00:10:26.160 --> 00:10:31.880]   videos, um, going into more detail about some of the areas, which you will find,
[00:10:31.880 --> 00:10:38.600]   um, on the, uh, on the course website.
[00:10:38.600 --> 00:10:46.280]   So make sure you go to cost@fast.ai, um, to get all the information, um,
[00:10:46.280 --> 00:10:54.160]   about, you know, all the materials, um, that, that, that you need to take
[00:10:54.160 --> 00:10:55.520]   full advantage of this.
[00:10:55.800 --> 00:11:05.520]   So every lesson, um, has links to notebooks and to details and so forth.
[00:11:05.520 --> 00:11:11.600]   Um, if you want to go even deeper, um, head over to forums.fast.ai
[00:11:11.600 --> 00:11:17.960]   into the part two 2022 category, um, hit on the about the course button.
[00:11:18.840 --> 00:11:29.400]   And you'll find that, uh, every lesson, uh, there's a chat, um, with even more stuff.
[00:11:29.400 --> 00:11:35.040]   So look at this carefully to see all the things that me and the community have
[00:11:35.040 --> 00:11:40.840]   provided to you to help you understand, um, this video, um, and also check
[00:11:40.840 --> 00:11:45.040]   out the questions, um, underneath and answers underneath to see what
[00:11:45.040 --> 00:11:45.840]   people have talked about.
[00:11:46.040 --> 00:11:47.640]   They can get a bit overwhelming.
[00:11:47.640 --> 00:11:54.640]   Um, so, um, once they get big enough, you'll see that there's a summarize
[00:11:54.640 --> 00:12:02.560]   button that you can, um, that you can click, um, uh, to kind of see just the
[00:12:02.560 --> 00:12:06.040]   most liked parts, um, so that can be very helpful.
[00:12:06.040 --> 00:12:08.040]   Um, okay.
[00:12:08.040 --> 00:12:10.840]   So they're all important resources, I think, to get the most, to
[00:12:10.840 --> 00:12:13.240]   get the most out of, um, this course.
[00:12:15.680 --> 00:12:18.200]   Now, um, compute.
[00:12:18.200 --> 00:12:24.040]   So, um, completing part two requires quite a bit more compute than part one.
[00:12:24.040 --> 00:12:29.320]   Um, compute options are changing rapidly.
[00:12:29.320 --> 00:12:32.120]   And to be honest, the main reason for that is because of the huge
[00:12:32.120 --> 00:12:34.080]   popularity of stable diffusion.
[00:12:34.080 --> 00:12:38.040]   Um, everybody's taken to using Colab for stable diffusion.
[00:12:38.040 --> 00:12:42.040]   Um, and Colab's response has been to start charging by the
[00:12:42.040 --> 00:12:45.000]   hour, um, for most usage.
[00:12:45.320 --> 00:12:48.240]   So you may well find if you're a Colab user, we still love Colab.
[00:12:48.240 --> 00:12:54.840]   Um, um, you may find that, you know, you run out of, uh, they start not giving
[00:12:54.840 --> 00:12:56.080]   you decent GPUs anymore.
[00:12:56.080 --> 00:13:01.640]   Um, and if you want to then upgrade, they limit quite a lot.
[00:13:01.640 --> 00:13:03.600]   How many hours you can use.
[00:13:03.600 --> 00:13:06.640]   So at the moment, yeah, still try Colab.
[00:13:06.640 --> 00:13:08.400]   They're, they're, they're pretty good.
[00:13:08.400 --> 00:13:10.240]   I mean, for free, you get some decent stuff.
[00:13:10.640 --> 00:13:15.760]   Um, but, um, I would strongly suggest trying out also paper space gradient.
[00:13:15.760 --> 00:13:22.000]   You can pay like $9 a month to actually get some pretty good
[00:13:22.000 --> 00:13:26.320]   GPUs there at the moment, um, or pay them a bit more to get even better ones.
[00:13:26.320 --> 00:13:30.120]   Um, again, but the thing is this is all going to change a lot.
[00:13:30.120 --> 00:13:30.480]   I don't know.
[00:13:30.480 --> 00:13:33.920]   Like maybe people will, will make paper space gradient
[00:13:33.920 --> 00:13:35.280]   have to change their pricing too.
[00:13:35.280 --> 00:13:36.080]   I don't know.
[00:13:36.080 --> 00:13:39.640]   So, um, check course.fast.ai to find out what our current
[00:13:39.640 --> 00:13:40.680]   recommendations are.
[00:13:40.680 --> 00:13:45.960]   Um, now, um, Lambda labs and Java slabs are also both good options.
[00:13:45.960 --> 00:13:51.600]   Java was created by a alum of the course and has some, um, just really
[00:13:51.600 --> 00:13:53.880]   fantastic options at a very reasonable price.
[00:13:53.880 --> 00:13:59.200]   Um, and a lot of fast AI students use them and love them.
[00:13:59.200 --> 00:14:07.600]   Um, and also check out Lambda labs who are the most recent, um, provider on this page.
[00:14:07.880 --> 00:14:13.400]   Um, and they are, um, rapidly adding new features, but the reason I particularly
[00:14:13.400 --> 00:14:17.480]   wanted to mention them is at least as I say this, which they say is early
[00:14:17.480 --> 00:14:24.560]   October, 2022, they're the cheapest provider of kind of big GPUs that you
[00:14:24.560 --> 00:14:28.280]   might want to use to, to run like serious models.
[00:14:28.280 --> 00:14:34.080]   Um, so they're absolutely, yeah, well worth checking out.
[00:14:34.080 --> 00:14:36.640]   But as I say, this could all have changed by the time you watch this.
[00:14:36.640 --> 00:14:38.280]   So go and check out course.fast.ai.
[00:14:38.280 --> 00:14:45.560]   Also, um, at the moment, like, uh, like 2020, 2020, 2022 GPU prices have come
[00:14:45.560 --> 00:14:51.360]   down a lot and you may well want to consider buying your own machine at this point.
[00:14:51.360 --> 00:14:58.200]   Um, okay.
[00:14:58.200 --> 00:15:02.200]   So what we're now going to do is, um, jump into the notebooks.
[00:15:03.920 --> 00:15:10.240]   And so there's a, uh, repo that we've linked to called diffusion NBS.
[00:15:10.240 --> 00:15:15.720]   Um, which isn't kind of the main course notebooks.
[00:15:15.720 --> 00:15:17.440]   It's not the, from the foundation's notes books.
[00:15:17.440 --> 00:15:20.920]   It's just a couple of notebooks that you might want to play with a bit of
[00:15:20.920 --> 00:15:22.560]   fun stuff to try out.
[00:15:22.560 --> 00:15:27.760]   One of the interesting things here is, um, uh, Jonathan Brittaker, um, who
[00:15:27.760 --> 00:15:28.960]   I tend to call Jono.
[00:15:28.960 --> 00:15:31.840]   So if I say Jono, that's who I'm referring to has kind of this really
[00:15:31.840 --> 00:15:36.200]   interesting thing called suggested tools.md, which hopefully he'll keep up to date.
[00:15:36.200 --> 00:15:41.280]   So even if you come here later, um, this will still be up to date because he knows
[00:15:41.280 --> 00:15:47.640]   so much about this area, he's been able to pull out some of the best stuff out
[00:15:47.640 --> 00:15:49.560]   there for just starting to play.
[00:15:49.560 --> 00:15:55.760]   And, and I think it's actually important to play, um, because that way you can
[00:15:55.760 --> 00:15:59.280]   really understand what the capabilities are and what the constraints are.
[00:15:59.560 --> 00:16:02.360]   So then you can think about like, well, what could you do with that?
[00:16:02.360 --> 00:16:07.240]   Um, and also like, what kind of research opportunities might there be?
[00:16:07.240 --> 00:16:10.160]   So I'd strongly suggest trying out these things.
[00:16:10.160 --> 00:16:19.080]   The community on the whole has moved towards, um, um, making things
[00:16:19.080 --> 00:16:20.920]   available as Colab notebooks.
[00:16:20.920 --> 00:16:25.400]   So if I click, for example, on this one, the forum.
[00:16:25.400 --> 00:16:33.800]   Um, and they often have this kind of hacker aesthetic, um, around them,
[00:16:33.800 --> 00:16:35.240]   which is kind of fun.
[00:16:35.240 --> 00:16:45.320]   Um, so what happens is like, just they add lots and lots of features and you can
[00:16:45.320 --> 00:16:49.840]   basically just fill in this stuff to try, to try things.
[00:16:49.840 --> 00:16:53.080]   Um, and they often have a few examples.
[00:16:54.440 --> 00:16:59.160]   And so you can hit up the runtime and say, change runtime type to make sure it says
[00:16:59.160 --> 00:17:08.160]   GPU, and you can say what kind of GPU, um, and, um, and start running things.
[00:17:08.160 --> 00:17:13.840]   Now, um, a lot of the folks who use this stuff honestly have no idea what any of
[00:17:13.840 --> 00:17:17.200]   these things mean now, by the end of the course, you'll know what all of these
[00:17:17.200 --> 00:17:24.880]   things mean, um, pretty much, um, and that will help you to make great outputs
[00:17:24.880 --> 00:17:30.000]   from stuff like this, but you can create great outputs just using more of an
[00:17:30.000 --> 00:17:31.000]   artisanal approach.
[00:17:31.000 --> 00:17:36.800]   There's lots of information online about, you know, what, what kinds
[00:17:36.800 --> 00:17:37.760]   of things could you try?
[00:17:37.760 --> 00:17:41.280]   Um, so anyway, check out this stuff, um, from, from Jono.
[00:17:41.760 --> 00:17:47.560]   Um, and then he also links to this fantastic resource from Pharma psychotic,
[00:17:47.560 --> 00:17:54.040]   which is a rather overwhelming list of things to play with.
[00:17:54.040 --> 00:17:59.160]   Uh, now again, you know, maybe by the time you watch this, this is all changed.
[00:17:59.160 --> 00:18:03.040]   Um, but I just wanted you to know these kinds of things are out there and they're
[00:18:03.040 --> 00:18:06.600]   basically like ready to go applications that you can start playing with.
[00:18:08.000 --> 00:18:16.440]   So play a lot. Um, what you'll find is that, um, most of them, at least at the
[00:18:16.440 --> 00:18:20.960]   moment, expect you to input some text to say what you want to create a picture of.
[00:18:20.960 --> 00:18:27.880]   Um, it turns out that as we'll learn, we'll learn in detail why, um, the text
[00:18:27.880 --> 00:18:33.280]   you pick, it's not very easy to know what to write and, and that gives kind of
[00:18:33.280 --> 00:18:34.480]   interesting results.
[00:18:35.040 --> 00:18:41.120]   Um, at the moment, it's quite an artisanal thing to understand what to write.
[00:18:41.120 --> 00:18:44.560]   And the best way to learn what to write, it's called the prompt.
[00:18:44.560 --> 00:18:48.080]   The best way to learn about prompts is to look at other people's prompts in their
[00:18:48.080 --> 00:18:48.680]   outputs.
[00:18:48.680 --> 00:18:55.560]   So at the moment, perhaps the best way to do that is a lexica, which has lots and
[00:18:55.560 --> 00:19:03.360]   lots of really interesting, um, artworks and so AI artworks.
[00:19:03.600 --> 00:19:06.720]   And so you can click on one and see what prompt was used.
[00:19:06.720 --> 00:19:14.200]   And so you'll see here that generally you start with, um, what do you want to take
[00:19:14.200 --> 00:19:17.280]   a, make a picture of what's the style.
[00:19:17.280 --> 00:19:25.960]   Um, and then the trick is to add a bunch of like artists names or places that they
[00:19:25.960 --> 00:19:34.640]   put art so that the algorithm will tend to create a piece which matches art, you
[00:19:34.640 --> 00:19:37.960]   know, that tends to have the, these kinds of words in their captions.
[00:19:37.960 --> 00:19:46.120]   Um, so there's a really useful trick to kind of get good at this.
[00:19:46.120 --> 00:19:48.320]   And so you can even search for things.
[00:19:48.320 --> 00:19:50.360]   So I don't know if they have Teddy bears.
[00:19:50.360 --> 00:19:51.320]   Let's try.
[00:19:51.320 --> 00:19:54.200]   Um, there we go.
[00:19:54.520 --> 00:20:00.280]   So if there's a kind of like a property, not that one, um, that's a pretty good
[00:20:00.280 --> 00:20:01.200]   Teddy bear image.
[00:20:01.200 --> 00:20:07.560]   So you can kind of get some sense of how to create nice Teddy bear images.
[00:20:07.560 --> 00:20:10.800]   That's so cute.
[00:20:10.800 --> 00:20:13.920]   I know what I'm going to be showing my daughter tomorrow.
[00:20:13.920 --> 00:20:19.960]   Um, and you can see they often tend to have similar kinds of stuff to try to
[00:20:19.960 --> 00:20:21.840]   encourage the algorithm to give good outputs.
[00:20:22.200 --> 00:20:22.520]   Okay.
[00:20:22.520 --> 00:20:27.120]   So by the end of this course, you'll understand why this is happening.
[00:20:27.120 --> 00:20:30.640]   Why these kinds of app, you know, prompts create these kind of outputs and also how
[00:20:30.640 --> 00:20:33.600]   you can go beyond just creating prompts.
[00:20:33.600 --> 00:20:42.080]   Um, to actually, um, to actually, um, building really innovative new
[00:20:42.080 --> 00:20:43.760]   things with new data types.
[00:20:43.760 --> 00:20:49.200]   Um, okay.
[00:20:51.360 --> 00:20:54.840]   So let's take a look at the diffusion and bees repo.
[00:20:54.840 --> 00:20:57.360]   The first thing we'll look at is a stable diffusion.
[00:20:57.360 --> 00:21:06.000]   So a couple of options here, you can, um, you can, uh, clone this repo, um, which
[00:21:06.000 --> 00:21:11.120]   is, uh, linked from both the cost of fast at AI and from the forum and run it on like
[00:21:11.120 --> 00:21:15.640]   pepper space gradient or your own machine or whatever, uh, or you can head over to
[00:21:15.640 --> 00:21:22.960]   CoLab and you can just say, get hub, right?
[00:21:22.960 --> 00:21:28.760]   And then you can paste in, um, the, the link to it directly from get hub.
[00:21:28.760 --> 00:21:33.000]   Okay.
[00:21:33.000 --> 00:21:43.040]   So, um, I'm running it on my own machine and, um, this notebook is, um, largely
[00:21:43.040 --> 00:21:48.480]   been built thanks to the wonderful folks at hugging face and hugging face have a
[00:21:48.480 --> 00:21:51.480]   library called, um, diffusers.
[00:21:51.480 --> 00:21:56.120]   So any of you that have done part one of the course, we'll be very familiar with
[00:21:56.120 --> 00:21:56.760]   hugging face.
[00:21:56.760 --> 00:21:58.640]   We used a lot of their libraries in part one.
[00:21:58.640 --> 00:22:06.680]   Um, diffusers is their library for doing stable diffusion and stuff like stable
[00:22:06.680 --> 00:22:16.000]   diffusion, um, at the moment, you know, these things are changing a lot, but at
[00:22:16.000 --> 00:22:20.360]   the moment, this is our recommended, um, library for doing this stuff.
[00:22:20.360 --> 00:22:21.960]   And it's what we'll be using in this course.
[00:22:21.960 --> 00:22:25.920]   Um, maybe by the time you watch this, there'll be lots of other options.
[00:22:25.920 --> 00:22:30.200]   So again, keep an eye on course.fast at AI, um, in general hugging face have done
[00:22:30.200 --> 00:22:35.320]   a really good job of, um, being at and staying at the kind of head of the pack
[00:22:35.360 --> 00:22:38.240]   around models in general for deep learning.
[00:22:38.240 --> 00:22:44.640]   So, um, that would be, you know, not surprising if they continue to be the
[00:22:44.640 --> 00:22:46.080]   best option for quite a while.
[00:22:46.080 --> 00:22:50.040]   Um, but the basic idea of any library is going to look pretty similar.
[00:22:50.040 --> 00:22:58.000]   Um, so, uh, to get started playing with this, um, you will need to, um,
[00:22:58.000 --> 00:23:00.800]   log in to hugging face.
[00:23:01.360 --> 00:23:07.280]   Um, so if you've got a hugging face, you can create a, um, uh, username
[00:23:07.280 --> 00:23:09.480]   there and a password and then login.
[00:23:09.480 --> 00:23:11.840]   Once you've done it once, it'll save it on your computer.
[00:23:11.840 --> 00:23:12.920]   So you wouldn't have to log in again.
[00:23:12.920 --> 00:23:22.680]   Um, and the thing we're going to be working with is, um, pipelines and in
[00:23:22.680 --> 00:23:26.120]   particular, the stable diffusion pipeline, again, you know, they might be using
[00:23:26.120 --> 00:23:32.200]   different pipelines by the time that, um, uh, you, um, you watch this, um, but
[00:23:32.200 --> 00:23:38.800]   the basic idea of pipeline is, um, quite similar to what we call a learner in
[00:23:38.800 --> 00:23:42.600]   fast AI, which is it's got a whole bunch of things in it, you know, a bunch of
[00:23:42.600 --> 00:23:48.320]   kind of processing and models and inference, all, all happening automatically.
[00:23:48.320 --> 00:23:53.840]   Uh, and just like you can save a pipeline in faster, sorry, save a learner in fast
[00:23:53.840 --> 00:23:57.880]   AI, you can save a pipeline, um, in diffusers.
[00:23:57.880 --> 00:24:02.960]   Um, now something that you can do in, um, all pretty much all hugging face
[00:24:02.960 --> 00:24:07.720]   libraries that you can't do in fast AI is you can then save a pipeline or
[00:24:07.720 --> 00:24:12.120]   whatever backup, um, into the cloud onto hugging face, they call it the hub.
[00:24:12.120 --> 00:24:18.400]   And so then if we say from pre-trained, um, it's, um, a lot like how we create
[00:24:18.400 --> 00:24:23.560]   pre-trained learners in fast AI, but the thing you put here is actually, um, if
[00:24:23.560 --> 00:24:27.520]   it's not a local path, it's a hugging face, uh, repo.
[00:24:27.520 --> 00:24:41.040]   So if we search hugging face for this, and you can see this is what it's going
[00:24:41.040 --> 00:24:47.160]   to download and you can actually save your own pipelines up to the hub for
[00:24:47.160 --> 00:24:48.040]   other people to use.
[00:24:48.040 --> 00:24:51.280]   So I think this is a very nice, uh, feature that helps, you know, the
[00:24:51.280 --> 00:24:53.560]   community build stuff.
[00:24:53.560 --> 00:24:58.000]   So this is actually going to, the first time you run this, it's going to download
[00:24:58.000 --> 00:25:00.400]   many gigabytes of data from the internet.
[00:25:00.400 --> 00:25:05.280]   Um, this is one of the slight challenges with using this on, on Colab is every
[00:25:05.280 --> 00:25:08.160]   time you use Colab, everything gets thrown away and start from scratch.
[00:25:08.160 --> 00:25:11.040]   So it'll all have to be downloaded every time you use Colab.
[00:25:11.040 --> 00:25:15.480]   Um, if you use something like, um, paper space or particularly actually
[00:25:15.480 --> 00:25:19.360]   Lambda Labs, um, it's all going to be saved for you.
[00:25:20.920 --> 00:25:25.200]   Um, so once you've, um, downloaded all this, um, it's going to be, it's going to
[00:25:25.200 --> 00:25:31.240]   save a whole bunch of stuff, um, into your dot cache in your home directory.
[00:25:31.240 --> 00:25:33.240]   So that's where hugging face puts things.
[00:25:33.240 --> 00:25:42.120]   So now that we have a pipeline called pipe, um, we can now trade it as if it's
[00:25:42.120 --> 00:25:46.880]   a function, which is pretty common for like PyTorch stuff and fast.ai stuff.
[00:25:46.880 --> 00:25:50.400]   You should be very familiar with this, hopefully, and you can pass it a prompt.
[00:25:51.400 --> 00:25:55.640]   And so this is just some text and that's going to return some images.
[00:25:55.640 --> 00:25:58.400]   Since we're only passing one prompt, it's going to return one image.
[00:25:58.400 --> 00:26:00.240]   So we'll just index into dot images.
[00:26:00.240 --> 00:26:06.880]   And when we run it, it takes, uh, you know, maybe 30 seconds or so and returns
[00:26:06.880 --> 00:26:09.400]   a photograph of an astronaut riding a horse.
[00:26:11.520 --> 00:26:20.160]   Um, every time you call, um, a pipeline using the same random seed,
[00:26:20.160 --> 00:26:21.840]   you'll get the same image.
[00:26:21.840 --> 00:26:26.520]   Um, you can set them at the random seed manually.
[00:26:26.520 --> 00:26:29.880]   And so you could send to somebody else and say, Oh, this is a really cool
[00:26:29.880 --> 00:26:31.000]   astronaut riding a horse.
[00:26:31.000 --> 00:26:37.840]   I found, uh, try manual seed one Oh two four, and you'll get back this particular
[00:26:37.840 --> 00:26:44.080]   astronaut riding a horse, um, so that's how you can, like, that's the most basic
[00:26:44.080 --> 00:26:48.640]   way to get started, um, running on CoLab or on your own machine.
[00:26:48.640 --> 00:26:50.640]   You can start creating images.
[00:26:50.640 --> 00:26:55.800]   Um, it takes, as I said, it takes 30 seconds or so.
[00:26:55.800 --> 00:26:57.960]   And in this case, it took 51 steps.
[00:26:57.960 --> 00:27:02.680]   Um, what it's doing, this is a bit very different to like what we're
[00:27:02.680 --> 00:27:08.680]   used to with inference in fast AI, uh, where it's, it's one step to, to
[00:27:08.680 --> 00:27:13.560]   classify something, for example, what it's doing in these 51 steps is it's
[00:27:13.560 --> 00:27:17.600]   starting with like, um, so this is actually an example that we're going to
[00:27:17.600 --> 00:27:22.880]   create ourselves ourselves, um, in the course of creating, um, handwritten
[00:27:22.880 --> 00:27:26.520]   digits, and this is actually an image from a later notebook we'll be building.
[00:27:26.520 --> 00:27:31.280]   Well, we basically starts with random noise and each step, it tries to make
[00:27:31.280 --> 00:27:35.360]   it slightly less noisy and slightly more like the thing we want.
[00:27:35.360 --> 00:27:39.760]   And so going down here is showing all the steps to create the first
[00:27:39.760 --> 00:27:44.160]   four, for example, or here to create the first one.
[00:27:44.160 --> 00:27:48.760]   And if you look closely, you can kind of see in this noise, there is
[00:27:48.760 --> 00:27:50.240]   something that looks a bit like a one.
[00:27:50.240 --> 00:27:52.640]   And so it kind of decides to focus on that.
[00:27:52.640 --> 00:27:58.600]   And so that's how these diffusion models basically work.
[00:27:58.600 --> 00:28:10.360]   So remember, if you're having any trouble finding the materials, we're looking
[00:28:10.360 --> 00:28:18.080]   at to go to cost.fast.ai or go to the forum topic, um, uh, to see all the
[00:28:18.080 --> 00:28:20.920]   links, and this one is called diffusion dash nbs.
[00:28:20.920 --> 00:28:25.960]   And the notebook is called, you can see it at the top stable diffusion.
[00:28:26.600 --> 00:28:30.920]   Now, um, a question might be, well, why don't we just do it in, in one go?
[00:28:30.920 --> 00:28:38.400]   Um, and we can do it in one go, but if we try to do it in one go, um, it doesn't
[00:28:38.400 --> 00:28:39.400]   do a very good job.
[00:28:39.400 --> 00:28:47.680]   Uh, these models aren't, as I speak now in October, 2022, smart enough to do it in one
[00:28:47.680 --> 00:28:54.360]   go now, as I mentioned, um, at the start, the fact that I'm doing it in 51 steps
[00:28:54.360 --> 00:28:59.920]   here is, um, you know, hopelessly out of date, because as of yesterday, apparently
[00:28:59.920 --> 00:29:01.680]   we can now do it in three to four steps.
[00:29:01.680 --> 00:29:03.520]   I'm not sure if that code's available yet.
[00:29:03.520 --> 00:29:07.440]   Um, so by the time you see this, yeah, this might all be dramatically faster.
[00:29:07.440 --> 00:29:12.600]   Um, but as I'll be describing, understanding this basic concept, I'm pretty confident
[00:29:12.600 --> 00:29:13.760]   it's going to be very important.
[00:29:13.760 --> 00:29:15.960]   Like forever.
[00:29:15.960 --> 00:29:18.480]   Um, so we'll talk about that.
[00:29:18.760 --> 00:29:25.600]   Um, so if we do 16 steps instead of 51 steps, you know, it looks a bit more like it, um, but
[00:29:25.600 --> 00:29:26.320]   it's still not amazing.
[00:29:26.320 --> 00:29:30.240]   Um, okay.
[00:29:30.240 --> 00:29:36.120]   So that's how you can kind of get started and I'll show you a few things that you can
[00:29:36.120 --> 00:29:41.040]   tune, um, and, you know, I should remind you that, you know, when I, most of the stuff
[00:29:41.040 --> 00:29:46.240]   I'm showing you in this was built by Pedro Cuenca and the other folks at, um, Hugging
[00:29:46.240 --> 00:29:49.680]   Face, um, so huge thanks to them.
[00:29:49.680 --> 00:29:55.720]   There's no way I could have been as up to speed, up to speed with all this, um, detail
[00:29:55.720 --> 00:29:57.120]   without their help.
[00:29:57.120 --> 00:30:02.760]   Um, they built this library diffusers and, um, um, they've done a fantastic job of
[00:30:02.760 --> 00:30:04.600]   helping display what you can do with it.
[00:30:04.600 --> 00:30:07.000]   So let's look at an example of what you can do with it.
[00:30:07.000 --> 00:30:11.320]   We're just going to quickly define a little function here to create a grid of images.
[00:30:11.320 --> 00:30:13.120]   Um, the details don't matter.
[00:30:13.640 --> 00:30:20.600]   Um, but what we, uh, do want to show here is you can, um, take your prompt, which was
[00:30:20.600 --> 00:30:24.520]   an astronaut riding a horse and, uh, just create four copies of it.
[00:30:24.520 --> 00:30:25.760]   Okay.
[00:30:25.760 --> 00:30:30.560]   So times when applied to a list, simply copies the list that many times.
[00:30:30.560 --> 00:30:34.080]   So here's a list of the exact same prompt four times.
[00:30:34.080 --> 00:30:41.400]   Um, and then what we're going to do is we're going to pass to the pipeline the
[00:30:41.400 --> 00:30:44.680]   prompts, and we're going to use a different parameter now called guidance scale.
[00:30:44.680 --> 00:30:50.360]   Um, we're going to be learning about guidance scale, um, in detail, uh, later in
[00:30:50.360 --> 00:30:56.080]   the course, but basically what this does is it says, um, to what degree should we
[00:30:56.080 --> 00:31:04.520]   be, um, uh, kind of focusing on the specifics, uh, caption versus just
[00:31:04.520 --> 00:31:05.560]   creating an image.
[00:31:05.560 --> 00:31:09.880]   Um, so we're going to try a few different guidance scales about one, three, seven,
[00:31:09.880 --> 00:31:12.200]   14, generally seven and a half.
[00:31:12.200 --> 00:31:15.600]   I believe at this stage is the default that might have changed by the time you
[00:31:15.600 --> 00:31:19.640]   watch this, um, and so each row here is a different guidance scale.
[00:31:19.640 --> 00:31:24.760]   So you can see in the first row, it hasn't really listened to us very much at all.
[00:31:24.760 --> 00:31:28.920]   Um, uh, these are very weird looking things and they, none of them really look
[00:31:28.920 --> 00:31:36.920]   like astronauts riding a horse, um, at guidance scale of three, they look more
[00:31:36.920 --> 00:31:44.240]   like things riding horses that they might be astronaut ish and at 7.5, they certainly
[00:31:44.240 --> 00:31:50.560]   on the whole look like astronauts riding a horse, um, and at 14 or 15, they
[00:31:50.560 --> 00:31:53.240]   certainly look like that, but getting a little bit too abstract.
[00:31:53.240 --> 00:31:57.160]   Sometimes, um, I have a pretty strong feeling there are some slight problems
[00:31:57.160 --> 00:32:02.640]   with actually how this is coded or actually how the algorithm works, which I
[00:32:02.640 --> 00:32:04.040]   will be looking at during this course.
[00:32:04.040 --> 00:32:06.960]   So maybe by the time you see this, some of these will be looking a bit better.
[00:32:06.960 --> 00:32:12.520]   Um, uh, I think basically something that's happening here is it's actually kind of
[00:32:12.520 --> 00:32:19.280]   over, uh, over jumping a bit too far during these high ones anyway.
[00:32:19.280 --> 00:32:25.040]   So the basic idea of what it's doing here is, um, this guidance is it's basically
[00:32:25.040 --> 00:32:30.600]   actually for every single, um, prompt it's creating, um, creating two versions.
[00:32:31.240 --> 00:32:38.080]   Um, one version of the image with the prompt and astronaut riding a horse and one
[00:32:38.080 --> 00:32:41.120]   version of the image with no prompt.
[00:32:41.120 --> 00:32:42.920]   So it's just some random thing.
[00:32:42.920 --> 00:32:46.720]   And then it takes the average basically of those two things.
[00:32:46.720 --> 00:32:50.760]   Um, and that's how, that's what guidance scale does.
[00:32:50.760 --> 00:32:55.000]   And, uh, you can kind of think of the guidance scale as being a bit like a
[00:32:55.000 --> 00:32:56.800]   number that's used to weight the average.
[00:32:58.240 --> 00:33:00.280]   Um, there's something very similar.
[00:33:00.280 --> 00:33:06.640]   You can do, um, where again, you create, um, get the model to create two images,
[00:33:06.640 --> 00:33:11.960]   but rather than taking the average, you can ask it to effectively subtract one
[00:33:11.960 --> 00:33:12.640]   from the other.
[00:33:12.640 --> 00:33:18.440]   So, um, here's something that Pedro did, um, of, uh, using the prompt a
[00:33:18.440 --> 00:33:20.280]   Labrador and the style of the mirror.
[00:33:20.280 --> 00:33:27.800]   And then he said, well, what if we then subtract something which is.
[00:33:28.400 --> 00:33:31.240]   Just the model for the caption blue.
[00:33:31.240 --> 00:33:36.400]   And, uh, you can pass in this thing, negative prompt to diffusers.
[00:33:36.400 --> 00:33:40.360]   And what that will do is it will take the prompt, which in this case is
[00:33:40.360 --> 00:33:45.440]   Labrador in the style of familiar and create a second image effectively, which
[00:33:45.440 --> 00:33:49.680]   is just responding to the prompt blue and effectively subtract one from the other.
[00:33:49.680 --> 00:33:52.280]   The details are slightly different to that, but that's the basic idea.
[00:33:52.840 --> 00:33:59.320]   Um, and that way we get a non blue, um, Labrador in the style of them yet.
[00:33:59.320 --> 00:34:06.320]   So, uh, yeah, this is the basic, um, kind of idea of how to use negative prompt
[00:34:06.320 --> 00:34:07.200]   and you can play with that.
[00:34:07.200 --> 00:34:07.800]   Good fun.
[00:34:07.800 --> 00:34:17.360]   Um, here's something else you can play with is you don't have to, um, uh, just
[00:34:17.360 --> 00:34:20.720]   to pass in text, uh, you can actually pass in images.
[00:34:21.200 --> 00:34:22.840]   So for this, you'll need a different pipeline.
[00:34:22.840 --> 00:34:25.160]   You'll need an image to image pipeline.
[00:34:25.160 --> 00:34:32.840]   And with the image to image pipeline, you can grab a rather sketchy looking sketch.
[00:34:32.840 --> 00:34:39.840]   Um, and you can then, uh, pass to this.
[00:34:40.520 --> 00:34:52.480]   I to I image to image pipeline, the, um, initial image to start with.
[00:34:52.480 --> 00:35:00.920]   Um, and basically what this is going to do is rather than starting diffusion
[00:35:00.920 --> 00:35:11.080]   process with random noise, it's going to basically start it with, um, a noisy
[00:35:11.080 --> 00:35:12.560]   version of this drawing.
[00:35:12.560 --> 00:35:19.080]   And so then it's going to try to create something that matches this
[00:35:19.080 --> 00:35:27.080]   caption and also like follows this kind of guiding starting point.
[00:35:27.720 --> 00:35:34.320]   And so as a result, you get things that look quite a lot better than the
[00:35:34.320 --> 00:35:37.720]   original drawing, but you can see that the composition is the same.
[00:35:37.720 --> 00:35:45.120]   And so using this approach, you can, um, you know, construct things that match
[00:35:45.120 --> 00:35:47.440]   the particular kind of composition you're looking for.
[00:35:47.440 --> 00:35:52.920]   Um, so I think that's quite a nifty approach.
[00:35:53.160 --> 00:35:59.120]   And so here, this parameter strength is saying, um, to what degree do you want to
[00:35:59.120 --> 00:36:04.400]   really, um, create something that looks like this, um, or to what degree do you
[00:36:04.400 --> 00:36:09.320]   want the model to be able to, you know, try out different things a bit.
[00:36:09.320 --> 00:36:12.240]   Now here's where things get interesting.
[00:36:12.240 --> 00:36:14.640]   And this is the kind of stuff you're not going to be able to do at the moment with
[00:36:14.640 --> 00:36:18.320]   just the basic, uh, gooeys and stuff, but you can, if you really know what you're
[00:36:18.320 --> 00:36:23.040]   doing, what we could do now is we could take these output images and we could
[00:36:23.040 --> 00:36:24.400]   say, Oh, this one's nice.
[00:36:24.400 --> 00:36:26.960]   Uh, sorry, this one, this one's nice.
[00:36:26.960 --> 00:36:34.280]   Um, let's make this the initial image and now we'll say, let's do an oil painting
[00:36:34.280 --> 00:36:40.720]   of by van Gogh and pass in the same thing here and the strength of one.
[00:36:40.720 --> 00:36:46.720]   And actually that pretty much worked.
[00:36:46.720 --> 00:36:50.960]   And I think that's, um, absolutely fascinating, right?
[00:36:50.960 --> 00:36:58.400]   Because this is something I haven't seen before, um, which, um, which, which Pedro
[00:36:58.400 --> 00:37:06.000]   put together this week, um, and it's combining simple Python code together.
[00:37:06.000 --> 00:37:09.120]   And so you can play with that.
[00:37:09.120 --> 00:37:15.080]   Um, something else you can do, which this one's actually example came from the folks
[00:37:15.080 --> 00:37:19.640]   at Lambda Labs is, and we won't be going into this in detail right now, because
[00:37:20.080 --> 00:37:24.920]   this is like basically exactly like what we've done a thousand times in fast AI is
[00:37:24.920 --> 00:37:30.920]   you can take the models in that pipeline and you can pass it, um, your own
[00:37:30.920 --> 00:37:33.760]   images, um, and your own captions.
[00:37:33.760 --> 00:37:44.800]   And so what happened here is, um, Oh, I hate these things go away.
[00:37:44.800 --> 00:37:47.800]   Nevermind.
[00:37:47.800 --> 00:37:49.440]   Um, oh, here we are at this one.
[00:37:50.080 --> 00:37:58.520]   Um, so, um, um, what these folks did, I think this was, uh, Justin, if I
[00:37:58.520 --> 00:37:59.240]   remember correctly, yeah.
[00:37:59.240 --> 00:38:05.840]   Uh, so what Justin at Lambda did was he, um, created a really cool dataset by
[00:38:05.840 --> 00:38:13.440]   going to, um, uh, grab a Pokemon dataset of images, um, which had almost a
[00:38:13.440 --> 00:38:16.920]   thousand images of Pokemon, and then this is really neat.
[00:38:17.120 --> 00:38:21.480]   He then used an imaging captioning image captioning model model to automatically
[00:38:21.480 --> 00:38:27.640]   generate captions for each of those image images, and then he fine tuned the stable
[00:38:27.640 --> 00:38:30.880]   diffusion model using those imaging caption pairs.
[00:38:30.880 --> 00:38:38.000]   Um, so here's an example of one of the captions and one of the images, um, and
[00:38:38.000 --> 00:38:45.960]   then took that fine tuned model and past it prompts like girl with a girl, girl
[00:38:45.960 --> 00:38:53.320]   with a pale earring and cute Obama creature and got back these Totoro these
[00:38:53.320 --> 00:39:05.560]   oopsie daisy, um, and got back these, um, super nifty edges that now are
[00:39:05.560 --> 00:39:11.400]   reflecting the fine tuning dataset that he used, um, and also responding to these
[00:39:11.400 --> 00:39:21.200]   prompts, um, here's another example of something you can do is fine tuning can
[00:39:21.200 --> 00:39:24.880]   take quite a bit of data and quite a bit of time, um, but you can actually do some
[00:39:24.880 --> 00:39:26.240]   special kinds of fine tuning.
[00:39:26.240 --> 00:39:32.800]   Um, one that you can do is called textual inversion, uh, which is where we actually
[00:39:32.800 --> 00:39:35.680]   fine tune just a single embedding.
[00:39:37.080 --> 00:39:49.960]   Um, so for example, we can create, um, a new, um, embedding, um, where we're trying
[00:39:49.960 --> 00:39:53.160]   to make things that look like this.
[00:39:53.160 --> 00:39:59.400]   So what we can do is we can give this concept a name.
[00:39:59.400 --> 00:40:05.600]   Um, so here we're going to call it, um, Oh, I just lost it now.
[00:40:05.840 --> 00:40:10.960]   Um, what a color.
[00:40:10.960 --> 00:40:13.360]   Yeah.
[00:40:13.360 --> 00:40:16.080]   Uh, we're going to call it what a color portrait.
[00:40:16.080 --> 00:40:21.480]   Um, and so that's what the embedding name we're going to use is.
[00:40:21.480 --> 00:40:29.160]   Um, and we can then, um, basically add that token to the text model and then we
[00:40:29.160 --> 00:40:37.480]   can train the embeddings for this, um, so that they match the example pictures that
[00:40:37.480 --> 00:40:41.000]   we've seen, and this is going to be much faster because we're just training a
[00:40:41.000 --> 00:40:44.160]   single token for just in this case, four pictures.
[00:40:44.160 --> 00:40:55.080]   Um, and so when we do that, we can then say, for example, woman reading in the
[00:40:55.080 --> 00:40:59.760]   style of, and then pass in that token we just trained, and as you see, we'll get
[00:40:59.760 --> 00:41:09.760]   back a kind of novel, um, image, um, which I think is, yeah, pretty, um, pretty
[00:41:09.760 --> 00:41:10.400]   interesting.
[00:41:15.680 --> 00:41:26.160]   Um, another example, um, very similar to textual inversion, um, is, uh, something
[00:41:26.160 --> 00:41:32.080]   called dream booth, um, which, um, as mentioned here, what it does is it takes
[00:41:32.080 --> 00:41:36.480]   an existing token, but one that isn't used much, like say, SKS, nothing, almost
[00:41:36.480 --> 00:41:41.440]   nothing has SKS and fine tunes a model to bring that token, as it says here, close
[00:41:41.440 --> 00:41:42.600]   to the images we provide.
[00:41:42.960 --> 00:41:49.080]   And so what Pedro did here was he grabbed some pictures of me and said painting
[00:41:49.080 --> 00:41:55.440]   of SKS, so in this case, he's fine tuned this token to be Jeremy Howard photos in
[00:41:55.440 --> 00:41:58.120]   the style of Paul Signac, and there they are.
[00:41:58.120 --> 00:42:03.800]   And so the, um, example I showed earlier of the dwarf Jeremy Howard, um, that, that
[00:42:03.800 --> 00:42:06.240]   service streamer is actually using this dream booth.
[00:42:06.240 --> 00:42:11.960]   Um, so here's how you can try that, uh, yourself.
[00:42:11.960 --> 00:42:26.520]   Okay, so, um, that is part one of, um, of this lesson, which is the how to get
[00:42:26.520 --> 00:42:28.560]   started playing around with table diffusion.
[00:42:28.560 --> 00:42:35.640]   Um, in part two, we're going to talk about, um, what's actually going on here
[00:42:35.640 --> 00:42:37.200]   from a machine learning point of view.
[00:42:37.840 --> 00:42:44.080]   Uh, so we'll come back in, um, about seven minutes, um, to talk about that.
[00:42:44.080 --> 00:42:45.360]   All right.
[00:42:45.360 --> 00:42:46.880]   See you guys in about seven minutes.
[00:42:46.880 --> 00:42:51.960]   Okay.
[00:42:51.960 --> 00:42:53.120]   Welcome back folks.
[00:42:53.120 --> 00:43:00.120]   Um, uh, I just thought I'd share with you one more example actually of, um, textual
[00:43:00.120 --> 00:43:01.400]   inversion training.
[00:43:02.000 --> 00:43:08.080]   This is my daughter's Teddy tiny, who, as you can see is grossly misnamed.
[00:43:08.080 --> 00:43:18.080]   Um, and, um, Pedro and I tried to, yeah, create a, um, textual inversion, uh,
[00:43:18.080 --> 00:43:25.280]   version of tiny, and, uh, I was trying to get, um, tiny riding a horse.
[00:43:25.280 --> 00:43:31.120]   And it's interesting that when I tried to do that, this top row here, this is
[00:43:31.120 --> 00:43:36.760]   actually Pedro's, um, example when he ran it, um, this is showing the kind of steps
[00:43:36.760 --> 00:43:41.360]   as he was training of, uh, trying to use the caption tiny riding a horse.
[00:43:41.360 --> 00:43:45.840]   And as you can see, it never actually ended up generating tiny riding a horse.
[00:43:45.840 --> 00:43:50.240]   Instead, it ended up generating a horse that looks a little bit like tiny.
[00:43:50.240 --> 00:43:55.240]   Um, and then we're trying to get tiny sitting on a pink rug.
[00:43:55.240 --> 00:43:59.640]   And actually after a while, it did make some progress there.
[00:43:59.640 --> 00:44:02.320]   It doesn't quite look like tiny.
[00:44:02.320 --> 00:44:07.160]   Um, one thing Pedro did that was different to me was he started with the
[00:44:07.160 --> 00:44:10.120]   embedding of a person, um, in my one, I actually started with the embedding
[00:44:10.120 --> 00:44:11.480]   for Teddy and it worked a bit better.
[00:44:11.480 --> 00:44:18.120]   Um, but, uh, as you see, there are like problems and, um, we'll understand where
[00:44:18.120 --> 00:44:22.240]   those problems come from as we talk more about how this is trained, um, in
[00:44:22.240 --> 00:44:23.240]   the rest of this lesson.
[00:44:23.240 --> 00:44:30.960]   Okay.
[00:44:30.960 --> 00:44:36.400]   So I'm going to be, um, relying on some understanding of the basic idea of how,
[00:44:36.400 --> 00:44:41.120]   um, machine learning models are trained here.
[00:44:41.120 --> 00:44:46.080]   Um, so if, if you start getting a bit lost at any point, um, you might want to go back
[00:44:46.080 --> 00:44:50.560]   to part one, um, and then come back to this once you're unlost.
[00:44:51.160 --> 00:44:59.840]   Um, the way we're going to start, okay.
[00:44:59.840 --> 00:45:05.560]   So I need to explain, um, the way stable diffusion is normally explained, uh, is
[00:45:05.560 --> 00:45:08.480]   focused very much on a particular mathematical derivation.
[00:45:08.480 --> 00:45:14.480]   Um, we've been developing a totally new way of thinking about stable diffusion.
[00:45:14.480 --> 00:45:21.120]   And, um, I'm going to be teaching you that, um, it's, um, mathematically
[00:45:21.120 --> 00:45:26.800]   equivalent to the approach, which you'll see in other places, but what you'll
[00:45:26.800 --> 00:45:32.240]   realize and discover is that it's actually, um, um, conceptually much simpler.
[00:45:32.240 --> 00:45:37.960]   And also later in this course, we'll be showing you some, um, really innovative
[00:45:37.960 --> 00:45:41.440]   directions that this can take you when you think of it in this brand new way.
[00:45:41.440 --> 00:45:47.840]   So, uh, all of which is to say, um, when you listen to this and then you go and
[00:45:47.840 --> 00:45:51.480]   look at some blog posts and it looks like I'm saying something different.
[00:45:51.480 --> 00:45:53.160]   Um, just keep that in mind.
[00:45:53.160 --> 00:45:54.320]   I'm not saying something different.
[00:45:54.320 --> 00:45:57.880]   I'm expressing it in, um, a different way.
[00:45:57.880 --> 00:46:02.400]   Um, but it's, um, it's equally mathematically valid.
[00:46:02.400 --> 00:46:10.840]   Um, what I'm going to do is I'm going to start by saying, let's imagine that,
[00:46:10.840 --> 00:46:17.360]   um, let's imagine that we were trying to get something to generate something
[00:46:17.360 --> 00:46:19.960]   much simpler, which is to generate handwritten digits.
[00:46:19.960 --> 00:46:21.040]   Okay.
[00:46:21.040 --> 00:46:24.920]   Um, so it's like the stable diffusion for handwritten digits.
[00:46:24.920 --> 00:46:31.240]   Um, and we're going to start by assuming there's some like, um, API, some web
[00:46:31.240 --> 00:46:34.760]   service or whatever out there, who knows how it was made.
[00:46:34.760 --> 00:46:40.080]   Um, but what it does is something pretty nifty, which is that you can get an
[00:46:40.080 --> 00:46:49.280]   image of a handwritten digit and you can pass it over into this, this web API
[00:46:49.280 --> 00:46:52.920]   into this, you know, this rest endpoint or whatever, it's just a black
[00:46:52.920 --> 00:46:54.520]   box as far as we're concerned.
[00:46:54.520 --> 00:47:02.360]   And it's going to spit out the probability that this thing you
[00:47:02.360 --> 00:47:03.880]   passed in as a handwritten digit.
[00:47:03.880 --> 00:47:09.360]   So for this one, so let's say this image is called X one.
[00:47:09.840 --> 00:47:16.680]   The probability that X one is a handwritten digit, it might say is 0.9 eight.
[00:47:16.680 --> 00:47:24.120]   And so then you pass something else into this, um, magic API endpoint,
[00:47:24.120 --> 00:47:34.560]   which looks like this, you pass that in and that looks a little bit like an
[00:47:34.560 --> 00:47:39.520]   eight, I guess, but it might not be, you'd pass it into this API and you
[00:47:39.520 --> 00:47:41.440]   see what happens, this is X two.
[00:47:41.440 --> 00:47:53.280]   And it says the probability that X two is a digit is 0.4.
[00:47:57.560 --> 00:48:14.360]   Okay. Now we pass in our image X three into our magic API and it returns the
[00:48:14.360 --> 00:48:26.200]   probability that X three is a handwritten digit, pretty small.
[00:48:26.200 --> 00:48:34.920]   Okay, so, um, why is this interesting?
[00:48:34.920 --> 00:48:44.240]   Well, it turns out that if you have a function, you know, let's not call
[00:48:44.240 --> 00:48:55.560]   this an API, let's call this, let's call this, um, it's quite an error.
[00:48:55.760 --> 00:49:00.520]   It's quite an F some function, but it's like behind some web API, rest
[00:49:00.520 --> 00:49:04.920]   endpoint, whatever, if you have this function, we can actually use it to
[00:49:04.920 --> 00:49:06.880]   generate handwritten digits.
[00:49:06.880 --> 00:49:13.240]   Um, so that's something pretty magical.
[00:49:13.240 --> 00:49:15.000]   And we're going to see how on earth would you do that?
[00:49:15.000 --> 00:49:19.000]   If you have this function, which can take an image and tell you the
[00:49:19.000 --> 00:49:26.600]   probability that that is a handwritten digit, how could you use it to
[00:49:26.600 --> 00:49:29.400]   generate new images?
[00:49:29.400 --> 00:49:39.840]   Well, imagine you, um, wanted to turn this mess into something that
[00:49:39.840 --> 00:49:42.720]   did look like an image.
[00:49:42.720 --> 00:49:44.520]   Here's something you could do.
[00:49:45.520 --> 00:49:53.680]   You let's say that it's a 28 by 28, um, image, which is what?
[00:49:53.680 --> 00:50:02.760]   7 86, oopsie dozy 28 times 28 784.
[00:50:02.760 --> 00:50:14.560]   So 794 pixels, and we could pick one of these pixels and say, what
[00:50:14.560 --> 00:50:19.080]   if I increased this pixel to be a little bit darker and then we could pass
[00:50:19.080 --> 00:50:24.120]   that image through F and we could see what happens to the probability that
[00:50:24.120 --> 00:50:25.120]   it's a handwritten digit.
[00:50:25.120 --> 00:50:32.960]   So for a specific example, handwritten digits don't normally have any pixels
[00:50:32.960 --> 00:50:34.880]   that are black in the very bottom corners.
[00:50:34.880 --> 00:50:39.440]   So if we took this here and we said, what would happen if we made this a
[00:50:39.440 --> 00:50:44.640]   little bit lighter, right, and then we pass that exact image through here,
[00:50:44.640 --> 00:50:52.400]   the probability would probably go up a tiny bit, for example.
[00:50:52.400 --> 00:51:00.400]   So now we've got an image, which is slightly more like a handwritten
[00:51:00.400 --> 00:51:08.040]   digit than before, and also in digits, generally there are straight lines.
[00:51:08.360 --> 00:51:12.280]   So this pixel here probably makes sense for it to be darker.
[00:51:12.280 --> 00:51:18.000]   So if we made a slightly darker version of this pixel and sent it through here,
[00:51:18.000 --> 00:51:21.800]   that would also increase the probability a little bit.
[00:51:21.800 --> 00:51:29.520]   And so we could do that for every single pixel of the 28 by 28, one at a time,
[00:51:29.520 --> 00:51:33.360]   finding out which ones, if we make them a little bit lighter, make it more
[00:51:33.360 --> 00:51:36.640]   like a handwritten digit, which ones if we make it a little bit darker, make
[00:51:36.640 --> 00:51:44.360]   it more like a handwritten digit, what we've just done is we've calculated the
[00:51:44.360 --> 00:51:56.280]   gradient of the probability that X3 is a handwritten digit with respect to the
[00:51:56.280 --> 00:52:09.240]   pixels of X3. Now notice that I didn't say DPX3, DX3, which you might be familiar
[00:52:09.240 --> 00:52:15.680]   with from, from high school, and the reason for that is that we've done, we've
[00:52:15.680 --> 00:52:19.920]   calculated this for every single pixel.
[00:52:19.920 --> 00:52:26.120]   And so when you do it for lots of different inputs, you have to turn the D
[00:52:26.120 --> 00:52:29.840]   into a, this is called a Dell or a nabla.
[00:52:29.840 --> 00:52:31.960]   And it just means there's lots of values here.
[00:52:31.960 --> 00:52:39.200]   So this here contains lots of values, which is the, um, how much does the
[00:52:39.200 --> 00:52:45.720]   probability that X3 is a digit increase as we increase this pixel value?
[00:52:45.720 --> 00:52:49.320]   And as we increase this pixel value, as we increase this pixel value.
[00:52:49.800 --> 00:52:58.600]   So there's going to be for 28 by 28 inputs, there's going to be 784 pixels,
[00:52:58.600 --> 00:53:03.880]   which means that this thing here has 784 values.
[00:53:03.880 --> 00:53:07.040]   Okay.
[00:53:07.040 --> 00:53:08.760]   I totally messed up the notation there.
[00:53:08.760 --> 00:53:12.880]   I did think about going back and rerecording it, but then I thought, well,
[00:53:12.880 --> 00:53:17.480]   maybe instead as penance for my failure to get the notation right, I should
[00:53:17.480 --> 00:53:23.640]   instead record a little section describing the notation in more detail,
[00:53:23.640 --> 00:53:24.600]   both for myself.
[00:53:24.600 --> 00:53:28.880]   So I don't make it a mistake again and for the rest of you.
[00:53:28.880 --> 00:53:30.880]   So you understand exactly what's going on.
[00:53:30.880 --> 00:53:35.720]   I think it's actually pretty worthwhile because this notation does come up a lot.
[00:53:35.720 --> 00:53:41.840]   And I've been regularly butchering it in talks and notes for years now.
[00:53:41.840 --> 00:53:43.120]   So that's about time I got it right.
[00:53:45.000 --> 00:53:49.000]   So I should mention, I have absolutely no excuse for butchering the notation like I
[00:53:49.000 --> 00:53:56.440]   have on the basis that actually my friend Terrence and I wrote a, what is it?
[00:53:56.440 --> 00:54:00.680]   Like 30, 40 page tutorial on matrix calculus.
[00:54:00.680 --> 00:54:12.360]   And in that paper, he actually described everything I'm going to show you here.
[00:54:13.160 --> 00:54:20.160]   Having said that, you certainly don't need to read this rather lengthy tutorial.
[00:54:20.160 --> 00:54:23.760]   I'm going to explain the key stuff that actually I think it's worth knowing.
[00:54:23.760 --> 00:54:29.560]   And then you'll understand the mistake that I made during the lesson.
[00:54:29.560 --> 00:54:37.520]   Maybe let's start with some reminders from stuff that hopefully you did at high school.
[00:54:38.960 --> 00:54:47.280]   So let's create maybe a 2D version here and maybe a 3D version as well.
[00:54:47.280 --> 00:54:50.160]   Okay.
[00:54:50.160 --> 00:55:03.880]   So let's say, for example, we've got a quadratic that looks something like this.
[00:55:05.680 --> 00:55:11.240]   And we can say this is a equation such as y equals x squared.
[00:55:11.240 --> 00:55:23.240]   And we might endeavor to identify the slope kind of at some exact moment, like here.
[00:55:23.240 --> 00:55:30.120]   This slope at this exact moment here.
[00:55:31.160 --> 00:55:37.680]   So this thing is called the tangent and the slope at a tangent is the derivative of a function.
[00:55:37.680 --> 00:55:45.040]   And so the derivative, let me just try to make this look a bit more like a y than an x.
[00:55:45.040 --> 00:55:48.640]   Maybe I write it like this.
[00:55:48.640 --> 00:55:49.480]   Okay.
[00:55:49.480 --> 00:55:58.320]   And so the derivative of a function we can write in a few ways, but one way we can write it is like this, dy dx.
[00:55:59.120 --> 00:56:02.480]   And there are some rules we can use to calculate it analytically.
[00:56:02.480 --> 00:56:07.880]   And for squared, the rule is that it's 2x.
[00:56:07.880 --> 00:56:14.320]   You basically move the index out to the front to calculate its derivative.
[00:56:14.320 --> 00:56:24.440]   Another way of writing y equals x squared is we could write f of x equals x squared.
[00:56:24.440 --> 00:56:28.840]   And another way of writing the derivative is we could use this.
[00:56:29.840 --> 00:56:33.680]   For example, okay.
[00:56:33.680 --> 00:56:37.880]   So this is all stuff that hopefully you at least vaguely remember from high school.
[00:56:37.880 --> 00:56:45.880]   Now functions are not necessarily just of one variable.
[00:56:45.880 --> 00:56:56.640]   So here we've got x and y, but they could be of two variables, x and y and z say.
[00:56:57.280 --> 00:57:06.480]   And so we could have functions which, for example, could be like a 3D parabola with this kind of curvature, for instance.
[00:57:06.480 --> 00:57:13.520]   And so you can still find the derivative.
[00:57:13.520 --> 00:57:23.760]   But if you think about it, there's one way to kind of get a derivative would be exactly what we did before, which would we say as we change x, how does it change z?
[00:57:23.760 --> 00:57:26.880]   So that would be this slope again.
[00:57:27.880 --> 00:57:32.520]   But you could also have something that says as we change y, how would we change z?
[00:57:32.520 --> 00:57:37.240]   That would be like rotating this whole thing around by 90 degrees and then kind of doing the same thing.
[00:57:37.240 --> 00:57:52.000]   So it's a little bit trickier now because we've got a function of x and y.
[00:57:52.000 --> 00:58:08.000]   And so we could calculate the derivative of that with respect to just one of these things or both of these things or whatever.
[00:58:08.000 --> 00:58:15.720]   And so what we do here is we write this little thing.
[00:58:19.760 --> 00:58:33.920]   And so we can then say this is how our output z changes as we change one thing at a time, in this case, just x.
[00:58:33.920 --> 00:58:46.160]   There's another value which would be how does it change as we change just y, one thing at a time.
[00:58:48.120 --> 00:58:54.200]   And so those are two separate numbers we could calculate at some particular point on this surface.
[00:58:54.200 --> 00:58:57.520]   And so these things are called partial derivatives.
[00:58:57.520 --> 00:59:00.920]   What is partials?
[00:59:00.920 --> 00:59:12.320]   So in our case, we've got a 28 by 28 pixel image.
[00:59:14.640 --> 00:59:20.400]   Which might be, for example, the number 7 made of 28 by 28 pixels.
[00:59:20.400 --> 00:59:29.520]   So the pixels would be, you know, something like this.
[00:59:29.520 --> 00:59:38.400]   And then down here.
[00:59:38.400 --> 00:59:54.240]   And so in our case, we've got a situation where we're saying we've got some loss.
[00:59:54.240 --> 01:00:04.800]   And our loss is calculated at some function of both some weights in a neural network.
[01:00:06.760 --> 01:00:09.720]   As well as some pixel values.
[01:00:09.720 --> 01:00:14.400]   Such as the pixels in this number 7.
[01:00:14.400 --> 01:00:19.040]   And I guess, you know, actually the way it would work would be these would be shaded.
[01:00:19.040 --> 01:00:23.120]   This is more like what MNIST looks like, right?
[01:00:23.120 --> 01:00:28.200]   All right.
[01:00:28.200 --> 01:00:32.560]   So that's my pixels, aren't they terrible?
[01:00:33.040 --> 01:00:49.640]   Okay, so the loss would be, you know, calculated more specifically as the MSE mean squared error of the actual.
[01:00:49.640 --> 01:00:55.440]   The actual, I guess we should use, that's correct.
[01:00:56.280 --> 01:01:02.720]   The actual answer is like, which digit should it be?
[01:01:02.720 --> 01:01:17.560]   So let's call that Y minus the predicted Y, which is some neural network with some weights and our pixels.
[01:01:17.560 --> 01:01:21.280]   So that would be like delving in one layer deeply.
[01:01:21.680 --> 01:01:28.360]   But none of these details really matter too much of like, what's the loss function or the neural network or whatever.
[01:01:28.360 --> 01:01:30.280]   It's just some function that's calculating loss.
[01:01:30.280 --> 01:01:31.440]   So let's get rid of all that.
[01:01:31.440 --> 01:01:32.360]   Okay.
[01:01:32.360 --> 01:01:40.440]   And we can now say what happens as we change X.
[01:01:40.440 --> 01:01:43.120]   As we change X, what happens to the loss?
[01:01:43.120 --> 01:01:45.920]   Because we want to change X in a way that the loss goes down.
[01:01:46.320 --> 01:01:52.520]   But there isn't just one X there's, I write this as seven by seven.
[01:01:52.520 --> 01:01:56.720]   It's actually meant to be 28 by 28, but let's just do a simple seven by seven version here.
[01:01:56.720 --> 01:01:59.640]   We've got seven pixels by seven pixels.
[01:01:59.640 --> 01:02:03.120]   This is a super low resolution 49 pixel image.
[01:02:03.120 --> 01:02:07.880]   So there's 49 different things we could change.
[01:02:07.880 --> 01:02:10.880]   We could make each of these pixels darker or lighter.
[01:02:10.880 --> 01:02:12.560]   All right.
[01:02:12.560 --> 01:02:15.600]   So let's take, for example, pixel, maybe we can write it like this.
[01:02:15.600 --> 01:02:18.160]   We'll say pixel one comma one.
[01:02:18.160 --> 01:02:19.880]   We could write it like that, for example.
[01:02:19.880 --> 01:02:25.520]   And so we could say what happens to the loss as we change pixel one comma one.
[01:02:25.520 --> 01:02:30.240]   So we can calculate a derivative, right?
[01:02:30.240 --> 01:02:34.040]   And it's going to be a partial, partial derivative.
[01:02:34.040 --> 01:02:41.040]   What, how does the loss change as we change pixel one comma one?
[01:02:44.640 --> 01:02:48.560]   So that would be a very useful thing to know, because that would then tell us, do we need
[01:02:48.560 --> 01:02:53.680]   to make pixel one comma one a bit brighter or a bit darker in order to improve the loss?
[01:02:53.680 --> 01:02:58.440]   And we could also calculate that for pixel one comma two, one comma three, and so forth.
[01:02:58.440 --> 01:03:01.520]   All 49 pixels in this super low resolution digit.
[01:03:01.520 --> 01:03:04.240]   So, okay.
[01:03:04.240 --> 01:03:06.320]   So there's the first thing we can calculate to them.
[01:03:06.320 --> 01:03:15.440]   The second thing I mentioned could be loss over pixel one comma two.
[01:03:15.440 --> 01:03:16.600]   Okay.
[01:03:16.600 --> 01:03:24.040]   So that's the slope as we change pixel one comma two.
[01:03:24.040 --> 01:03:31.520]   I'm not going to write all of them, but there could be, well, there will be 49 of these.
[01:03:35.600 --> 01:03:36.640]   For each seven by seven.
[01:03:36.640 --> 01:03:49.760]   So rather than writing out all 49 of those, it's nice to instead write them all at once
[01:03:49.760 --> 01:03:52.360]   and say, and you can do that like so.
[01:03:52.360 --> 01:03:57.920]   You can say upside down triangle X.
[01:03:57.920 --> 01:04:01.600]   Loss.
[01:04:02.840 --> 01:04:09.400]   And what that means is it's a vector of all of these derivatives.
[01:04:09.400 --> 01:04:14.360]   And this upside down triangle here is called either the Dell or the nabla.
[01:04:14.360 --> 01:04:19.800]   And it's just a little convenient notational shortcut to avoid writing all these out.
[01:04:19.800 --> 01:04:26.560]   And the X here is telling you about the thing that we're basically putting on the bottom.
[01:04:26.560 --> 01:04:27.120]   Right.
[01:04:27.120 --> 01:04:30.520]   What's it with respect to what's the direction that we're trying to go?
[01:04:31.480 --> 01:04:39.000]   Um, so that's actually what I should have written in, in the notes that I was doing in the lesson.
[01:04:39.000 --> 01:04:45.160]   Uh, I wrote something else, um, which was basically the equivalent of writing this
[01:04:45.160 --> 01:04:51.520]   and that's not a thing at all.
[01:04:51.520 --> 01:04:57.400]   Um, so in my notes, when you see me write this, I actually mean this.
[01:04:57.400 --> 01:05:00.400]   Um, so why does my brain get confused?
[01:05:00.400 --> 01:05:02.360]   And I write this weird thing that doesn't even exist.
[01:05:02.360 --> 01:05:03.520]   It's as far as I know.
[01:05:03.520 --> 01:05:08.200]   Uh, well, the reason is that this thing does exist if you check, turn the triangles upside down.
[01:05:08.200 --> 01:05:10.800]   And hence my brain always gets confused.
[01:05:10.800 --> 01:05:17.280]   And if I turn the triangles upside down, these triangles are now totally different.
[01:05:17.280 --> 01:05:21.720]   These triangles now mean a small change.
[01:05:22.800 --> 01:05:31.360]   So this is a small change in loss divided by a small change in, let's for example, one particular pixel.
[01:05:31.360 --> 01:05:33.840]   And that's a totally valid thing to say.
[01:05:33.840 --> 01:05:42.320]   Um, and in fact, if you make that small change small enough, then you're going to end up with a derivative.
[01:05:42.320 --> 01:05:43.760]   That's what the derivative is.
[01:05:51.360 --> 01:05:55.920]   So the derivative is just our classic rise over run.
[01:05:55.920 --> 01:06:00.320]   Okay, slope that we did in what is that grade eight grade nine rise over run.
[01:06:00.320 --> 01:06:06.560]   Once we make our step in X small enough.
[01:06:06.560 --> 01:06:19.200]   Um, and so then we can then do that for changing just one variable in a multivariable function.
[01:06:19.960 --> 01:06:24.080]   Um, so for example, when I say variable, I guess in this case, I should give an example.
[01:06:24.080 --> 01:06:31.080]   For example, changing one pixel value in an image to see how that impacts our loss.
[01:06:31.080 --> 01:06:33.160]   Uh, or we could do the same thing for the weights.
[01:06:33.160 --> 01:06:34.280]   We could change one weight.
[01:06:34.280 --> 01:06:42.080]   And if you just change one thing at a time and calculate the derivative of the loss against that one thing, then we get these things called partials.
[01:06:42.080 --> 01:06:46.600]   And if you then do it for all the different things that you could change, such as every pixel,
[01:06:47.880 --> 01:06:55.240]   you get this whole gradient vector, which we use the upside down triangle to represent.
[01:06:55.240 --> 01:07:03.600]   Um, and then finally, um, the non upside down triangle simply refers to a small change.
[01:07:03.600 --> 01:07:10.880]   So this would be a small change in loss, which is caused by changing pixel one, one by a small bit.
[01:07:10.880 --> 01:07:16.360]   And if you use a small enough bit, an infinitely small bit, we call that the derivative.
[01:07:17.640 --> 01:07:28.680]   Okay, so with all that said, um, net result, every time you see me, well, I think I did it once, but, um, in the notes where I say.
[01:07:28.680 --> 01:07:40.040]   This, uh, please throw that away in your head and replace it in your head with this.
[01:07:40.040 --> 01:07:43.200]   And that is the moral of the story.
[01:07:43.440 --> 01:07:51.800]   Okay, so thank you very much for, uh, bearing with me as I do my penance to actually, um, uh, get this notation correct this time.
[01:07:51.800 --> 01:07:56.720]   And I will endeavor not to make the same mistake again during this course, but no promises.
[01:07:56.720 --> 01:07:58.560]   All right, back to the lesson.
[01:07:58.560 --> 01:08:11.760]   Okay, so with those 784 values, they tell us how can we change X3 to make it look more like a digit?
[01:08:12.360 --> 01:08:18.840]   And so what we can then do is we can now change the pixels according to this gradient.
[01:08:18.840 --> 01:08:32.520]   And so we can do something a lot like what we do when we train neural networks, except instead of changing the whites in a model, we're changing the inputs to the model.
[01:08:32.520 --> 01:08:39.400]   And so we're going to take every pixel and we're going to modify it, subtract its gradient a little bit times its gradient.
[01:08:39.400 --> 01:08:49.480]   So we'll multiply this by some constant, let's call it C, and then we're going to subtract it to get some new image.
[01:08:49.480 --> 01:08:58.120]   So with the new image, it's probably going to get rid of some of these bits at the bottom, right?
[01:08:58.120 --> 01:09:05.360]   And it's probably going to add a few more bits between some of these here.
[01:09:08.480 --> 01:09:08.960]   Right.
[01:09:08.960 --> 01:09:17.920]   And we've now got something that looks slightly more like a handwritten digit than before.
[01:09:17.920 --> 01:09:23.520]   And this is the basic idea.
[01:09:23.520 --> 01:09:24.560]   We can now do that again.
[01:09:24.560 --> 01:09:25.720]   We can now take this.
[01:09:25.720 --> 01:09:27.640]   We can run it through F.
[01:09:27.640 --> 01:09:36.800]   And so we've now got something, let's say we call it X3 prime, for example.
[01:09:37.720 --> 01:09:45.400]   So this new version, X3 prime or whatever, is now the probability that's a handwritten digits, quite a bit higher.
[01:09:45.400 --> 01:09:48.440]   I'd say it's probably like 0.2, maybe.
[01:09:48.440 --> 01:09:51.400]   And we can now do the same thing.
[01:09:51.400 --> 01:10:03.960]   We can say for every pixel, if I increase its value a little bit or decrease its value a little bit, how does it change the probability that this new X3, whatever prime prime is a digit?
[01:10:04.400 --> 01:10:24.000]   And so we'll now get a new gradient here, 784 values, and we can use that to change every pixel to make it look a little bit more like a handwritten digit.
[01:10:26.320 --> 01:10:50.200]   So as you can see, if we have this magic function, we can use it to turn any arbitrary noisy input into something that looks like a valid input, something that has a high p-value from that function by using this derivative.
[01:10:50.560 --> 01:11:01.560]   So a key thing to remember here is saying, as I change the input pixels, how does it change the probability that this is a digit?
[01:11:01.560 --> 01:11:08.000]   And that tells me which pixels to make darker and which pixels to make lighter.
[01:11:12.480 --> 01:11:29.200]   Now, those of you who remember your high school calculus may recall that when you do this by changing each pixel one at a time to calculate a derivative, this is called the finite differencing method of calculating derivatives.
[01:11:29.840 --> 01:11:46.600]   And it's very slow because we have to call finite diff-- sorry, I can't spell-- differencing, it's very slow because we have to call it 7 dysfunction, 784 times, every single one.
[01:11:47.640 --> 01:12:17.440]   We don't have to use finite differencing. Assuming the folks running this magic API endpoint use Python, we can just call f.grad-- f.backward, and then we can get x3.grad, and that will tell us the same thing in one go by using the analytic derivatives.
[01:12:18.280 --> 01:12:28.160]   So we'll learn exactly about what these dot backward does. We'll write our own everything from scratch, including our own calculus things from scratch later.
[01:12:28.160 --> 01:12:32.840]   But for now, just like we did in part one of the course, we're just going to assume these things exist.
[01:12:35.760 --> 01:12:51.600]   So maybe then the nice folks that provide this endpoint can actually provide a new endpoint that calls dot backward for us and gives us dot grad. Right. And then we don't really have to use f at all. Right. We can instead just directly call this endpoint.
[01:12:56.320 --> 01:13:19.440]   We'll just directly call this endpoint that gives us the gradient directly. We'll multiply it by this smaller constant c. We'll subtract it from the pixels, and we'll do it a few times, making the input get larger and larger p values, larger and larger probabilities that this is actually a digit.
[01:13:20.920 --> 01:13:34.760]   So we don't particularly need this thing at all. We don't particularly need the thing that calculates these probabilities. We only need the thing that tells us which pixels we should change to calculate the probabilities.
[01:13:34.760 --> 01:13:48.920]   Okay, so that's great. The problem is nobody's provided this for us. So we're going to have to write it.
[01:13:49.760 --> 01:13:51.440]   So how are we going to do that?
[01:13:51.440 --> 01:14:09.600]   Well, no problem. Generally speaking, in this course, when there's some magic black box that we want to exist and it doesn't exist, we create a neural net and we train it.
[01:14:11.200 --> 01:14:25.600]   So we want to train a neural net that tells us which pixels to change to make a digit look more to make an image look more like a handwritten digit.
[01:14:25.600 --> 01:14:29.400]   Okay, so here's how we can do that.
[01:14:29.400 --> 01:14:31.800]   We could
[01:14:34.240 --> 01:14:39.840]   create some training data and use that training data
[01:14:39.840 --> 01:14:46.440]   to get the information we want. We could pass in something that looks a lot like a handwritten digit.
[01:14:46.440 --> 01:14:49.440]   We could pass something that looks
[01:14:49.440 --> 01:14:55.560]   a bit like a handwritten digit. We could pass something in that
[01:14:55.560 --> 01:15:00.360]   doesn't look very much like a handwritten digit.
[01:15:01.880 --> 01:15:04.240]   And we could pass in something which
[01:15:04.240 --> 01:15:09.600]   doesn't really look like a handwritten digit at all.
[01:15:09.600 --> 01:15:19.040]   Now you'll notice it was very easy for me to create these. I created real handwritten digits and then I just chucked random noise on top of it.
[01:15:23.760 --> 01:15:35.840]   It's a little bit awkward for us to come up with an exact score saying, how much is that like a handwritten digit? How much is that like a handwritten digit? How much is that and how much is that? It seems a bit arbitrary.
[01:15:35.840 --> 01:15:40.640]   So let's not do that. Let's use something which is kind of like the opposite.
[01:15:41.680 --> 01:15:54.400]   Right? And instead, let's say, oh, why don't we predict how much noise I added? Right? Because this number 7 is actually equal to
[01:15:54.400 --> 01:15:57.680]   this number 7 plus
[01:15:57.680 --> 01:16:00.040]   this noise.
[01:16:00.040 --> 01:16:07.120]   And this number 3 is actually equal to this number 3
[01:16:07.120 --> 01:16:10.000]   plus
[01:16:11.000 --> 01:16:11.720]   this noise.
[01:16:11.720 --> 01:16:17.600]   And this number 6 is actually equal to this number 6
[01:16:17.600 --> 01:16:19.560]   plus
[01:16:19.560 --> 01:16:21.600]   this noise.
[01:16:21.600 --> 01:16:25.160]   And that one's got a lot.
[01:16:25.160 --> 01:16:29.400]   And of course, the very first one is equal to
[01:16:29.400 --> 01:16:32.280]   this number 9
[01:16:32.280 --> 01:16:34.160]   plus
[01:16:34.160 --> 01:16:36.200]   this noise.
[01:16:39.280 --> 01:16:42.280]   So why don't we generate this data?
[01:16:42.280 --> 01:16:55.920]   And then rather than trying to come up with some arbitrary number of like how much like a digit is it, let's say the amount of noise tells us how much like a digit it is.
[01:16:55.920 --> 01:17:07.280]   So something with no noise is very much like a digit and something with lots of noise isn't much like a digit at all. So let's feed in. Let's create a neural net.
[01:17:08.760 --> 01:17:10.440]   Who cares what the architecture is?
[01:17:10.440 --> 01:17:13.640]   Right? It's just a neural net of some kind.
[01:17:13.640 --> 01:17:29.240]   And this is critical to your understanding of of this course at this point. We're going to go beyond the idea of like worrying all the time about architectures and details.
[01:17:30.080 --> 01:17:42.840]   And we're going to be spending quite often. We're going to get I mean we're going to get to all those details. But the important thing to using this stuff. Well, is to think about neural nets as being something that has some inputs.
[01:17:42.840 --> 01:17:47.120]   Some outputs.
[01:17:47.120 --> 01:17:51.440]   Oopsie-daisy.
[01:17:51.440 --> 01:17:57.680]   Some outputs.
[01:17:58.200 --> 01:18:03.440]   And some loss function which takes those two.
[01:18:03.440 --> 01:18:10.480]   And then the derivative is used to update the weights.
[01:18:10.480 --> 01:18:19.640]   Right? That's really what we care about. Those four things. Now the inputs to our model is.
[01:18:19.640 --> 01:18:23.640]   This.
[01:18:26.720 --> 01:18:28.840]   Okay, that's the inputs to our model.
[01:18:28.840 --> 01:18:53.440]   The outputs to our model is a measure of how much noise there is. So maybe we could just say, oh, well, what's the, um, these are all basically normally distributed random variables with a mean of zero and a variance in this case of zero, in this case, they're normally distributed random variables with a mean of zero and a variance of like 0.1.
[01:18:54.160 --> 01:19:02.920]   This one's normally distributed random variables, pixels, I guess, with a mean of zero and like 0.3. This one's super noisy.
[01:19:02.920 --> 01:19:15.440]   There's the main invariance. So that's the main each one and the variance for each one.
[01:19:17.240 --> 01:19:31.960]   So, why don't we, as the output, use the variance? So, predict how much noise. Or better still, why don't we predict the actual noise itself?
[01:19:31.960 --> 01:19:35.560]   So why don't we actually use.
[01:19:35.560 --> 01:19:39.600]   That.
[01:19:39.600 --> 01:19:45.720]   Now we're not just predicting how much noise, but we're predict the actual noise.
[01:19:46.760 --> 01:19:47.800]   That's our outputs.
[01:19:47.800 --> 01:19:51.400]   Now, if we do that, our loss is going to be very simple.
[01:19:51.400 --> 01:19:53.640]   It's going to be.
[01:19:53.640 --> 01:20:12.400]   We took the input, we passed it through our neural net. We tried to predict what the noise was. And so the prediction of the noise is N hat and the actual noise is N. And so we can do something we've done a thousand times.
[01:20:15.240 --> 01:20:21.000]   Which is we can divide it by the count squared and then we can sum all that up.
[01:20:21.000 --> 01:20:28.680]   And this here is the main squared error, which we use all the time.
[01:20:28.680 --> 01:20:34.120]   So the main squared error.
[01:20:37.160 --> 01:20:48.280]   Means that we've now got inputs, which is noisy digits. We've got outputs, which is noise. And so this neural network is trying to predict.
[01:20:48.280 --> 01:20:51.040]   This noise.
[01:20:51.040 --> 01:20:58.880]   So we're basically jumping straight to the step.
[01:20:58.880 --> 01:21:02.920]   That we had here. Remember, this is what we really wanted.
[01:21:04.000 --> 01:21:09.000]   We wanted some ability to know how much do we have to change a pixel by
[01:21:09.000 --> 01:21:15.440]   to make it more digit like. Well, to turn this
[01:21:15.440 --> 01:21:17.560]   number seven
[01:21:17.560 --> 01:21:23.200]   into this number seven. That's our goal. We have to remove all of that.
[01:21:23.200 --> 01:21:32.640]   So if we can predict the noise, then we've got exactly what we want, which is this.
[01:21:33.120 --> 01:21:39.280]   We can then do this process. We can take and multiply it by a constant and subtract it from our input.
[01:21:39.280 --> 01:21:47.480]   And so if you subtract this noise from this input, you get this hand written digit.
[01:21:47.480 --> 01:21:51.320]   So we're doing exactly what we wanted.
[01:21:51.320 --> 01:22:00.000]   Well, that seems easy enough.
[01:22:01.240 --> 01:22:05.280]   We already know from part one how to do this.
[01:22:05.280 --> 01:22:12.640]   So we just have any old neural network. So some kind of ConvNet or something that takes as input.
[01:22:12.640 --> 01:22:20.040]   Numbers where we've just randomly added different amounts of noise, lots of noise to some, not much noise to others.
[01:22:20.040 --> 01:22:27.280]   It predicts what the noise was that we added. We take the loss between the input.
[01:22:28.200 --> 01:22:33.480]   Sorry, between we take the loss between the predicted output and the actual noise mean squared error.
[01:22:33.480 --> 01:22:39.080]   And we use that to update the weights. And so if we train this for a while,
[01:22:39.080 --> 01:22:41.680]   then if we pass
[01:22:41.680 --> 01:22:49.160]   this into our model, it will return
[01:22:49.160 --> 01:22:51.200]   that.
[01:22:51.200 --> 01:22:54.720]   And
[01:22:58.040 --> 01:22:58.640]   we're done.
[01:22:58.640 --> 01:23:02.480]   We now have something that can generate
[01:23:02.480 --> 01:23:09.960]   images. How? Because now we can take this train neural network. So I'm going to copy it down here.
[01:23:09.960 --> 01:23:18.120]   And we can pass it.
[01:23:18.120 --> 01:23:22.480]   Something very, very, very noisy, which is pure noise.
[01:23:27.120 --> 01:23:30.200]   We pass it to the neural net and it's going to spit out
[01:23:30.200 --> 01:23:42.600]   information saying which part of that does it think is noise? And it's going to leave behind the bits that look the most like a digit, just like we did back here.
[01:23:42.600 --> 01:23:48.720]   So it might say, oh, you know what? If you left behind
[01:23:50.760 --> 01:23:57.600]   just that bit, that bit, that bit, that bit, that bit, that bit, that bit, that bit and that bit, it's going to look a little bit more like
[01:23:57.600 --> 01:24:04.160]   a digit. And then maybe you could increase the values of that bit, that bit, that bit, that bit, that bit, that bit and that bit.
[01:24:04.160 --> 01:24:05.880]   And so after you
[01:24:05.880 --> 01:24:09.320]   do that and so that everything else is noise.
[01:24:09.320 --> 01:24:12.320]   So we subtract
[01:24:12.320 --> 01:24:14.520]   those bits.
[01:24:14.520 --> 01:24:19.680]   Subtract it times some constant.
[01:24:20.520 --> 01:24:23.520]   We're now going to have
[01:24:23.520 --> 01:24:28.960]   something that looks more like a digit,
[01:24:28.960 --> 01:24:33.640]   which is what we hoped for. And so then we can just do it again.
[01:24:33.640 --> 01:24:37.400]   And you can see now why we
[01:24:37.400 --> 01:24:47.440]   you can see now why we are doing this multiple times.
[01:24:47.440 --> 01:24:58.600]   Somebody on the chat saying they don't see me drawing.
[01:24:58.600 --> 01:25:03.120]   Oh, you can see. Thanks, Jimmy.
[01:25:03.120 --> 01:25:05.880]   Don't know, Michelangelo, what's happening for you.
[01:25:05.880 --> 01:25:08.040]   Okay.
[01:25:12.720 --> 01:25:17.880]   And to answer your earlier question about how am I drawing, I'm using a graphics tablet,
[01:25:17.880 --> 01:25:24.520]   which I'm not very expert at, because on Windows you can just draw directly on the screen, which is why this is particularly messy.
[01:25:33.840 --> 01:25:43.160]   All right. In practice, at the moment, this might change by the time you've watched this, we use a particular type of neural net for this.
[01:25:43.160 --> 01:25:48.200]   The particular kind of neural net we use is something that was developed for medical imaging called the unit.
[01:25:48.200 --> 01:25:56.400]   If you've done previous versions of the course, you will have seen this and don't worry, this course will see exactly how a unit works and we'll build them ourselves from scratch.
[01:25:56.400 --> 01:26:01.400]   And this is the first component of stable diffusion.
[01:26:02.640 --> 01:26:03.720]   It's the unit.
[01:26:03.720 --> 01:26:14.640]   Okay, so there's going to be a few pieces.
[01:26:14.640 --> 01:26:26.640]   And the details of why they're called these things don't matter too much just yet. Just take my word for it. This is their names and the thing that you do need to know for each thing is like what's the input and what's the output.
[01:26:27.000 --> 01:26:47.800]   So the input to a unit, well, what does it do? The input to the unit is a somewhat noisy image. And when I say somewhat, it could be not noisy at all, or it could be all noise. That's the input.
[01:26:47.800 --> 01:26:53.840]   And the output is the noise.
[01:26:55.560 --> 01:27:03.520]   Such that if we subtract the output from the input, we end up with the unnoisy image or at least an approximation of it.
[01:27:03.520 --> 01:27:09.840]   So that's the unit.
[01:27:09.840 --> 01:27:15.960]   Now here's the problem. Well, here's our problem.
[01:27:15.960 --> 01:27:21.360]   We have, oh, why do I keep forgetting this? We have
[01:27:24.920 --> 01:27:31.120]   28 times 28, 784, I should write that down. We have in these things
[01:27:31.120 --> 01:27:34.800]   784 pixels.
[01:27:34.800 --> 01:27:51.040]   And that's quite a lot. And it gets worse because in practice, we don't want to draw handwritten digits. The thing that would be passing in here is beautiful high definition photos or images of like great paintings.
[01:27:51.760 --> 01:27:58.480]   And at the moment, the thing we tend to use for that is a 512
[01:27:58.480 --> 01:28:02.880]   by 512
[01:28:02.880 --> 01:28:06.000]   by three channel RGB.
[01:28:06.000 --> 01:28:12.480]   Nice big image, 512 by 512 by 3.
[01:28:19.000 --> 01:28:31.880]   Red, green, blue. These are the pixels. So that is 512 by 512 by 3, 786, 432.
[01:28:31.880 --> 01:28:35.320]   So we've got 786,
[01:28:35.320 --> 01:28:38.440]   432 pixels in here.
[01:28:38.440 --> 01:28:47.800]   And so this is, I don't know, some beautiful picture. This is my amazing portrait Van Gogh style
[01:28:48.640 --> 01:28:51.840]   in a dainty little hat. There we go. So
[01:28:51.840 --> 01:29:00.720]   this is the beautiful painting or an image of it. That's a lot of pixels. And so training
[01:29:00.720 --> 01:29:10.160]   this model where we put noisy versions of millions of these beautiful images is going to take us an awful long time.
[01:29:11.360 --> 01:29:21.360]   And, you know, if you're Google with a huge cloud of TPUs or something, maybe that's okay. But for the rest of us, we would like to do this as efficiently as possible.
[01:29:21.360 --> 01:29:26.640]   How could we do this more efficiently?
[01:29:26.640 --> 01:29:33.160]   Well, when you think about it, in this beautiful picture I drew,
[01:29:33.160 --> 01:29:40.600]   storing the exact pixel value of every single pixel is probably not the most efficient way.
[01:29:41.280 --> 01:29:41.920]   To store it.
[01:29:41.920 --> 01:29:51.400]   You know, what if instead we said like, oh, you know, let's say this is like green rushes or something.
[01:29:51.400 --> 01:29:59.720]   It might say like, oh, over here is green and everything kind of underneath. It's pretty much the same.
[01:29:59.720 --> 01:30:07.400]   Or, you know, maybe I'm wearing a blue top in this beautiful portrait and it could kind of say like, oh, all the pixels in here are blue.
[01:30:07.880 --> 01:30:13.160]   You know, you don't really have to do every one individually. There are faster, more concise ways of
[01:30:13.160 --> 01:30:17.440]   storing what an image is.
[01:30:17.440 --> 01:30:23.240]   We know this is true because, for example, a JPEG picture
[01:30:23.240 --> 01:30:30.160]   is far fewer bytes than the number of bytes you would get if you multiplied its height by its width by its channels.
[01:30:30.160 --> 01:30:34.480]   So we know that it's possible to compress
[01:30:34.480 --> 01:30:37.560]   pictures.
[01:30:38.160 --> 01:30:44.000]   So let me show you a really interesting way to compress pictures.
[01:30:44.000 --> 01:30:50.760]   Let's take this image and let's put it through a convolutional layer of Stride 2.
[01:30:50.760 --> 01:30:54.200]   Now, if we put it through a convolutional layer of Stride 2
[01:30:54.200 --> 01:31:05.760]   with six features, with six channels, we would get back a 256 by 256. Gosh, that was a terrible attempt at drawing a square, wasn't it?
[01:31:05.760 --> 01:31:22.680]   256 by 256. Actually, do it here by, okay, let's double the number of channels to six by six.
[01:31:22.680 --> 01:31:26.680]   And then let's put it through another Stride 2 convolution.
[01:31:26.680 --> 01:31:30.880]   And remember, we're going to be seeing exactly how to do all these things and building them all from scratch.
[01:31:30.880 --> 01:31:34.280]   So don't worry if you're not sure what a Stride 2 convolution exactly is.
[01:31:35.120 --> 01:31:40.840]   And just do it again to get 128 by 128. And again, let's double the number of channels.
[01:31:40.840 --> 01:31:48.560]   And then let's do it again. Another Stride 2 convolution. So we're just building a neural network here.
[01:31:48.560 --> 01:31:59.920]   So now we're down to 64 by 64 by 24.
[01:32:01.400 --> 01:32:09.200]   Okay, and then now let's put that through a few like resnet blocks to kind of squish down the number of channels as much as we can.
[01:32:09.200 --> 01:32:14.920]   So it'll be now down to let's say 64 by 64 by 4.
[01:32:14.920 --> 01:32:21.000]   Okay, so here's a neural network.
[01:32:21.000 --> 01:32:30.760]   And so the number of pixels in this version is now 64 times 64 times 4, 16, 3, 8, 4.
[01:32:30.760 --> 01:32:38.200]   So there's 16, 3, 8, 4 pixels here.
[01:32:38.200 --> 01:32:50.240]   Okay, so we've compressed it from 7, 8, 6, 4, 3, 2, to 16, 3, 8, 4,
[01:32:50.240 --> 01:32:54.360]   which is a 48 times decrease.
[01:32:59.240 --> 01:33:01.640]   Now that's no use if we've lost our image.
[01:33:01.640 --> 01:33:05.560]   So can we get the image back again?
[01:33:05.560 --> 01:33:13.160]   Sure, why not? What if we now create a
[01:33:13.160 --> 01:33:17.960]   kind of an inverse convolution
[01:33:17.960 --> 01:33:24.200]   which does the exact opposite. So actually let's put it
[01:33:26.000 --> 01:33:29.520]   over here. So we're going to take our
[01:33:29.520 --> 01:33:36.160]   64 by 64 by 4 image, put it through an inverse convolution.
[01:33:36.160 --> 01:33:41.840]   So let's put it, let's keep moving this over further.
[01:33:51.640 --> 01:33:56.360]   Back to 128 by 128 by 12.
[01:33:56.360 --> 01:34:01.840]   And put it through another inverse convolution.
[01:34:01.840 --> 01:34:06.480]   So these are all just basically they're just neural network layers.
[01:34:06.480 --> 01:34:11.640]   256 by 256
[01:34:11.640 --> 01:34:15.280]   by 6.
[01:34:15.280 --> 01:34:19.240]   And then finally
[01:34:21.280 --> 01:34:23.280]   wrap you out
[01:34:23.280 --> 01:34:29.600]   all the way back to
[01:34:29.600 --> 01:34:33.520]   512
[01:34:33.520 --> 01:34:39.360]   by 512
[01:34:39.360 --> 01:34:42.080]   by 3.
[01:34:42.080 --> 01:34:44.400]   Okay, we could put this whole thing
[01:34:44.400 --> 01:34:49.360]   inside a neural net. Here's our single neural network.
[01:34:49.360 --> 01:34:57.040]   And what we could do is we can start fading at images.
[01:34:57.040 --> 01:35:04.960]   It goes all the way through this neural network and out of the other end comes back. Well initially
[01:35:04.960 --> 01:35:07.360]   it's random.
[01:35:07.360 --> 01:35:10.160]   So initially comes out of this is random noise.
[01:35:10.160 --> 01:35:16.200]   512 by 512, I guess I draw it
[01:35:17.680 --> 01:35:21.280]   inside here. So inside here initially it's going to give us random noise.
[01:35:21.280 --> 01:35:25.520]   And so now we need a loss function, right?
[01:35:25.520 --> 01:35:28.560]   So the loss function we can create
[01:35:28.560 --> 01:35:32.200]   could be to say let's take
[01:35:32.200 --> 01:35:34.880]   this output and
[01:35:34.880 --> 01:35:37.080]   this input and
[01:35:37.080 --> 01:35:41.880]   compare them and create and do an MSE, Mean Squared Error,
[01:35:41.880 --> 01:35:46.440]   directly on those two pieces.
[01:35:47.440 --> 01:35:49.640]   So what would that do if we train this model?
[01:35:49.640 --> 01:35:55.800]   This model is going to try to put an image through
[01:35:55.800 --> 01:36:01.560]   and going to try to make it so that what comes out the other end is the exact same thing
[01:36:01.560 --> 01:36:07.080]   that went into it.
[01:36:07.080 --> 01:36:16.040]   That's what it's going to try to do.
[01:36:16.920 --> 01:36:18.920]   Because if it does that successfully
[01:36:18.920 --> 01:36:21.840]   then the Mean Squared Error would be zero.
[01:36:21.840 --> 01:36:31.360]   So I see some people in the chat saying that this is a unit. This is not a unit. Okay, we'll get to that later.
[01:36:31.360 --> 01:36:33.360]   There's no cross connections.
[01:36:33.360 --> 01:36:41.000]   It's just a bunch of convolutions that decrease inside followed by a bunch of convolutions that increase in size.
[01:36:43.240 --> 01:36:45.800]   And so we're going to try to train this model
[01:36:45.800 --> 01:36:50.800]   to spit out exactly what it received in.
[01:36:50.800 --> 01:36:53.760]   And that seems really boring.
[01:36:53.760 --> 01:36:59.720]   What's the point of a model that only learns
[01:36:59.720 --> 01:37:03.000]   to give you back exactly what came in?
[01:37:03.000 --> 01:37:09.120]   Well, this is actually extremely interesting. This kind of model is called an autoencoder.
[01:37:10.840 --> 01:37:13.200]   It's something that gives you back what you gave it.
[01:37:13.200 --> 01:37:20.520]   And the reason an autoencoder is interesting is because we can spit it in half.
[01:37:20.520 --> 01:37:25.720]   Let's grab just this bit.
[01:37:25.720 --> 01:37:35.760]   Okay, let's cut it up. Let's grab that just that bit and then we'll get a second half.
[01:37:35.760 --> 01:37:39.040]   Okay, they're not quite halves, but you know what I mean, which is just
[01:37:40.040 --> 01:37:43.000]   this bit. And so let's say I
[01:37:43.000 --> 01:37:51.800]   take this image and I put it through just this first half, this green half, which is called the encoder.
[01:37:51.800 --> 01:37:57.080]   Okay, I can take this
[01:37:57.080 --> 01:38:00.320]   this thing that comes out of it
[01:38:00.320 --> 01:38:06.520]   and I could save it. And the thing that I'm going to save is going to be
[01:38:08.360 --> 01:38:10.360]   16,384 bytes.
[01:38:10.360 --> 01:38:13.600]   I started with something
[01:38:13.600 --> 01:38:16.560]   that was 48 times bigger than that,
[01:38:16.560 --> 01:38:26.040]   786,432 bytes. And I've turned it into something that's 16,384 bytes. I could now
[01:38:26.040 --> 01:38:33.800]   attach that to an email, say or whatever. And I've now got something that's 48 times smaller than my original picture.
[01:38:34.520 --> 01:38:38.560]   So what's going to happen? The person who receives these 16,384 bytes?
[01:38:38.560 --> 01:38:44.400]   Well, as long as they have a copy of the decoder on their computer,
[01:38:44.400 --> 01:38:48.360]   they can feed those bytes into the decoder and get back
[01:38:48.360 --> 01:38:52.040]   the original image.
[01:38:52.040 --> 01:38:58.160]   So what we've just done is we've created a compression algorithm.
[01:38:58.160 --> 01:39:04.400]   That's pretty amazing, isn't it?
[01:39:04.560 --> 01:39:06.240]   And in fact,
[01:39:06.240 --> 01:39:08.240]   these compression algorithms
[01:39:08.240 --> 01:39:11.600]   work extremely, extremely well.
[01:39:11.600 --> 01:39:20.560]   Notice that we didn't train this on just this one image. We've trained it on say millions and millions of images, right?
[01:39:20.560 --> 01:39:25.120]   And then so you and I both need to have a copy of these two neural nets.
[01:39:25.120 --> 01:39:28.120]   But now we can share
[01:39:28.120 --> 01:39:33.880]   thousands of pictures that we send each other by sending just the 16,384
[01:39:34.240 --> 01:39:36.240]   byte version.
[01:39:36.240 --> 01:39:38.520]   So we've created a very powerful
[01:39:38.520 --> 01:39:41.520]   compression algorithm.
[01:39:41.520 --> 01:39:43.040]   And
[01:39:43.040 --> 01:39:45.040]   so maybe you can see where this is going.
[01:39:45.040 --> 01:39:53.240]   If this here is something which contains all of the interesting and useful information of the image in
[01:39:53.240 --> 01:39:55.720]   16,384 bytes,
[01:39:55.720 --> 01:39:58.680]   why on earth
[01:39:58.680 --> 01:40:01.000]   would we train our UNET
[01:40:01.960 --> 01:40:06.000]   with 786,432 pixels of information?
[01:40:06.000 --> 01:40:11.360]   And the answer is we wouldn't. That would be stupid.
[01:40:11.360 --> 01:40:14.600]   Instead, we're going to do this entire thing
[01:40:14.600 --> 01:40:21.520]   using our encoded version of each picture.
[01:40:21.520 --> 01:40:24.200]   So if we want to train this
[01:40:24.200 --> 01:40:26.680]   UNET on
[01:40:26.680 --> 01:40:28.680]   10 million pictures,
[01:40:28.800 --> 01:40:33.720]   we put all 10 million pictures through the auto encoder's encoder.
[01:40:33.720 --> 01:40:39.480]   So we've now got 10 million of these smaller things and
[01:40:39.480 --> 01:40:43.680]   then we feed it into the UNET training
[01:40:43.680 --> 01:40:47.000]   hundreds or thousands of times
[01:40:47.000 --> 01:40:51.440]   to train our UNET. And so what will that UNET now do?
[01:40:51.440 --> 01:40:58.240]   Something slightly different to what we described. It does not anymore take a somewhat noisy image
[01:40:59.240 --> 01:41:05.160]   instead it takes a somewhat noisy one of these. So it probably helped to give this thing a name and
[01:41:05.160 --> 01:41:07.920]   so the name we give this thing is
[01:41:07.920 --> 01:41:12.840]   Latents. These are called the Latents.
[01:41:12.840 --> 01:41:17.760]   Okay, so instead
[01:41:17.760 --> 01:41:21.600]   the input is somewhat noisy
[01:41:21.600 --> 01:41:24.640]   Latents.
[01:41:24.640 --> 01:41:32.400]   The output is still the noise. And so we can now subtract the noise from the slightly noise somewhat noisy Latents.
[01:41:32.400 --> 01:41:35.600]   And that would give us
[01:41:35.600 --> 01:41:38.560]   the actual Latents.
[01:41:38.560 --> 01:41:46.240]   And so we can then take the output of the UNET and pass it into our auto encoder's
[01:41:52.200 --> 01:41:54.720]   decoder. Sorry, yes decoder.
[01:41:54.720 --> 01:41:57.680]   Because that's something which
[01:41:57.680 --> 01:42:04.560]   Okay, that's something which takes Latents and turns it into a picture. So the input to this is
[01:42:04.560 --> 01:42:09.240]   small
[01:42:09.240 --> 01:42:11.600]   Latents tensor.
[01:42:11.600 --> 01:42:19.840]   And the output is a large image.
[01:42:19.840 --> 01:42:21.840]   Okay.
[01:42:21.840 --> 01:42:33.480]   Now this thing here is not going to be called an encoder. It's going to have the name
[01:42:33.480 --> 01:42:37.840]   the VAE. And we'll learn about why
[01:42:37.840 --> 01:42:39.920]   later.
[01:42:39.920 --> 01:42:42.520]   Those details aren't too important, but let's
[01:42:45.440 --> 01:42:52.920]   put its correct name here, the VAE's decoder.
[01:42:52.920 --> 01:43:01.080]   So you're only going to need the encoder for the VAE if you're training a UNET. If you want to just do inference
[01:43:01.080 --> 01:43:05.320]   like we did today, you're only going to need the decoder of the UNET.
[01:43:11.080 --> 01:43:17.960]   So this whole thing of Latents is entirely optional, right? This thing we described before works fine.
[01:43:17.960 --> 01:43:23.200]   But you know, generally speaking, we would rather not use more compute than necessary.
[01:43:23.200 --> 01:43:28.800]   So unless you're trying to sell the world a roomful of TPUs,
[01:43:28.800 --> 01:43:34.480]   you would probably rather everybody was doing stuff on the thing that's 48 times smaller.
[01:43:35.320 --> 01:43:41.480]   So the VAE is optional, but it saves us a whole lot of time and a whole lot of money.
[01:43:41.480 --> 01:43:45.120]   So that's good.
[01:43:45.120 --> 01:43:50.520]   Okay, what's next?
[01:43:50.520 --> 01:43:54.680]   Well, there's something else which is
[01:43:54.680 --> 01:44:03.960]   we have not just been in this morning's, you know, sorry, in the first half of today's lesson, we weren't just
[01:44:04.480 --> 01:44:11.280]   saying, "produce me an image." We were saying, "produce me an image of
[01:44:11.280 --> 01:44:18.160]   Tiny the teddy bear riding a horse." So how does that bit work?
[01:44:18.160 --> 01:44:25.920]   So the way that bit works is actually on the whole pretty straightforward.
[01:44:25.920 --> 01:44:29.880]   Let's think about how we could do exactly that for our MNIST example.
[01:44:30.880 --> 01:44:35.600]   How could we get this so that rather than just feeding in noise and
[01:44:35.600 --> 01:44:42.320]   getting back some digit, how do we get it to give us a particular digit? What if we wanted to pass in
[01:44:42.320 --> 01:44:45.040]   the literal number 3
[01:44:45.040 --> 01:44:47.520]   plus some noise and
[01:44:47.520 --> 01:44:50.840]   having it attempt to generate a handwritten 3 for us?
[01:44:50.840 --> 01:44:54.240]   How would we do that?
[01:44:54.240 --> 01:45:00.320]   Well, what we could do is way back here for the input to this model
[01:45:00.720 --> 01:45:05.360]   is in addition to passing in the noisy input, let's also pass in
[01:45:05.360 --> 01:45:11.440]   a one hot encoded version of what digit it is.
[01:45:11.440 --> 01:45:22.600]   So we're now passing two things into this model. So previously this neural net
[01:45:22.600 --> 01:45:25.360]   took as inputs
[01:45:25.360 --> 01:45:27.760]   just the pixels,
[01:45:29.800 --> 01:45:32.080]   but now it's going to take in the pixels and
[01:45:32.080 --> 01:45:36.800]   what digit is it as like a one hot encoded vector?
[01:45:36.800 --> 01:45:44.400]   So now it's going to learn how to predict what is the noise,
[01:45:44.400 --> 01:45:53.600]   right, and it's going to predict what is the noise and it's going to have some extra information, which is it's going to know
[01:45:54.280 --> 01:46:01.000]   what the original image was. So we would expect this model to be better at predicting noise than the previous one because we're giving
[01:46:01.000 --> 01:46:02.600]   it more information.
[01:46:02.600 --> 01:46:05.400]   This was a 3, this was a 6, this was a 7.
[01:46:05.400 --> 01:46:14.120]   So this neural net is going to learn to estimate noise better by taking advantage of the fact that it knows
[01:46:14.120 --> 01:46:16.720]   what actual the input was.
[01:46:18.600 --> 01:46:24.440]   And why is that useful? Well the reason that's useful is because now when we feed in
[01:46:24.440 --> 01:46:31.040]   the number 3, like the actual digit 3 is a one hot encoded vector plus noise after this has been trained,
[01:46:31.040 --> 01:46:38.240]   then our model is going to say the noise is everything that doesn't represent the number 3,
[01:46:38.240 --> 01:46:40.720]   because that's what it's learned to do.
[01:46:42.600 --> 01:46:50.680]   Right? So that's a pretty straightforward way to give it, the word we use is guidance about what it is
[01:46:50.680 --> 01:46:59.280]   that we're actually trying to remove the noise from. And so then we can use that guidance to guide it as to what image
[01:46:59.280 --> 01:47:01.280]   we're trying to create.
[01:47:01.280 --> 01:47:08.200]   So that's the basic idea. Now the problem is if we want to create a picture of
[01:47:11.800 --> 01:47:13.800]   a cute teddy bear,
[01:47:13.800 --> 01:47:22.280]   we've got a problem.
[01:47:22.280 --> 01:47:25.440]   It was easy enough to pass the digit 8,
[01:47:25.440 --> 01:47:28.960]   the literal number 8 into our
[01:47:28.960 --> 01:47:33.560]   neural net, because we can just create a one hot encoded vector in
[01:47:33.560 --> 01:47:38.280]   which position number 8 is a 1 and everything else is a 0.
[01:47:38.280 --> 01:47:41.080]   But how do we do that for a cute teddy?
[01:47:41.960 --> 01:47:43.960]   We can't.
[01:47:43.960 --> 01:47:46.720]   We can't create every possible
[01:47:46.720 --> 01:47:52.120]   sentence that can be uttered in the whole world and then create a one hot encoded version,
[01:47:52.120 --> 01:47:58.600]   one hot encoded version of every sentence in the world, because that's going to take a vector that is
[01:47:58.600 --> 01:48:01.080]   too long to say the least.
[01:48:01.080 --> 01:48:05.520]   So we have to do something else to turn this
[01:48:06.320 --> 01:48:11.600]   into an embedding, something other than grabbing a one hot encoded version of this.
[01:48:11.600 --> 01:48:14.720]   So what do we do?
[01:48:14.720 --> 01:48:17.720]   So what we do
[01:48:17.720 --> 01:48:24.160]   So what we're going to do is we're going to try to
[01:48:24.160 --> 01:48:32.440]   create a model that can take a sentence like a cute teddy and
[01:48:34.400 --> 01:48:42.520]   can return a vector of numbers that in some way represents what cute teddies look like.
[01:48:42.520 --> 01:48:48.880]   And the way we're going to do that is we're first going to surf the internet and
[01:48:48.880 --> 01:48:54.440]   download images. So here are four examples of images that I found on the internet. And
[01:48:54.440 --> 01:48:57.200]   so for each of these images
[01:48:57.200 --> 01:48:59.400]   they
[01:48:59.400 --> 01:49:02.240]   had an image tag next to them, right?
[01:49:02.240 --> 01:49:12.960]   And if people are being good, then they also added an alt tag to help with accessibility and
[01:49:12.960 --> 01:49:18.200]   maybe for SEO purposes and they probably said things like a
[01:49:18.200 --> 01:49:21.280]   graceful swan.
[01:49:28.080 --> 01:49:32.760]   And the alt tag for this might have been a scene from Hitchcock's The Birds.
[01:49:32.760 --> 01:49:42.640]   And the alt tag for this might have been Jeremy Howard.
[01:49:42.640 --> 01:49:50.320]   And the alt tag for this might have been fast.ai's logo.
[01:49:54.880 --> 01:49:59.560]   And we could do that for millions and millions and millions of images that we find on the internet.
[01:49:59.560 --> 01:50:10.600]   So what we can now do with these is we can create two models.
[01:50:10.600 --> 01:50:15.920]   One model which is a text encoder
[01:50:15.920 --> 01:50:22.360]   and one model which is an image encoder.
[01:50:22.360 --> 01:50:37.800]   Okay, so again, these are neural nets. We don't care about what their architectures are or whatever.
[01:50:37.800 --> 01:50:41.560]   We know that they're just black boxes which contain weights,
[01:50:41.560 --> 01:50:47.600]   which means they need inputs and outputs and a loss function and then they'll do something.
[01:50:49.640 --> 01:50:55.200]   Once we've defined inputs and outputs and a loss function, the neural nets will then do something.
[01:50:55.200 --> 01:50:58.200]   So here's a really interesting idea.
[01:50:58.200 --> 01:51:05.960]   What if we take
[01:51:05.960 --> 01:51:09.920]   this image
[01:51:13.640 --> 01:51:20.800]   and what if we then also take the text a graceful swan.
[01:51:20.800 --> 01:51:28.960]   Okay, and we're going to feed these
[01:51:28.960 --> 01:51:35.200]   into their respective models, which initially they of course have random weights.
[01:51:35.200 --> 01:51:39.640]   And that means that they're going to spit out
[01:51:41.200 --> 01:51:46.120]   random features, the vector of stuff, random crap.
[01:51:46.120 --> 01:51:49.560]   Because we haven't trained them yet, okay?
[01:51:49.560 --> 01:51:56.120]   And we can do the same thing with a scene from Hitchcock.
[01:51:56.120 --> 01:52:03.160]   We pass the scene from Hitchcock in and we'll pass in the words seen from Hitchcock and they'll give us two other vectors.
[01:52:03.160 --> 01:52:08.480]   Right, and so we can do something really interesting now.
[01:52:08.480 --> 01:52:15.320]   We can line these up.
[01:52:15.320 --> 01:52:20.760]   Guess we'll just move them.
[01:52:20.760 --> 01:52:23.680]   We can line these up.
[01:52:23.680 --> 01:52:32.080]   Okay, here's all of our images.
[01:52:32.080 --> 01:52:37.240]   Okay, and then we can have, oopsie dozy,
[01:52:37.240 --> 01:52:44.920]   okay, and then we can have our text.
[01:52:44.920 --> 01:52:51.120]   So we've got graceful swan.
[01:52:51.120 --> 01:52:58.560]   We've got Hitchcock.
[01:53:03.480 --> 01:53:08.720]   We've got Jeremy Howard and we've got fastai logo.
[01:53:08.720 --> 01:53:15.840]   Now ideally when we pass the graceful swan
[01:53:15.840 --> 01:53:20.480]   through our model,
[01:53:20.480 --> 01:53:32.880]   what we'd like is that it creates a set of embeddings that are a good match for the text.
[01:53:33.600 --> 01:53:35.600]   Graceful swan.
[01:53:35.600 --> 01:53:42.400]   When we pass the scene from Hitchcock through our image model,
[01:53:42.400 --> 01:53:49.000]   we would like it to return embeddings which are similar to the embeddings for the text seen from Hitchcock.
[01:53:49.000 --> 01:53:55.160]   And ditto for the picture of Jeremy Howard versus the name Jeremy Howard and ditto for the image fastai and
[01:53:56.160 --> 01:54:02.960]   sorry, the fastai logo and the word fastai logo. So in other words, for this particular combination here,
[01:54:02.960 --> 01:54:05.920]   we would like this one's
[01:54:05.920 --> 01:54:13.360]   features and this one's features to be similar.
[01:54:13.360 --> 01:54:18.960]   So how do we tell if two sets of things are similar? Two vectors.
[01:54:22.880 --> 01:54:30.480]   Well, what we can do is we can simply multiply them together, element-wise, and add them up.
[01:54:30.480 --> 01:54:34.000]   And this thing here is called the dot product.
[01:54:34.000 --> 01:54:40.480]   And
[01:54:40.480 --> 01:54:46.560]   so we could take the dot product of the features from the image model for this one and the dot product of the
[01:54:46.560 --> 01:54:51.480]   features from the text model for the word graceful swan and take their dot product.
[01:54:51.480 --> 01:54:53.800]   And we want that number to be
[01:54:53.800 --> 01:54:56.520]   nice and big.
[01:54:56.520 --> 01:55:00.760]   And the scene from Hitchcock's
[01:55:00.760 --> 01:55:04.360]   features should be very similar to the text
[01:55:04.360 --> 01:55:11.880]   seen from Hitchcock's features. So we want their product to be nice and big and ditto for everything on this diagonal.
[01:55:11.880 --> 01:55:17.600]   Now on the other hand, a graceful swan picture
[01:55:17.760 --> 01:55:22.080]   should not have embeddings that are similar to the text as seen from Hitchcock.
[01:55:22.080 --> 01:55:28.600]   So that should be nice and small. And ditto for everything else off diagonal.
[01:55:28.600 --> 01:55:35.600]   And so perhaps you can see where this is going.
[01:55:35.600 --> 01:55:40.560]   If we add up
[01:55:40.560 --> 01:55:44.040]   all of these
[01:55:46.640 --> 01:55:50.760]   right, add those all together and then subtract
[01:55:50.760 --> 01:55:55.640]   all of these
[01:55:55.640 --> 01:56:02.080]   we have a loss function.
[01:56:02.080 --> 01:56:07.200]   And so if we want this loss function
[01:56:07.200 --> 01:56:12.520]   to be good, then we're going to need the weights of our model
[01:56:13.880 --> 01:56:17.000]   for the text encoder to spit out embeddings
[01:56:17.000 --> 01:56:20.360]   that are very similar
[01:56:20.360 --> 01:56:25.680]   to the images that they're paired with. And we need them to spit out
[01:56:25.680 --> 01:56:28.320]   embedd- uh, features
[01:56:28.320 --> 01:56:31.840]   for things that they are not paired with which are not similar.
[01:56:31.840 --> 01:56:35.320]   And so if we can do that
[01:56:35.320 --> 01:56:40.120]   then we're going to end up with a text encoder that we can feed in
[01:56:42.000 --> 01:56:44.000]   things like a graceful swan
[01:56:44.000 --> 01:56:48.040]   some beautiful swan
[01:56:48.040 --> 01:56:52.720]   such a lovely swan and
[01:56:52.720 --> 01:57:00.080]   these should all give very similar embeddings because these would all represent very similar pictures.
[01:57:00.080 --> 01:57:06.200]   And so what we've now done is we successfully created
[01:57:06.200 --> 01:57:10.880]   two models
[01:57:11.240 --> 01:57:16.080]   that together put text and images into the same space.
[01:57:16.080 --> 01:57:19.160]   So we've got this multimodal
[01:57:19.160 --> 01:57:23.800]   set of models
[01:57:23.800 --> 01:57:31.040]   which is exactly what we wanted. So now we can take our cute teddy bear
[01:57:31.040 --> 01:57:40.960]   feed it in here
[01:57:41.960 --> 01:57:43.960]   get out some features
[01:57:43.960 --> 01:57:49.040]   and that is what we will use
[01:57:49.040 --> 01:57:56.480]   instead of these one hot encoded vectors when we train our
[01:57:56.480 --> 01:58:01.760]   photo or painting whatever unit.
[01:58:01.760 --> 01:58:07.040]   And then we can do exactly the same thing with guidance. We can now pass in
[01:58:08.360 --> 01:58:11.880]   the text encoder's feature vector for a cute teddy and
[01:58:11.880 --> 01:58:14.960]   it is going to turn the noise
[01:58:14.960 --> 01:58:17.520]   into something that
[01:58:17.520 --> 01:58:23.280]   is similar to things that it's previously seen that are cute teddies.
[01:58:23.280 --> 01:58:31.000]   So the model that's used or the pair of models that's used here is called clip.
[01:58:35.280 --> 01:58:41.240]   This thing where we want these to be bigger and these to be smaller is called a contrastive loss.
[01:58:41.240 --> 01:58:48.880]   And now you know where the CL comes from.
[01:58:48.880 --> 01:58:58.880]   So here we have a clip text encoder.
[01:58:58.880 --> 01:59:11.480]   Its input is some text.
[01:59:11.480 --> 01:59:18.440]   Its output is we call it an embedding. It's just some features.
[01:59:18.440 --> 01:59:23.600]   Oops embedding
[01:59:25.200 --> 01:59:31.400]   where similar sets of text meaning with similar meanings will give us
[01:59:31.400 --> 01:59:35.080]   similar embeddings.
[01:59:35.080 --> 01:59:43.600]   Okay, because we need a bit more space. We're nearly done.
[01:59:52.440 --> 01:59:56.440]   Okay, so we've got the unit that can de-noise
[01:59:56.440 --> 01:59:59.760]   latency into unnoisy latency
[01:59:59.760 --> 02:00:04.560]   including pure noise. We've got a decoder that can take latency and create an image.
[02:00:04.560 --> 02:00:10.680]   We've got a text encoder which can allow us to train a unit which is guided by captions.
[02:00:10.680 --> 02:00:16.400]   So the last thing we need
[02:00:16.400 --> 02:00:21.080]   is the question about how exactly
[02:00:22.040 --> 02:00:25.720]   do we do this inference process here?
[02:00:25.720 --> 02:00:33.600]   So how exactly once we've got something that gives us the gradients we want and
[02:00:33.600 --> 02:00:36.680]   by the way these gradients
[02:00:36.680 --> 02:00:42.680]   are often called the score function just in case you come across that.
[02:00:42.680 --> 02:00:48.080]   That's all that's referring to.
[02:00:48.760 --> 02:00:52.440]   Yeah, how exactly do we go about this process and
[02:00:52.440 --> 02:00:56.560]   unfortunately the
[02:00:56.560 --> 02:01:01.760]   language used around this is
[02:01:01.760 --> 02:01:05.400]   weird and
[02:01:05.400 --> 02:01:08.360]   confusing and so ideally
[02:01:08.360 --> 02:01:16.040]   you will learn to ignore the fact that the language is weird and confusing and in particular the language you'll see a lot talks about
[02:01:17.000 --> 02:01:19.000]   time steps.
[02:01:19.000 --> 02:01:28.760]   And you'll notice that during our training process we never used any concept of time steps.
[02:01:28.760 --> 02:01:33.000]   This is basically an overhang from
[02:01:33.000 --> 02:01:38.160]   the particular way in which the math was formulated in the first papers.
[02:01:38.160 --> 02:01:41.400]   There are lots of other ways we can formulate it
[02:01:41.400 --> 02:01:46.760]   and during the course on the whole we will avoid using the term time steps.
[02:01:47.400 --> 02:01:49.680]   But we can, to see what time steps are,
[02:01:49.680 --> 02:01:53.200]   even though it's got nothing to do with time in real life,
[02:01:53.200 --> 02:01:56.280]   consider the fact that we used
[02:01:56.280 --> 02:02:01.480]   varying levels of noise. Some things were very noisy, some things were not noisy at all,
[02:02:01.480 --> 02:02:05.800]   some things had no noise and some I haven't drawn here would have been pure noise.
[02:02:05.800 --> 02:02:12.080]   You could basically create a kind of a noising schedule
[02:02:15.120 --> 02:02:19.240]   where along here you could put say the numbers from 1 to 1,000
[02:02:19.240 --> 02:02:28.520]   and you could then say oh, you know and we'll call this t and
[02:02:28.520 --> 02:02:37.640]   maybe we randomly pick a number from 1 to 1,000 and then we look up on this noise schedule
[02:02:37.640 --> 02:02:42.240]   which will be some monotonically decreasing function and
[02:02:43.720 --> 02:02:47.640]   we'd look up, let's say we happen to pick randomly a number 4,
[02:02:47.640 --> 02:02:54.200]   we would look up here to find where that is and we'd look over here and this would return to us some
[02:02:54.200 --> 02:02:59.520]   sigma which is the amount of noise to use if you happen to get a 4.
[02:02:59.520 --> 02:03:04.080]   So if you happen to get a 1
[02:03:04.080 --> 02:03:09.640]   you're going to get a whole lot of noise and if you happen to get a 1,000 you're going to have
[02:03:09.640 --> 02:03:12.280]   hardly any noise.
[02:03:13.520 --> 02:03:20.320]   So this is one way of like picking, so remember we were going to pick and when we were training
[02:03:20.320 --> 02:03:22.520]   we were going to pick for every image a random amount of noise.
[02:03:22.520 --> 02:03:27.200]   So this would be one way to do that is to pick a random number from 1 to 1,000,
[02:03:27.200 --> 02:03:31.800]   look it up on this function and that tells us how much noise to use.
[02:03:31.800 --> 02:03:37.840]   So this t is what people refer to as the time step.
[02:03:40.880 --> 02:03:45.800]   Nowadays you don't really have to do that that much and a lot of people are starting to get rid of this idea altogether
[02:03:45.800 --> 02:03:50.760]   and some people instead will simply say how much noise was there.
[02:03:50.760 --> 02:03:56.520]   Normally we would think of using sigma for standard deviations of
[02:03:56.520 --> 02:03:59.920]   Gaussians or normal distributions, but actually
[02:03:59.920 --> 02:04:03.640]   much more common is to use the Greek letter beta.
[02:04:05.680 --> 02:04:12.440]   And so if you see something talking about beta, they're just saying oh for that particular image when it was being trained
[02:04:12.440 --> 02:04:16.960]   what standard deviation of noise was being used basically?
[02:04:16.960 --> 02:04:20.160]   Slightly hand-wavy, but close enough.
[02:04:20.160 --> 02:04:27.720]   And so what you do each time you're going to create a mini batch to pass into your model,
[02:04:27.720 --> 02:04:31.760]   you randomly pick an image from your training set,
[02:04:33.480 --> 02:04:38.200]   you randomly pick either an amount of noise or some models,
[02:04:38.200 --> 02:04:45.120]   you randomly pick a t and then look up an amount of noise and then you put use that amount of noise for each one and
[02:04:45.120 --> 02:04:48.320]   then you pass that mini batch
[02:04:48.320 --> 02:04:50.440]   into your model
[02:04:50.440 --> 02:04:56.800]   to train it and that trains the weights in your model so it can learn to predict noise.
[02:04:56.800 --> 02:05:01.400]   And so then
[02:05:02.440 --> 02:05:08.720]   when you come to inference time, so inference is when you're generating a picture from pure noise,
[02:05:08.720 --> 02:05:17.960]   you want your model, basically your model is now starting
[02:05:17.960 --> 02:05:23.360]   here, right, which is as much noise as possible.
[02:05:23.360 --> 02:05:28.680]   And so you want it to learn to remove noise,
[02:05:30.400 --> 02:05:32.400]   but what it does in practice,
[02:05:32.400 --> 02:05:40.040]   as we saw in our notebook, is it actually creates some hideous and rather random
[02:05:40.040 --> 02:05:43.160]   kind of thing.
[02:05:43.160 --> 02:05:45.640]   So in fact, let's remind ourselves
[02:05:45.640 --> 02:05:51.520]   what that looked like.
[02:05:58.680 --> 02:06:00.680]   This is what it created
[02:06:00.680 --> 02:06:04.360]   when we tried to do it in one step.
[02:06:04.360 --> 02:06:10.040]   So remember what we then do is we say, okay,
[02:06:10.040 --> 02:06:13.400]   what's the prediction of the noise and
[02:06:13.400 --> 02:06:17.540]   then we multiply the prediction of the noise I said by
[02:06:17.540 --> 02:06:20.680]   some constant.
[02:06:20.680 --> 02:06:25.840]   It's kind of like a learning rate, but we're not updating weights now, we're updating pixels and
[02:06:26.520 --> 02:06:28.520]   we subtract it from the pixels.
[02:06:28.520 --> 02:06:37.040]   So it didn't actually predict the image, what it actually did was it predicted what the noise is.
[02:06:37.040 --> 02:06:44.140]   So that could then subtract that from the image, from the noisy image,
[02:06:44.140 --> 02:06:48.980]   to give us the
[02:06:48.980 --> 02:06:51.000]   denoised image.
[02:06:51.000 --> 02:06:56.340]   And so what we do is we don't actually subtract all of it, we multiply that by a constant.
[02:06:57.340 --> 02:07:00.260]   And we get a somewhat noisy image.
[02:07:00.260 --> 02:07:06.780]   The reason we don't jump all the way to
[02:07:06.780 --> 02:07:12.700]   the best image we can find is because things that look
[02:07:12.700 --> 02:07:17.960]   like this never appeared in our training set.
[02:07:22.740 --> 02:07:26.480]   And so since it never appeared in our training set,
[02:07:26.480 --> 02:07:32.980]   our model has no idea what to do with it. Our model only knows how to deal with things that look like
[02:07:32.980 --> 02:07:37.460]   somewhat noisy latents.
[02:07:37.460 --> 02:07:41.620]   So that's why we subtract just a bit of the noise
[02:07:41.620 --> 02:07:45.760]   so that we still have a somewhat noisy latent.
[02:07:45.760 --> 02:07:49.260]   So this process
[02:07:50.620 --> 02:07:54.900]   repeats a bunch of times, and the questions like what do we use for C?
[02:07:54.900 --> 02:08:01.600]   Right, and how do we go from the prediction of noise to the thing that we subtract?
[02:08:01.600 --> 02:08:04.820]   These are all of the things that
[02:08:04.820 --> 02:08:10.420]   are the kind of the things that you decide in the actual
[02:08:10.420 --> 02:08:16.820]   sampler.
[02:08:16.820 --> 02:08:19.780]   And that's used both to think about like
[02:08:20.420 --> 02:08:24.340]   how do I add the noise, and how do I subtract the noise? And
[02:08:24.340 --> 02:08:31.820]   there's a few things that might be jumping into your head at this point if you're anything like me.
[02:08:31.820 --> 02:08:37.820]   And one is that gosh, this looks an awful lot like
[02:08:37.820 --> 02:08:41.780]   deep learning optimizers.
[02:08:41.780 --> 02:08:47.660]   So in a deep learning optimizer this constant
[02:08:48.580 --> 02:08:50.580]   is called the learning rate.
[02:08:50.580 --> 02:08:57.380]   And we have some neat tricks where we say for example, oh if you change
[02:08:57.380 --> 02:09:01.700]   the same parameters by a similar amount
[02:09:01.700 --> 02:09:10.660]   multiple times in multiple steps, maybe you should increase the amount you change them. This concept is something we call momentum.
[02:09:10.660 --> 02:09:17.580]   And we'll be doing all this from scratch during the course, don't worry.
[02:09:18.220 --> 02:09:21.620]   And in fact, we even got better ways of doing that, where we kind of say well
[02:09:21.620 --> 02:09:27.500]   what about what happens if the variance changes? Maybe we can look at that as well, and that gives us something called Adam.
[02:09:27.500 --> 02:09:31.620]   And these are types of optimizer.
[02:09:31.620 --> 02:09:38.740]   And so maybe you might be wondering could we use these kinds of tricks?
[02:09:38.740 --> 02:09:46.780]   And the answer based on our very early research is yes. Yes, we can.
[02:09:46.780 --> 02:09:52.860]   The whole world of like where
[02:09:52.860 --> 02:10:00.500]   stable diffusion and all these diffusion based models came from, came from a very different world of maths,
[02:10:00.500 --> 02:10:03.740]   which is the world of differential equations.
[02:10:03.740 --> 02:10:10.220]   And there's a whole lot of very parallel concepts in the world of differential equations,
[02:10:12.180 --> 02:10:19.940]   which is really all about taking these like little steps, little steps, little steps, and trying to figure out how to take bigger steps.
[02:10:19.940 --> 02:10:28.180]   And so different differential equation solvers use a lot of the same kind of ideas if you squint as optimizers.
[02:10:28.180 --> 02:10:37.940]   One thing that differential equations solvers do, which is kind of interesting though, is that they tend to take T
[02:10:39.660 --> 02:10:45.940]   as an input. And in fact, pretty much all diffusion models, I've actually lied,
[02:10:45.940 --> 02:10:48.860]   pretty much all diffusion models
[02:10:48.860 --> 02:10:57.740]   don't just take the input pixels and the digit or the caption or the prompt, they also take
[02:10:57.740 --> 02:11:04.500]   T. And the idea is that the model will be better at
[02:11:04.500 --> 02:11:09.340]   removing the noise if you tell it how much noise there is.
[02:11:10.300 --> 02:11:12.860]   And remember, this is related to how much noise there is.
[02:11:12.860 --> 02:11:18.540]   I very strongly suspect that this premise is incorrect.
[02:11:18.540 --> 02:11:27.940]   Because if you think about it, for a complicated fancy neural net, figuring out how noisy something is, is very, very straightforward.
[02:11:27.940 --> 02:11:36.540]   So I very much doubt we actually need to pass in T. And as soon as you stop doing that,
[02:11:37.940 --> 02:11:44.060]   things stop looking like differential equations and they start looking more like optimizers.
[02:11:44.060 --> 02:11:49.740]   And so actually, Jono started playing with this and experimenting a bit.
[02:11:49.740 --> 02:11:58.020]   And early results suggest that, yeah, actually, when we re-think about the whole thing as being about learning rates and optimizers,
[02:11:58.020 --> 02:12:00.100]   maybe it actually works a bit better.
[02:12:00.100 --> 02:12:02.780]   In fact, there's all kinds of things we could do.
[02:12:03.940 --> 02:12:10.780]   Once we stop thinking about them as differential equations and worry about the math, don't worry about the math so much about Gaussians and whatever,
[02:12:10.780 --> 02:12:14.100]   we can really switch things around.
[02:12:14.100 --> 02:12:22.940]   So, for example, we decided for no particular obvious reason to use MSC.
[02:12:22.940 --> 02:12:32.020]   Well, the truth is in statistics and machine learning, almost every time you see somebody use MSC, it's because the math worked out better that way.
[02:12:32.820 --> 02:12:38.300]   Not as in it's a better thing to do, but as in, you know, it was kind of easier.
[02:12:38.300 --> 02:12:44.220]   Now, MSC does fall out quite nicely as being a good thing to do with some particular premises.
[02:12:44.220 --> 02:12:57.660]   You know, like it's not like totally arbitrary, but what if we instead used more sophisticated loss functions where we actually said, well,
[02:12:59.980 --> 02:13:08.740]   you know, after we subtract the outputs, how good is this really? Does it look like a digit or does it have the similar qualities to a digit?
[02:13:08.740 --> 02:13:14.300]   So we'll learn about this stuff, but there's things called, for example, perceptual loss.
[02:13:14.300 --> 02:13:20.020]   Or another question is,
[02:13:20.020 --> 02:13:23.180]   do we really need
[02:13:23.180 --> 02:13:29.660]   to do this thing where we actually put noise back at all?
[02:13:30.460 --> 02:13:32.860]   Could we instead use this directly?
[02:13:32.860 --> 02:13:37.180]   These are all things that suddenly become possible
[02:13:37.180 --> 02:13:44.860]   when we start thinking of this as an optimization problem rather than a differential equation solving problem.
[02:13:44.860 --> 02:13:54.820]   So for those of you who are interested in kind of doing novel research, this is some of the kind of stuff that we are starting to research at the moment.
[02:13:55.300 --> 02:14:05.100]   And the early results are extremely positive, both in terms of how quickly we can do things and what kind of outputs we seem to be getting.
[02:14:05.100 --> 02:14:13.220]   OK, so I think that's probably a good place to stop it.
[02:14:13.220 --> 02:14:20.740]   So what we're going to do in the next lesson is we're going to finish our journey into this notebook
[02:14:22.980 --> 02:14:28.860]   to see some of the code behind the scenes of what's in a pipeline when I get there.
[02:14:28.860 --> 02:14:36.940]   So we'll do looking inside the pipeline and see exactly what's going on behind the scenes a bit more in terms of the code.
[02:14:36.940 --> 02:14:39.540]   And then we're going to do a huge rewind
[02:14:39.540 --> 02:14:46.700]   to the from the foundations, and we're going to build up from some very tricky ground rules.
[02:14:46.700 --> 02:14:54.860]   Our ground rules would be we're only allowed to use pure Python, the Python standard library and nothing else
[02:14:54.860 --> 02:15:02.620]   and build up from there until we have recreated all of this and possibly
[02:15:02.620 --> 02:15:06.020]   some new research directions at the same time.
[02:15:06.020 --> 02:15:08.220]   So that's our goal.
[02:15:08.220 --> 02:15:11.740]   And so strap in and see you all next time.
[02:15:11.740 --> 02:15:13.740]   See ya.
[02:15:13.740 --> 02:15:23.740]   [BLANK_AUDIO]

