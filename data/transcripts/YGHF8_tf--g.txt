
[00:00:00.000 --> 00:00:08.180]   I'm very happy to end it off with a bang here with Andrew.
[00:00:08.180 --> 00:00:14.760]   So he's a research scientist at Meta's Gen AI team, focusing on media generation.
[00:00:14.760 --> 00:00:18.940]   Over the past few years, his team has focused on publishing research papers
[00:00:18.940 --> 00:00:22.860]   that push the frontiers of video generative models,
[00:00:22.860 --> 00:00:26.260]   including emu video as well as movie gen.
[00:00:27.160 --> 00:00:32.400]   Prior to working on Meta, Andrew completed his PhD at Oxford's Visual Geometry Group, VGG,
[00:00:32.400 --> 00:00:36.160]   under the supervision of Professor Andrew Zisserman.
[00:00:36.160 --> 00:00:39.780]   So without further ado, I'll hand it off to Andrew to take it.
[00:00:39.780 --> 00:00:41.160]   Yeah, thank you for that.
[00:00:41.160 --> 00:00:45.180]   Like the intro said, I'm Andrew Brown.
[00:00:45.180 --> 00:00:48.080]   I'm a researcher in Gen AI at MESA.
[00:00:48.080 --> 00:00:53.840]   If you guys haven't heard of that, Gen AI is the research organization that releases MESA's generative models,
[00:00:53.960 --> 00:01:00.260]   things like LAMA for the text LLMs and our media generation models as well.
[00:01:00.260 --> 00:01:05.340]   I've been there for about two and a half years, ever since I finished my PhD.
[00:01:05.340 --> 00:01:12.960]   And like Stephen said, over that period, we've released a bunch of frontier-pushing video generation models.
[00:01:13.700 --> 00:01:15.560]   So thank you so much for inviting me.
[00:01:15.560 --> 00:01:16.240]   I'm very honored.
[00:01:16.240 --> 00:01:17.020]   Thank you.
[00:01:17.020 --> 00:01:20.960]   And yeah, today's talk is Transformers for video generation.
[00:01:20.960 --> 00:01:27.180]   So I saw in the list of seminar speakers already you've had a bunch on NLP and some media generation stuff.
[00:01:27.180 --> 00:01:29.700]   I hope this is new compared to what you've heard already.
[00:01:32.280 --> 00:01:34.800]   Okay, so text-to-video models.
[00:01:34.800 --> 00:01:38.020]   You guys might have seen videos like this on the internet.
[00:01:38.020 --> 00:01:47.920]   But given a text prompt, contemporary text-to-video generation models can now create these incredibly high-quality videos.
[00:01:47.920 --> 00:01:52.360]   Complex motion, fantastical scenes, very high-quality.
[00:01:52.940 --> 00:01:54.360]   These things are amazing.
[00:01:54.360 --> 00:02:02.380]   Another example I quite like, this is a ghost in a white bedsheet.
[00:02:02.380 --> 00:02:04.440]   These things are amazing.
[00:02:04.440 --> 00:02:09.220]   Not only are they super high-quality, they seem to have learned some notion of the laws of physics.
[00:02:09.760 --> 00:02:15.220]   The thing I like about this one is if you look closely, you can see the reflection of the ghost is shown in the mirror there.
[00:02:15.220 --> 00:02:22.700]   So these models have clearly learned something very, like I was saying, if you look very closely, you can see this reflection of the ghost in the mirror.
[00:02:22.700 --> 00:02:23.480]   These things are amazing.
[00:02:23.480 --> 00:02:25.460]   And it doesn't stop there.
[00:02:25.460 --> 00:02:32.200]   So these text-to-video generation models can be used for other amazing capabilities as well, like editing.
[00:02:32.200 --> 00:02:43.780]   So, for example, you can give these models an input video, like on the top left, and specify some edit prompt, like turn the runner into an inflatable dinosaur or turn it into a cactus desert.
[00:02:43.780 --> 00:02:46.500]   These things are amazing.
[00:02:46.500 --> 00:02:54.540]   Now, I don't know how long a lot of you have been paying attention to the media generation field or even the machine learning field.
[00:02:54.540 --> 00:02:59.460]   But if you've been only paying attention for the last year, year and a half, this is all that you're used to.
[00:02:59.560 --> 00:03:04.100]   You're only used to seeing generated videos that are completely indistinguishable from real ones.
[00:03:04.100 --> 00:03:07.780]   But this is an incredibly recent development.
[00:03:07.780 --> 00:03:12.460]   So on the right here, I have the same video I showed you on the first slide.
[00:03:12.460 --> 00:03:15.400]   This is from a model that was released in October 2024.
[00:03:15.400 --> 00:03:21.800]   And on the left, I have what was an amazing states-of-the-art approach from September 2022.
[00:03:21.800 --> 00:03:24.900]   This is another model that was released by my team.
[00:03:26.200 --> 00:03:29.140]   And I can't stress enough how amazing this was at the time.
[00:03:29.140 --> 00:03:31.500]   And this gap, you'll see, is two years.
[00:03:31.500 --> 00:03:40.880]   I'm sure every speaker at this seminar has come in and said there's been, like, amazing progress in this machine learning subfield or that one.
[00:03:40.880 --> 00:03:42.500]   And there has been everywhere.
[00:03:42.500 --> 00:03:45.640]   But nowhere is it more clear than video generation.
[00:03:46.940 --> 00:03:49.760]   So how did this happen?
[00:03:49.760 --> 00:03:56.700]   This is what the subject of today's talk is going to be.
[00:03:56.700 --> 00:03:59.840]   How do we train models to generate videos like this?
[00:04:00.100 --> 00:04:07.880]   So all of the videos you saw in the previous slides are from a paper we released in October 2024 called MovieGen.
[00:04:07.880 --> 00:04:09.760]   Here's a little snapshot of the abstract.
[00:04:09.760 --> 00:04:18.660]   A little spoiler for how we did this and a spoiler for why I was invited to this is that we did it using transformers.
[00:04:19.040 --> 00:04:21.640]   I saw this little guy included in previous talks, so I had to put him there.
[00:04:21.640 --> 00:04:26.620]   So today's conclusions are going to be twofold.
[00:04:26.620 --> 00:04:33.860]   First, I'm going to talk you through every detail of how you train a transformer to generate videos like this.
[00:04:33.860 --> 00:04:35.820]   We publish all of the details.
[00:04:35.820 --> 00:04:36.960]   We're going to step through everything.
[00:04:36.960 --> 00:04:40.440]   Some of the concepts are going to be familiar, things like transformers.
[00:04:40.440 --> 00:04:41.680]   Some are going to be new.
[00:04:41.680 --> 00:04:42.820]   We're going to go through it all.
[00:04:43.280 --> 00:04:47.700]   The second takeaway is going to be this conclusion that I'll keep on saying.
[00:04:47.700 --> 00:04:56.420]   That throughout this project, we learned that scaling data, compute, and model parameters for a simple transformer also works for video generation.
[00:04:56.420 --> 00:04:59.740]   We've seen it work in all kinds of machine learning fields.
[00:04:59.740 --> 00:05:02.040]   We also saw it work here for video generation.
[00:05:02.040 --> 00:05:07.800]   Okay, so just a little bit of personal background.
[00:05:08.140 --> 00:05:13.460]   I think most of the speakers that you've had are from NLP, which makes sense because transformers came from NLP.
[00:05:13.460 --> 00:05:23.220]   I'm a computer vision researcher, and I've been in visual generation for a few years now, and it hasn't always been as popular as it is now.
[00:05:23.220 --> 00:05:33.460]   So how I got into this, I was sat in this lecture hall in the engineering department at Oxford in, what, the second year of my PhD,
[00:05:33.880 --> 00:05:40.620]   and we were having a talk by Professor Antonio Tarabla from MIT, and he was presenting this work called GAN dissection.
[00:05:40.620 --> 00:05:43.220]   Some of you may have heard of GANs.
[00:05:43.220 --> 00:05:47.860]   The state-of-the-art image generation approach at the time were these generative adversarial networks,
[00:05:47.860 --> 00:05:59.240]   and in 2019, you could generate like a blurry face or a blurry kitchen or a blurry bedroom, and that was amazing at the time.
[00:05:59.780 --> 00:06:05.960]   And this paper here was showing that you could activate or deactivate certain neurons in the GAN,
[00:06:05.960 --> 00:06:09.820]   and in doing so, you could make certain concepts appear or disappear.
[00:06:09.820 --> 00:06:14.340]   So these are the kind of images that we were generating at the time.
[00:06:14.340 --> 00:06:19.600]   So this is like a blurry kitchen, and this was like near state-of-the-art.
[00:06:19.600 --> 00:06:23.180]   So you can see, you know, the visual concepts are pretty messed up.
[00:06:23.560 --> 00:06:27.820]   It doesn't make a huge amount of sense, but I can't stress how, like, good this was at the time.
[00:06:27.820 --> 00:06:32.840]   I'm sure a lot of you have seen, like, Dolly and stable diffusion and so on.
[00:06:32.840 --> 00:06:35.060]   Things were not always this good.
[00:06:35.060 --> 00:06:40.360]   So the point of the paper, or at least in this example, was they were showing that you could activate certain neurons
[00:06:40.360 --> 00:06:42.560]   and make windows appear in the kitchen.
[00:06:42.680 --> 00:06:45.460]   You could imagine how your kitchen would look with windows.
[00:06:45.460 --> 00:06:48.060]   And the outcome was this.
[00:06:48.060 --> 00:06:52.580]   So some, like, pretty janky windows on the left.
[00:06:52.580 --> 00:06:58.620]   And my mind was completely blown, as I can sense, like, all of yours are as well.
[00:06:58.620 --> 00:07:01.480]   This was amazing.
[00:07:01.480 --> 00:07:08.180]   So what they showed here is not only that the model had learned a physically plausible place to put the windows,
[00:07:08.180 --> 00:07:12.340]   but importantly, they'd also shown that the model had learned some notion of physics.
[00:07:12.340 --> 00:07:16.280]   The model had learned that if you put windows on the left-hand side of the room,
[00:07:16.280 --> 00:07:20.140]   light will come through them, and there'll be a reflection of the marble countertop.
[00:07:20.140 --> 00:07:21.580]   And you can see that here.
[00:07:21.580 --> 00:07:24.960]   And the model had just learned this by looking at images.
[00:07:24.960 --> 00:07:29.520]   So this had, like, a really profound impact for me as a young PhD student,
[00:07:29.840 --> 00:07:32.920]   and I've been in visual generation ever since.
[00:07:32.920 --> 00:07:38.240]   Okay, so the body of the talk.
[00:07:38.240 --> 00:07:40.100]   There's going to be five parts.
[00:07:40.100 --> 00:07:43.600]   I'll give an overview of the model that we trained,
[00:07:43.600 --> 00:07:48.300]   talk about architecture, data, and training recipe results and applications,
[00:07:48.300 --> 00:07:50.720]   and a little discussion on what is next.
[00:07:50.720 --> 00:07:59.720]   So first, I included a bit of historical context on movie gen and video generation.
[00:07:59.720 --> 00:08:02.480]   Maybe some of you are quite new to the video generation field.
[00:08:02.480 --> 00:08:05.020]   The field is quite new inherently.
[00:08:05.020 --> 00:08:11.820]   This snapshot is maybe three years, from 2024 back to around 2022.
[00:08:11.820 --> 00:08:14.660]   This is a century in machine learning research.
[00:08:16.300 --> 00:08:18.380]   I haven't included all of the works here.
[00:08:18.380 --> 00:08:22.120]   There are some very relevant, important works here.
[00:08:22.120 --> 00:08:24.460]   I've just included a snapshot to make a couple of points.
[00:08:24.460 --> 00:08:29.660]   There have been two milestone events in video generation.
[00:08:30.360 --> 00:08:34.040]   The first was in 2022, when people started using diffusion modeling.
[00:08:34.040 --> 00:08:37.300]   This is when the whole community started using diffusion.
[00:08:37.300 --> 00:08:40.760]   That was a big step up in visual quality at that point.
[00:08:41.760 --> 00:08:46.020]   The second one was in 2024, and this is the point of today's talk.
[00:08:46.020 --> 00:08:52.220]   Before 2024, people were using quite small-scale, specialized architectures.
[00:08:52.220 --> 00:08:59.060]   I say small because the definition of small and large has been moving all over the place recently.
[00:08:59.060 --> 00:09:06.480]   But these were specialized architectures for computer vision, things like CNNs, UNETs, and so on.
[00:09:06.480 --> 00:09:13.760]   And then around 2024, video generation sort of boarded this architecture unification setup.
[00:09:13.760 --> 00:09:19.420]   So all over machine learning fields, we've seen people ditch specialized architectures
[00:09:19.420 --> 00:09:21.680]   and move towards this simple transformer setup.
[00:09:21.680 --> 00:09:28.500]   The reason is because all of these different fields are seeing the benefits of efficiency and scalability
[00:09:28.500 --> 00:09:30.060]   by moving to these transformers.
[00:09:30.060 --> 00:09:34.780]   So in 2024, the video generation community started doing the same,
[00:09:34.780 --> 00:09:38.660]   and that's where Movie Jam comes in, which I'll talk about today.
[00:09:38.660 --> 00:09:45.320]   So a quick overview on what Movie Jam is before we get into the details.
[00:09:45.320 --> 00:09:51.360]   So Movie Jam was a cast of foundation models that generates high-quality 1080p HD videos
[00:09:51.360 --> 00:09:53.740]   with different aspect ratios and synchronized audio.
[00:09:53.740 --> 00:09:56.460]   Today, I'm just going to be talking about the text-to-video model.
[00:09:56.460 --> 00:10:00.400]   I'll show some fun examples later of the other models that we trained.
[00:10:02.140 --> 00:10:07.900]   And again, like I've been saying, the point of the paper was showing that scaling data, training compute,
[00:10:07.900 --> 00:10:13.120]   and model parameters for a simple transformer trained with flow matching, I'll cover that later,
[00:10:13.120 --> 00:10:15.240]   yielded state-of-the-art results.
[00:10:15.240 --> 00:10:20.980]   We also presented a few sort of innovations and simplifications along the way.
[00:10:21.060 --> 00:10:30.400]   So Movie Jam video, the model, was a 30 billion parameter foundation model for joints, text-to-image, and text-to-video generation.
[00:10:30.400 --> 00:10:36.200]   The model was trained on the order of around 100 million videos and 1 billion images.
[00:10:40.020 --> 00:10:42.220]   Okay, so on to the architecture.
[00:10:42.220 --> 00:10:46.600]   There are three main things that I want to cover today.
[00:10:46.600 --> 00:10:49.320]   The first is the representation.
[00:10:49.320 --> 00:10:51.380]   What representation are we learning?
[00:10:51.380 --> 00:10:54.220]   The second is what learning objective that we used.
[00:10:54.220 --> 00:10:57.120]   And the third is what model architecture we used for learning it.
[00:10:58.280 --> 00:11:02.840]   If I do a good job here, then all of you will know all there is to know about video generation.
[00:11:02.840 --> 00:11:10.700]   I'm imagining most of you have more of a NLP background with sort of text-to-aggressive models.
[00:11:10.700 --> 00:11:18.380]   I'm going to try and contextualize all of this in relation to text and how it differs from large language models.
[00:11:21.620 --> 00:11:23.600]   Okay, so the representation.
[00:11:23.600 --> 00:11:25.600]   What do we mean by that?
[00:11:25.600 --> 00:11:28.940]   Well, we mean how are we going to represent the data for the model?
[00:11:28.940 --> 00:11:31.140]   We're doing generative modeling here.
[00:11:31.140 --> 00:11:32.200]   We're learning P of X.
[00:11:32.200 --> 00:11:34.580]   The question here is what should X be?
[00:11:34.580 --> 00:11:41.220]   We know that X is going to be derived in some way from videos, but there's an open question of how exactly do we do that.
[00:11:41.220 --> 00:11:51.540]   So to motivate what we ended up doing, I'm just going to talk a bit about the differences between text and media.
[00:11:51.540 --> 00:11:55.220]   So let's look at some text data, for example.
[00:11:55.220 --> 00:11:59.500]   And this piece of data, a sentence, an image of a cat.
[00:11:59.500 --> 00:12:15.620]   What has happened when this data sample has been created is a human has put in a huge amount of thought into compressing what they're thinking into this very well-designed, semantically rich language.
[00:12:15.620 --> 00:12:17.620]   It's very compressed.
[00:12:17.620 --> 00:12:19.660]   Every word packs a huge amount of information.
[00:12:20.380 --> 00:12:22.280]   And it's also inherently discrete.
[00:12:22.280 --> 00:12:28.320]   So in practice, when people are training large language models, they can use a representation that's quite close to this.
[00:12:28.320 --> 00:12:33.620]   So they might use a sort of simple tokenizer before feeding it into the transformer.
[00:12:33.620 --> 00:12:38.140]   Media data is incredibly different to this.
[00:12:38.380 --> 00:12:42.340]   So let's look at a related piece of data, an actual image of a cat.
[00:12:42.340 --> 00:12:46.620]   No compression has really occurred here.
[00:12:46.620 --> 00:12:50.580]   This image is just continuous raw data that's been captured by your camera.
[00:12:50.580 --> 00:13:00.100]   Maybe the only sort of human effort that's gone into this is positioning the camera and framing the cat in the middle of the camera, but nothing else.
[00:13:00.880 --> 00:13:03.080]   As a result of this, there's tons of redundancy.
[00:13:03.080 --> 00:13:13.340]   So what I mean by this is if you know what a cat is, and then let's say the middle pixel you know is this white fur on the cat.
[00:13:13.340 --> 00:13:19.500]   Well, if you know what a cat is, you know the next pixel along is probably going to be white fur and the next one along from that.
[00:13:19.500 --> 00:13:25.140]   And if it's a video, you know the same pixels one frame along are also going to be white cat fur.
[00:13:25.140 --> 00:13:26.760]   There's a huge amount of redundancy.
[00:13:26.760 --> 00:13:34.980]   So this begs the question of perhaps this raw data could be transformed into something that more closely resembles language.
[00:13:34.980 --> 00:13:39.400]   So what do we actually do?
[00:13:39.400 --> 00:13:47.140]   So if you forget everything that I just said on the previous slide, one thing you could do, a very simple approach, is you just model the pixels directly.
[00:13:48.000 --> 00:13:56.860]   So let's say you took an image or a video, you unraveled it into a long sequence of pixels, and then trained, let's say, next token prediction on that.
[00:13:56.860 --> 00:13:59.800]   And in a way, that's what some prior works did.
[00:13:59.800 --> 00:14:05.240]   Things like imagine video or image GPT back in the day, along with a little bit of patching.
[00:14:05.240 --> 00:14:13.640]   So this is a very sort of conceptually simple method, but it's very computationally constraining.
[00:14:14.520 --> 00:14:22.440]   So the thing about modeling pixels directly is the number of pixels scales quadrastically with the image or video resolution.
[00:14:22.440 --> 00:14:24.540]   It's bad for images.
[00:14:24.540 --> 00:14:27.120]   It's even worse for video when you have a temporal dimension.
[00:14:27.860 --> 00:14:37.760]   In practice, what this means is these models can only model very low-resolution images or videos, things like 64 by 64 videos, which is not ideal.
[00:14:37.760 --> 00:14:51.880]   And if we want to generate an actual large HD video, these methods had to employ a huge cascade of upsampling stages, things like super-resolution models, frame interpolation models, to increase the size of the data.
[00:14:52.400 --> 00:14:54.400]   So this really isn't ideal.
[00:14:54.400 --> 00:15:05.740]   So instead, what prior work does is they learn a compressed latent representation using something like a VAE or a VQVAE trained offline.
[00:15:07.120 --> 00:15:13.460]   This is what every sort of text-to-image model or text-to-video model you've seen on social media has been doing for a long time.
[00:15:13.460 --> 00:15:16.140]   The advantages here are twofold.
[00:15:16.140 --> 00:15:22.760]   If you're modeling a compressed version of your data, then you can natively model larger data.
[00:15:22.760 --> 00:15:24.960]   We don't need to go down to 64 by 64.
[00:15:24.960 --> 00:15:26.560]   We can natively model something bigger.
[00:15:27.140 --> 00:15:35.560]   The other advantage is that this offline-trained VAE or VQVAE can remove some of the computational burden from the language model.
[00:15:35.560 --> 00:15:44.920]   For example, these autoencoders could handle the modeling of how two separate blades of grass differ from each other in an image or a video.
[00:15:44.920 --> 00:15:48.740]   And it can take that burden off the sort of downstream language model.
[00:15:50.760 --> 00:15:53.600]   Okay, so that is what we do.
[00:15:53.600 --> 00:16:02.640]   From an architecture, we train something called a temporal autoencoder for spatial-temporal video compression.
[00:16:02.640 --> 00:16:06.100]   This is basically just a variational autoencoder.
[00:16:06.100 --> 00:16:08.520]   How does this work?
[00:16:08.520 --> 00:16:10.320]   Well, you take a video.
[00:16:10.320 --> 00:16:13.360]   You'll feed it through the TAE encoder.
[00:16:13.360 --> 00:16:15.680]   A VAE consists of an encoder and a decoder.
[00:16:16.600 --> 00:16:24.300]   After the encoder, the representation will be compressed, and you end up with this latent representation at the bottleneck in the middle.
[00:16:24.300 --> 00:16:28.440]   And this is the representation that we're going to use downstream.
[00:16:28.440 --> 00:16:32.060]   How you train these things is quite simple.
[00:16:32.060 --> 00:16:33.220]   Some of you may have seen it before.
[00:16:33.220 --> 00:16:34.020]   You take your video.
[00:16:34.020 --> 00:16:35.140]   You feed it through the encoder.
[00:16:35.140 --> 00:16:37.920]   You get to the bottleneck latent representation.
[00:16:37.920 --> 00:16:40.560]   You then decode it back to pixel space.
[00:16:40.760 --> 00:16:48.260]   And you have a bunch of losses between the output and the input, things like L1 losses, adversarial losses, and so on.
[00:16:48.260 --> 00:16:52.540]   So this representation in the middle is what we're going to model.
[00:16:52.540 --> 00:16:57.920]   When we talk about learning P of X, we're learning the distribution of this latent.
[00:16:57.920 --> 00:17:03.280]   What this means is when we train a generative model on this, it generates in this space.
[00:17:03.280 --> 00:17:05.160]   It doesn't generate in RGB space.
[00:17:05.300 --> 00:17:10.140]   So after we generate a video, we then need to decode it back to RGB space.
[00:17:10.140 --> 00:17:18.580]   So the TAE that we trained had 8x compression in each dimension.
[00:17:18.580 --> 00:17:21.280]   8x in height, width, and time.
[00:17:21.280 --> 00:17:25.880]   And this was pretty high compression at the time.
[00:17:27.040 --> 00:17:29.140]   It's not the highest compression anymore.
[00:17:29.140 --> 00:17:31.600]   This was published like six months ago.
[00:17:31.600 --> 00:17:35.340]   And six months is, again, like a decade in machine learning research.
[00:17:35.340 --> 00:17:36.900]   But at the time, this was very high compression.
[00:17:36.900 --> 00:17:42.580]   And like I said, this means that we can natively model very high-resolution videos.
[00:17:42.580 --> 00:17:52.880]   As an example, the largest video that we model in this work is 768x768 pixels, 16 seconds, 16 FPS.
[00:17:54.080 --> 00:18:06.980]   Now, if we were to model pixels directly, and we took a video of that size, we unraveled everything, we treated one pixel as one token, and we flattened the whole thing, it would result in 150 million tokens.
[00:18:06.980 --> 00:18:14.340]   Even with very long context training methods with language models at the moment, this is completely unfeasible.
[00:18:15.460 --> 00:18:22.680]   But using this temporal autoencoder, the same video is just compressed to 73,000 tokens.
[00:18:22.680 --> 00:18:30.780]   So this is suddenly completely computationally feasible using like today's parallelism approaches, today's infrastructure.
[00:18:32.220 --> 00:18:38.660]   If anyone is doing this math offline, there is also a patch of high layer, if someone thinks my math is wrong here.
[00:18:38.660 --> 00:18:44.180]   Okay, so that's everything for the representation.
[00:18:44.180 --> 00:18:46.780]   Does anyone have any questions at this point?
[00:18:46.780 --> 00:18:53.140]   No.
[00:18:54.960 --> 00:18:56.180]   It's a great point.
[00:18:56.180 --> 00:19:02.260]   A lot of autoencoders for videos do use causality.
[00:19:02.260 --> 00:19:14.700]   Some nice outcomes of that is that when you encode images, they can be encoded completely independently of subsequent frames and so on.
[00:19:14.700 --> 00:19:15.880]   But no, this isn't causal.
[00:19:18.960 --> 00:19:24.020]   Okay, so next up is which generative modeling learning objective do we use?
[00:19:24.020 --> 00:19:30.720]   So probably in most of the talks that you've had so far, you've heard about autoregression and next token prediction for text.
[00:19:30.720 --> 00:19:36.620]   In media generation, we haven't been doing that for a couple of years.
[00:19:36.620 --> 00:19:41.320]   So the de facto approach in most media generation has been using diffusion modeling.
[00:19:41.320 --> 00:19:44.780]   We use something called flow matching.
[00:19:48.620 --> 00:19:50.940]   So what is flow matching?
[00:19:50.940 --> 00:19:57.580]   Flow matching is, in a way, a simpler generalization of diffusion.
[00:19:57.580 --> 00:20:07.440]   Now, if any of you have watched a talk on diffusion modeling or read anything about diffusion or flow matching, I'm sure you've seen a figure like this before.
[00:20:07.440 --> 00:20:13.380]   I'm going to give a brief sort of explainer of what is similar between flow matching and diffusion.
[00:20:13.380 --> 00:20:16.780]   And then we're going to go over what a training step looks like.
[00:20:17.660 --> 00:20:22.360]   So both diffusion and flow matching have a very similar setup.
[00:20:22.360 --> 00:20:26.280]   So you assume that you have some unknown data distribution.
[00:20:26.280 --> 00:20:29.000]   This is the sort of distribution of images in this figure.
[00:20:29.000 --> 00:20:30.920]   In this case, like images of cats.
[00:20:33.040 --> 00:20:34.780]   This is the distribution you're trying to learn.
[00:20:34.780 --> 00:20:37.700]   This is the distribution we want to learn and then sample from.
[00:20:37.700 --> 00:20:42.820]   You also assume you have a known data distribution on the right.
[00:20:42.820 --> 00:20:46.060]   And we model this as normally just like Gaussian noise.
[00:20:48.240 --> 00:20:51.720]   Both assume then that we have this fixed forward process.
[00:20:51.720 --> 00:21:00.500]   What this means is we have a method of translating between the unknown data distribution and the known one by iteratively adding noise.
[00:21:00.500 --> 00:21:06.800]   Both assume that if you keep on adding noise, you basically end up at this known data distribution.
[00:21:08.400 --> 00:21:12.380]   Then both of them train a neural network to do the reverse process.
[00:21:12.380 --> 00:21:17.740]   So they train a neural network to take one of these images and iteratively denoise those.
[00:21:17.740 --> 00:21:27.140]   And then at inference time, you can iteratively use this neural network to go from a sample that's pure noise back to a sample from this data distribution that you've just learned.
[00:21:27.600 --> 00:21:30.880]   And that's how we end up sampling images and videos.
[00:21:30.880 --> 00:21:35.760]   So diffusion and flow matching are very similar in a lot of ways.
[00:21:35.760 --> 00:21:39.040]   Flow matching is, in a way, a simpler generalization.
[00:21:39.040 --> 00:21:47.920]   It's been very recently shown to result in more robust training and more efficient probability paths that are easier and faster to sample from.
[00:21:47.920 --> 00:21:53.740]   So this paper came out pretty recently in 2023 from some colleagues at Massa.
[00:21:56.820 --> 00:21:59.380]   Importantly, it's been shown to work better than diffusion.
[00:21:59.380 --> 00:22:07.920]   And I'm not going to go into a huge amount of detail here, but we're going to go over how a training step looks like.
[00:22:07.920 --> 00:22:11.520]   So there are lots of equations here.
[00:22:11.520 --> 00:22:12.940]   We're going to step through them pretty easily.
[00:22:12.940 --> 00:22:15.520]   It's a three-step process.
[00:22:15.520 --> 00:22:19.600]   We first take a training data sample, X1.
[00:22:19.600 --> 00:22:23.100]   This is your image of a cat on the previous slide.
[00:22:23.100 --> 00:22:24.620]   This is just an image from your data set.
[00:22:25.780 --> 00:22:27.480]   We then sample a time step.
[00:22:27.480 --> 00:22:29.340]   This is a float between zero and one.
[00:22:29.340 --> 00:22:31.940]   And we sample from the known data distribution.
[00:22:31.940 --> 00:22:35.140]   This just means taking a sample from a normal Gaussian.
[00:22:35.140 --> 00:22:39.680]   We then construct a training sample, Xt.
[00:22:39.680 --> 00:22:41.140]   What is this?
[00:22:41.140 --> 00:22:45.840]   This is just this sort of intermediate image, a somewhat noise image of a cat.
[00:22:47.440 --> 00:22:50.440]   There are lots of different ways of constructing Xt.
[00:22:50.440 --> 00:22:55.460]   We use what's called the simple linear interpolation from the flow matching paper.
[00:22:55.460 --> 00:22:56.900]   And the equation is shown here.
[00:22:56.900 --> 00:23:02.460]   So this is how we go from the three things we sampled above to this intermediate training sample.
[00:23:02.460 --> 00:23:07.380]   Then in flow matching, what you do is you train the model to predict the velocity.
[00:23:08.220 --> 00:23:12.360]   This is a value which moves the training sample back in the direction of the data sample.
[00:23:14.680 --> 00:23:16.160]   In actuality, it's very simple.
[00:23:16.160 --> 00:23:21.100]   So this is how we compute the velocity, simply by differentiating the equation above.
[00:23:21.100 --> 00:23:23.060]   This is how we get our ground truth.
[00:23:23.060 --> 00:23:26.180]   And then on the right, we have our actual learning objective.
[00:23:26.180 --> 00:23:30.560]   So this is the mean squared error between the model prediction and the ground truth velocity.
[00:23:31.300 --> 00:23:34.960]   Here, the model prediction is parametrized by U.
[00:23:34.960 --> 00:23:37.900]   It takes as input the training sample.
[00:23:37.900 --> 00:23:39.980]   It's conditioned on two things.
[00:23:39.980 --> 00:23:42.340]   It's conditioned on the text prompt.
[00:23:42.340 --> 00:23:42.880]   That's P.
[00:23:42.880 --> 00:23:44.840]   Remember, we're doing text to video generation.
[00:23:44.840 --> 00:23:47.520]   So we need to condition the generation on the text prompt.
[00:23:47.520 --> 00:23:49.400]   I'll cover later how we do this.
[00:23:49.400 --> 00:23:52.100]   You condition on the time step as well.
[00:23:52.100 --> 00:23:54.580]   And then theta are the model parameters.
[00:23:54.580 --> 00:23:58.740]   Okay, you know how to do flow matching.
[00:24:01.220 --> 00:24:03.080]   Inference is also pretty simple.
[00:24:03.080 --> 00:24:07.020]   So you start by sampling from this known data distribution, Gaussian noise.
[00:24:07.020 --> 00:24:13.180]   And then we use an ordinary differential equation solver to go back to the data distribution,
[00:24:13.180 --> 00:24:15.240]   given a series of time steps.
[00:24:15.240 --> 00:24:18.160]   So very simply, you'll sample some noise.
[00:24:18.160 --> 00:24:19.900]   You'll sample a stream of time steps.
[00:24:19.900 --> 00:24:23.660]   At each time step, you compute the model's prediction for the velocity
[00:24:23.660 --> 00:24:28.880]   and use the solver to move the sample in the direction of the unknown data distribution.
[00:24:29.820 --> 00:24:32.660]   And at the end of that, you have your sample.
[00:24:32.660 --> 00:24:38.420]   Low-level detail, we use a quite simple solver.
[00:24:38.420 --> 00:24:40.420]   There are lots of different options you can choose.
[00:24:43.620 --> 00:24:49.960]   Okay, so lastly, which model architecture do we use?
[00:24:49.960 --> 00:24:54.400]   Now, I already said that we're using transformers.
[00:24:54.400 --> 00:25:01.080]   The big goal of this paper was to benefit from, like I've said about seven times already,
[00:25:01.080 --> 00:25:05.400]   scaling data, training compute, and model parameters with transformers.
[00:25:05.760 --> 00:25:07.920]   But there is a question about which transformer to use.
[00:25:07.920 --> 00:25:14.380]   So, in my research organization, we train these things called LAMAs.
[00:25:14.380 --> 00:25:19.480]   LAMA is the large language model that messes open sources.
[00:25:19.480 --> 00:25:25.000]   We take the LAMA3 model, hence why I sort of pasted this L3 on it.
[00:25:25.840 --> 00:25:32.160]   LAMA3 is quite a classic, dense, fully connected, decoder-only language model.
[00:25:34.480 --> 00:25:40.840]   So, what we did in MovieGen is you take your videos, you encode them with the TAE that we discussed earlier,
[00:25:40.840 --> 00:25:46.180]   you flatten the tokens, this gives you your input sequence, and we just throw it into LAMA.
[00:25:46.180 --> 00:25:48.680]   So, very, very simple.
[00:25:51.980 --> 00:25:56.400]   Now, when I say LAMA, I don't mean a pre-trained LAMA.
[00:25:56.400 --> 00:25:59.320]   I don't mean one that's been trained for text.
[00:25:59.320 --> 00:26:04.740]   What I mean is the architecture, so a randomly initialized architecture.
[00:26:04.740 --> 00:26:07.320]   But this is still very important.
[00:26:07.320 --> 00:26:12.180]   Training large language models at scale is incredibly difficult.
[00:26:12.180 --> 00:26:18.860]   Every time you change anything about the architecture, you need different hyper-premises, they scale differently.
[00:26:18.860 --> 00:26:20.480]   It's incredibly tricky.
[00:26:21.320 --> 00:26:27.340]   So, the fact that we already know, in our research organization, how to scale this architecture,
[00:26:27.340 --> 00:26:32.440]   and the fact that we have the infra set up already to train these things at scale, makes a huge difference.
[00:26:32.440 --> 00:26:36.780]   So, that's why the simplest thing for us to do was to go with the LAMA architecture.
[00:26:36.780 --> 00:26:46.640]   We didn't do that for this project.
[00:26:46.640 --> 00:26:48.700]   But I agree, that would be a really cool thing to try.
[00:26:50.660 --> 00:27:00.040]   Yeah, it's not entirely clear why that would work.
[00:27:00.040 --> 00:27:04.400]   Obviously, like, these are very different modalities, different learning objectives.
[00:27:04.400 --> 00:27:14.040]   But, you know, in a lot of ways, there's a lot of sort of shared structure between these modalities that would maybe benefit from that.
[00:27:17.640 --> 00:27:21.940]   Okay, so that last slide was, like, very deceptively oversimplified.
[00:27:23.220 --> 00:27:25.720]   There are some changes that we needed to make to LAMA 3.
[00:27:25.720 --> 00:27:33.320]   So, importantly, LAMA 3 is a model for auto-aggressive text generation, and we are doing text-to-video generation using flow matching.
[00:27:33.320 --> 00:27:35.020]   So, there are three changes that we need to make.
[00:27:35.020 --> 00:27:40.620]   I'm going to go over all of them exhaustively to sort of hammer the point that we barely changed the architecture.
[00:27:43.720 --> 00:27:46.560]   So, the first thing that we need to do is incorporate the text conditioning.
[00:27:46.560 --> 00:27:51.000]   You'll have seen on the previous slide that our input sequence is just made up of video tokens.
[00:27:51.000 --> 00:27:56.180]   We're doing text-to-video generation, so we need to incorporate the text conditioning somehow.
[00:27:56.620 --> 00:28:00.760]   And we do this using cross-attention layers.
[00:28:00.760 --> 00:28:09.200]   So, very simply, we construct a sequence made up of our text conditioning, and we add cross-attention layers into the transformer block.
[00:28:09.200 --> 00:28:12.640]   So, these go between the self-attention layers and the feedforward network.
[00:28:12.640 --> 00:28:17.920]   It's a very common way of adding text conditioning for media generation models.
[00:28:17.920 --> 00:28:25.120]   There is a question, as well, of what should your text representation be?
[00:28:25.120 --> 00:28:27.000]   How should you construct this sequence?
[00:28:27.000 --> 00:28:35.000]   One, like, very simple thing to do would be you just tokenize the prompt, the caption, and then you feed that in.
[00:28:35.620 --> 00:28:41.140]   But when you do that, you're very much burdening your model with learning this text representation from scratch.
[00:28:41.140 --> 00:28:44.220]   So, instead, we use pre-trained text representations.
[00:28:44.220 --> 00:28:47.760]   We use three, in fact.
[00:28:47.760 --> 00:28:50.120]   Three that are complementary to each other.
[00:28:50.120 --> 00:28:54.500]   The first two, all of them are pre-trained frozen text models, basically.
[00:28:54.500 --> 00:28:58.520]   The first two have very sort of semantic level representations.
[00:28:58.520 --> 00:29:01.620]   UL2 is a large-scale encoder-decoder model.
[00:29:01.620 --> 00:29:04.260]   Metaclip is our internal clip model.
[00:29:04.940 --> 00:29:10.720]   And the third one has more of a sort of character-level text representation by T5.
[00:29:10.720 --> 00:29:15.940]   So, we encode the text prompt using all three of these.
[00:29:15.940 --> 00:29:22.860]   We project them all to the model dimension, and we concatenate, and that gives us our text sequence.
[00:29:25.860 --> 00:29:31.320]   The second thing we need to do, you'll remember from the learning objective, that we also need to condition on the time step.
[00:29:33.780 --> 00:29:36.900]   So, what we do here is we do this in adaptive layer norm blocks.
[00:29:36.900 --> 00:29:39.300]   So, we've already added a cross-attention block.
[00:29:39.300 --> 00:29:41.180]   We also add this adaptive layer norm block.
[00:29:41.180 --> 00:29:46.300]   This might seem like quite a strange way of adding some conditioning.
[00:29:46.780 --> 00:29:56.120]   It's something that was popularized in the diffusion transformer paper, which was the first paper that used diffusion with transformers, obviously, by the name.
[00:29:58.060 --> 00:29:59.500]   It might seem a little bit random.
[00:29:59.500 --> 00:30:02.660]   It's basically very computationally cheap, and works super well.
[00:30:02.660 --> 00:30:06.220]   Okay, number three.
[00:30:06.220 --> 00:30:07.280]   There are only three.
[00:30:08.960 --> 00:30:10.900]   We use full bidirectional attention.
[00:30:10.900 --> 00:30:14.920]   LLAMA is an auto-aggressive text model.
[00:30:14.920 --> 00:30:17.180]   They use causal masking for next token prediction.
[00:30:17.180 --> 00:30:21.220]   For the flow matching objective, we have no such constraints.
[00:30:21.220 --> 00:30:24.260]   We want every video token to see every other video token.
[00:30:24.260 --> 00:30:27.440]   We don't care about causal masking, so we take that out.
[00:30:27.440 --> 00:30:34.080]   A very low-level detail is that because of this, we use multi-head attention instead of groups query attention.
[00:30:34.080 --> 00:30:35.360]   But that's everything.
[00:30:35.360 --> 00:30:37.000]   Other than that, it's the LLAMA architecture.
[00:30:37.000 --> 00:30:44.740]   Okay, so we now have our full architecture diagram.
[00:30:44.740 --> 00:30:50.680]   I was very wary of putting this earlier because it's pretty complicated, but I think it should all make sense at this point.
[00:30:50.680 --> 00:30:56.780]   So from left to right, during training, we take one of our training videos.
[00:30:56.780 --> 00:31:00.900]   We encode it with the TAE to get to our compressed latent representation.
[00:31:00.900 --> 00:31:02.780]   It goes through a small Petrify.
[00:31:02.780 --> 00:31:04.620]   This just does some extra compression.
[00:31:05.520 --> 00:31:09.040]   And we flatten it, and that's how we get our input sequence.
[00:31:09.040 --> 00:31:15.840]   During training, we'll construct our training sample by combining it with this Gaussian noise.
[00:31:15.840 --> 00:31:19.680]   During inference, this whole sequence will start off being Gaussian noise.
[00:31:20.880 --> 00:31:24.480]   The sequence goes through these LLAMA transformer blocks.
[00:31:24.480 --> 00:31:29.680]   We add in the conditioning, and then we get our output sequence.
[00:31:29.680 --> 00:31:32.960]   During training, we'd compute our loss and backpropagate.
[00:31:32.960 --> 00:31:39.760]   During inference, we would do this iterative denoising process, and finally decode back to the RGB space.
[00:31:40.000 --> 00:31:45.680]   Any questions on the architecture?
[00:31:45.680 --> 00:31:45.680]   Any questions on the architecture?
[00:31:50.880 --> 00:32:08.620]   So, at inference for a given text prompt, we add this conditioning into the model always.
[00:32:08.620 --> 00:32:13.020]   So the input sequence is just Gaussian noise, but that's not where the text information comes in.
[00:32:13.020 --> 00:32:15.860]   The text information comes in through these cross-attention layers.
[00:32:16.400 --> 00:32:22.380]   So even though the input sequence is just noise, the model is still seeing these clean text information.
[00:32:22.380 --> 00:32:24.300]   We don't noise the text or anything like that.
[00:32:24.300 --> 00:32:26.620]   Does that make sense?
[00:32:26.620 --> 00:32:55.460]   That's just a hyperbrameter that we keep constant.
[00:32:55.460 --> 00:33:01.620]   I cannot remember off the top of my head exactly what that hyperparameter is for, actually.
[00:33:01.620 --> 00:33:03.840]   I'm going to talk to you about that after.
[00:33:03.840 --> 00:33:06.640]   The next question is, how many of you know these steps?
[00:33:06.640 --> 00:33:07.660]   Yeah.
[00:33:07.660 --> 00:33:08.920]   Is it typically required?
[00:33:08.920 --> 00:33:09.160]   Yeah.
[00:33:09.160 --> 00:33:13.360]   So, it's a very good point.
[00:33:13.360 --> 00:33:16.280]   So, during inference, you'll sample a series of time steps.
[00:33:16.280 --> 00:33:20.440]   Usually, with these flow-based models, the more you sample, the better.
[00:33:20.440 --> 00:33:22.680]   You'll better approximate these probability paths.
[00:33:22.680 --> 00:33:26.000]   In practice, we use 250, I think.
[00:33:26.000 --> 00:33:31.380]   One of the advantages of flow matching is that the probability paths are theoretically straighter.
[00:33:31.380 --> 00:33:37.420]   So, you should be able to require less function evaluations to approximate this path.
[00:33:37.420 --> 00:33:38.920]   That's one of the advantages.
[00:33:38.920 --> 00:33:48.240]   And is it 250, like, so, is it not a pre-described number of Ts during training?
[00:33:49.180 --> 00:33:49.960]   Yeah, that's continuous.
[00:33:49.960 --> 00:33:50.840]   Yeah.
[00:33:50.840 --> 00:33:54.660]   But during inference, it's, we just sample some discrete ones.
[00:33:54.660 --> 00:33:55.820]   Yeah.
[00:33:55.820 --> 00:33:57.080]   Thank you.
[00:33:57.080 --> 00:33:58.560]   So, I have a question.
[00:33:58.560 --> 00:34:05.380]   On the two videos that you show the difference between 2022 and 2024, was the improvement just
[00:34:05.380 --> 00:34:10.780]   algorithmic what you used with the hardware in terms of TPUs, or it was just a pure algorithm?
[00:34:10.780 --> 00:34:17.080]   So, I think everything comes down to scale.
[00:34:17.080 --> 00:34:20.720]   There are quite a lot of things that have changed.
[00:34:20.720 --> 00:34:25.000]   There's an architecture change moving towards transformers, and then there's the scale.
[00:34:25.000 --> 00:34:27.360]   And that includes a whole load of things.
[00:34:27.360 --> 00:34:39.440]   Scaling the data, scaling the amount of compute, in order for that to be, like, tractable, better, like, GPU hardware, it does help.
[00:34:39.440 --> 00:34:42.260]   There wasn't a huge improvement in GPU hardware over those two years.
[00:34:42.260 --> 00:34:46.860]   It might have been one or two generations of NVIDIA's stuff.
[00:34:46.860 --> 00:34:48.140]   Yeah.
[00:34:48.140 --> 00:34:51.220]   Okay.
[00:34:51.220 --> 00:34:55.840]   Okay.
[00:34:55.840 --> 00:34:59.760]   So, now we have an architecture that we're pretty confident scales.
[00:34:59.760 --> 00:35:00.580]   Longer.
[00:35:00.580 --> 00:35:04.640]   We have a learning objective that we think should work in flow matching.
[00:35:04.640 --> 00:35:07.280]   That's pretty much it for the details.
[00:35:07.280 --> 00:35:08.700]   It's not the entire story.
[00:35:08.700 --> 00:35:10.680]   But that's a lot of it.
[00:35:10.680 --> 00:35:14.260]   Okay.
[00:35:14.260 --> 00:35:19.660]   So, the last technical details are about data and the training recipe.
[00:35:19.660 --> 00:35:22.520]   So, data.
[00:35:22.520 --> 00:35:29.260]   I think in a lot of ways, this is the most important slide of the entire talk today.
[00:35:29.260 --> 00:35:33.820]   Data is so important for training large language models.
[00:35:33.820 --> 00:35:38.540]   And, by the way, when I say large language models, I'm sort of just talking about transformers at scale for any modality.
[00:35:38.540 --> 00:35:41.000]   People use, like, different definitions there.
[00:35:43.780 --> 00:35:47.260]   But these models are incredibly data-hungry.
[00:35:47.260 --> 00:35:49.100]   They require internet-scale data.
[00:35:49.100 --> 00:35:51.680]   And they require the data to be clean.
[00:35:51.680 --> 00:35:55.400]   The scaling laws depend on the data being clean.
[00:35:55.400 --> 00:35:56.980]   Otherwise, the scaling laws don't hold.
[00:35:58.040 --> 00:36:01.060]   And the model output quality depends on the data being clean.
[00:36:01.060 --> 00:36:08.800]   As a result of this, research groups at these big companies spend a huge amount of resources on data.
[00:36:08.800 --> 00:36:11.800]   This is something that I find isn't really talked about so much.
[00:36:12.380 --> 00:36:16.760]   But they'll spend huge amounts of resources in terms of GPUs and also actual researchers.
[00:36:16.760 --> 00:36:22.880]   Often, on these research teams, the data teams massively outnumber the modeling teams.
[00:36:22.880 --> 00:36:28.180]   Which was something very new to me after my little PhD.
[00:36:30.620 --> 00:36:31.640]   So, why is this?
[00:36:31.640 --> 00:36:35.540]   Well, you know, remember we're training generative models.
[00:36:35.540 --> 00:36:39.840]   We are learning this distribution of our training data.
[00:36:39.840 --> 00:36:43.960]   And then we're sampling videos from it that are likely according to that training data.
[00:36:43.960 --> 00:36:48.720]   So, if we want to sample the kinds of videos that I showed you on the first two slides,
[00:36:48.720 --> 00:36:51.560]   then all of our training data needs to look like that.
[00:36:54.900 --> 00:36:56.660]   I'm mainly talking about pre-training here.
[00:36:56.660 --> 00:37:03.060]   You obviously have a post-training phase as well where you can align your videos to be more high-quality perhaps.
[00:37:03.060 --> 00:37:05.440]   But your pre-training data still needs to look great.
[00:37:05.440 --> 00:37:09.500]   So, this is a huge challenge.
[00:37:09.500 --> 00:37:14.020]   We trained the model on the order of around 100 million videos.
[00:37:14.020 --> 00:37:16.480]   How do we get to this number?
[00:37:16.480 --> 00:37:20.920]   Well, we can predict a sort of training budget that we had for this project.
[00:37:20.920 --> 00:37:24.720]   And you want as many videos as you can that you don't epoch.
[00:37:24.720 --> 00:37:25.360]   Thank you very much.
[00:37:25.360 --> 00:37:29.800]   So, the challenge was how to get this many videos that are high enough quality.
[00:37:29.800 --> 00:37:36.140]   At the time of MovieGen, we constructed this incredibly detailed complex pipeline
[00:37:36.140 --> 00:37:40.900]   with a bunch of handcrafted and model-based filters.
[00:37:40.900 --> 00:37:46.460]   I'll just talk through a few bits of it because of the sheer amount of work that went into this.
[00:37:47.500 --> 00:37:53.640]   So, you start with a large pool of videos from some corpus.
[00:37:53.640 --> 00:37:57.040]   They may be different lengths, long tail of concepts.
[00:37:57.040 --> 00:38:03.780]   We did a bunch of visual filtering on these, removing videos that are too small, scene changes, bad aesthetics.
[00:38:04.940 --> 00:38:07.880]   We removed a bunch of videos that have bad motion.
[00:38:07.880 --> 00:38:15.840]   It turns out a bunch of videos in any large corpus have really slow motion, janky motion, motion effects.
[00:38:15.840 --> 00:38:17.000]   We removed all of those.
[00:38:18.080 --> 00:38:23.580]   We then did a content filtering step.
[00:38:23.580 --> 00:38:25.160]   This is first deduplication.
[00:38:25.160 --> 00:38:27.500]   But the really important one here is resampling.
[00:38:27.500 --> 00:38:35.120]   Large language models do not work well when they're trained on a very imbalanced data set in terms of concepts.
[00:38:35.120 --> 00:38:36.500]   So, something with a very long tail.
[00:38:37.140 --> 00:38:41.480]   They work best if the concept distribution is roughly, roughly uniform.
[00:38:41.480 --> 00:38:47.320]   And that uniformity doesn't occur if you just take a random set of videos.
[00:38:47.320 --> 00:38:56.280]   So, we do this very sort of complex visual concept extraction, clustering, the upweights, certain clusters, downweights, certain clusters.
[00:38:56.280 --> 00:39:00.420]   This, all of this will give us a set of videos.
[00:39:00.420 --> 00:39:04.320]   We also need captions because we're doing text-to-video generation.
[00:39:04.320 --> 00:39:07.900]   And we generate these automatically using Lama 3.
[00:39:07.900 --> 00:39:11.300]   So, that is data.
[00:39:11.300 --> 00:39:15.360]   Very lastly, the training recipe.
[00:39:15.360 --> 00:39:21.180]   So, this multi-stage recipe here was optimized for conversion speed.
[00:39:21.180 --> 00:39:26.360]   We start off with a 256-pixel T2i stage image generation.
[00:39:26.360 --> 00:39:33.440]   Here, the model can whip through a bunch of samples in very few, relatively, GPU hours.
[00:39:33.440 --> 00:39:45.140]   We then move on to a pre-training stage with joint text-to-image and text-to-video generation where we progressively increase the resolution from 256p to 768p.
[00:39:45.140 --> 00:39:51.960]   At the highest resolution here, 768p, that's where we have the sequence length of 73k.
[00:39:52.700 --> 00:39:57.300]   And we train this on 6,000 GPUs, around 1,500 batch size.
[00:39:57.300 --> 00:40:01.100]   At this point, the model splinters.
[00:40:01.100 --> 00:40:04.160]   So, we have a text-to-video post-training stage.
[00:40:04.160 --> 00:40:08.900]   This is just SFT on, like, a very small set of very high-quality videos.
[00:40:09.420 --> 00:40:12.080]   And then we also branch off into these different capabilities.
[00:40:12.080 --> 00:40:15.740]   I'm not going to talk about those a bunch, but I'll show you some examples later.
[00:40:15.740 --> 00:40:18.840]   Any questions, Owen?
[00:40:18.840 --> 00:40:20.140]   Sure.
[00:40:20.140 --> 00:40:30.020]   For, like, sort of a wider-tailed ASF for brain research videos, is there sort of, is there free training you can do specifically to address those types of challenges?
[00:40:30.860 --> 00:40:40.640]   Yeah, I think, definitely, I guess the question is about certain concepts in your pre-training data.
[00:40:40.640 --> 00:40:46.720]   So, I guess, yeah, in a very large corpus like we'll be training on, there is an incredibly long tail of concepts.
[00:40:46.720 --> 00:40:52.860]   Pretty much every concept that you might want to generate would probably appear at some point in that data set.
[00:40:52.860 --> 00:40:57.080]   Okay, anything else?
[00:40:59.940 --> 00:41:04.040]   Okay, so, lastly, the results and applications.
[00:41:04.040 --> 00:41:09.920]   So, putting everything together that I just showed you, and that's all of the technical details, by the way, like, we published all of this.
[00:41:09.920 --> 00:41:16.340]   We get videos like this, and like the ones that I showed at the beginning of the talk as well.
[00:41:16.340 --> 00:41:22.080]   And this pretty much sums up the whole point of this project.
[00:41:22.080 --> 00:41:29.380]   I really want to hammer home that these kinds of videos were nowhere near possible before people started scaling transformers.
[00:41:29.740 --> 00:41:46.340]   And we showed here that, again, this classic architecture unification story, scaling data, model parameters, and compute for a simple transformer, ended up in a model that can reason about objects, motion, and physics just by watching videos.
[00:41:47.840 --> 00:41:52.400]   So, none of this was possible, and it's scaling transformers that unlocks all of this.
[00:41:52.400 --> 00:41:58.680]   I have to keep on pressing replay, because I couldn't figure out how to auto-replay on Google Slides.
[00:42:00.120 --> 00:42:04.500]   How many PhDs does it take to auto-replay?
[00:42:04.500 --> 00:42:06.120]   Okay, so, another one.
[00:42:06.120 --> 00:42:09.300]   Here's a sloth with pink sunglasses on a donut float.
[00:42:09.300 --> 00:42:17.540]   Again, I think the physics of sloth-like donut flotation here are good.
[00:42:19.060 --> 00:42:20.840]   This slide isn't only a joke.
[00:42:20.840 --> 00:42:24.400]   It does actually highlight something quite important.
[00:42:24.400 --> 00:42:32.320]   When we're training generative models, one important thing is how well it generalizes to concepts that may be one in its pre-training data.
[00:42:32.320 --> 00:42:41.060]   We can't be sure that there are no, like, slots and floats in the pre-training data, but, you know, by common sense, there probably aren't too many.
[00:42:41.060 --> 00:42:46.440]   So, the fact that it can generate this is testament to its generalizing capabilities.
[00:42:46.440 --> 00:42:53.020]   Okay, a few other things.
[00:42:53.020 --> 00:42:54.300]   I showed you some of these at the beginning.
[00:42:54.300 --> 00:42:59.140]   We also trained a MovieGen edit model.
[00:42:59.140 --> 00:43:04.900]   Like I said before, you take the original video on the top left, and you can provide these precise edit instructions.
[00:43:04.900 --> 00:43:07.320]   This is really magic to me.
[00:43:09.080 --> 00:43:15.580]   I didn't get a chance to cover this too much today, but the team trained this with paired data.
[00:43:15.580 --> 00:43:19.560]   It's incredibly hard to get paired data for this task.
[00:43:19.560 --> 00:43:24.180]   These pairs of input and outputs, they came up with, like, a fascinating self-supervised approach for this.
[00:43:24.180 --> 00:43:25.760]   I'd really recommend reading the paper.
[00:43:25.760 --> 00:43:26.280]   Hey.
[00:43:26.280 --> 00:43:30.020]   Where did you guys get the data from on this project?
[00:43:30.020 --> 00:43:35.020]   The videos are completely licensed videos by matter.
[00:43:35.020 --> 00:43:36.840]   Five minutes.
[00:43:37.100 --> 00:43:49.320]   And one more example here.
[00:43:49.320 --> 00:43:55.100]   You can take, you know, everyone wants to take a video of their penguin and put some Victorian outfits on it.
[00:43:55.100 --> 00:43:56.820]   So, this is great.
[00:44:01.680 --> 00:44:06.280]   One other model that we trained is the personalization model.
[00:44:06.280 --> 00:44:13.580]   So, here, this is MovieGen video, but with the added capability that you can condition on an image of yourself.
[00:44:14.300 --> 00:44:21.840]   So, here, the model can generate a video that is faithful to this text prompt, but also contains the person in the conditioning image.
[00:44:21.840 --> 00:44:22.760]   So, that's really fun.
[00:44:25.820 --> 00:44:27.780]   And another funny example here.
[00:44:27.780 --> 00:44:30.080]   This is my colleague that I worked on the project with.
[00:44:30.080 --> 00:44:31.480]   This makes me laugh.
[00:44:31.480 --> 00:44:35.720]   So, yeah, if anyone is interested in this, please go read the paper.
[00:44:35.720 --> 00:44:37.000]   A bunch of work went into this.
[00:44:39.200 --> 00:44:42.160]   Very lastly, we're going to see now if the theater has audio.
[00:44:42.160 --> 00:44:45.520]   It doesn't.
[00:44:45.520 --> 00:44:49.200]   So, we trained this MovieGen audio model.
[00:44:49.200 --> 00:44:52.080]   Again, I didn't have time to go into this today.
[00:44:52.080 --> 00:44:58.860]   But this is a model that will condition on text and a video, either real or generated, and generate synchronized audio.
[00:44:59.340 --> 00:45:02.380]   So, this way, we can add audio to our generated videos.
[00:45:02.380 --> 00:45:05.360]   It's an amazing research team that did this.
[00:45:05.360 --> 00:45:07.960]   So, I'd recommend going to check out the paper if you're interested.
[00:45:07.960 --> 00:45:10.200]   Okay.
[00:45:10.200 --> 00:45:13.220]   So, there are a couple of just points left.
[00:45:13.220 --> 00:45:15.160]   Firstly, some quantitative results.
[00:45:15.160 --> 00:45:21.280]   It's incredibly hard to do fair comparisons in video generation.
[00:45:21.280 --> 00:45:24.360]   We don't have automated metrics or anything like this.
[00:45:25.780 --> 00:45:30.400]   So, what we did was we did a very extensive human evaluation study.
[00:45:30.400 --> 00:45:37.220]   We came up with a bunch of metrics that are somewhat orthogonal to each other that test every aspect of video generation.
[00:45:37.220 --> 00:45:43.240]   Things like motion quality, how well the videos follow the text prompts, visual quality.
[00:45:43.240 --> 00:45:46.680]   These metrics are shown on the left.
[00:45:46.680 --> 00:45:51.680]   I won't go into a huge bunch of detail here, but they're very sort of fully defined in the paper.
[00:45:51.960 --> 00:46:01.120]   We put in a load of work to make sure that the human evaluators had sort of low standard deviation when multiple evaluators were rating the same thing.
[00:46:01.120 --> 00:46:06.760]   So, we compared to all of the methods that were released in the same year.
[00:46:06.760 --> 00:46:07.540]   This is 2024.
[00:46:07.540 --> 00:46:14.500]   So, things like runways, models, Luma, Sora at the time, and Kling.
[00:46:15.640 --> 00:46:18.780]   And these are net win rates you're seeing here.
[00:46:18.780 --> 00:46:21.600]   So, a score above zero means that our model was preferred.
[00:46:21.600 --> 00:46:26.640]   At the time of release, Movie Jam outperformed all of the prior work.
[00:46:26.640 --> 00:46:28.060]   So, this is, that's great.
[00:46:28.060 --> 00:46:33.220]   It's very hard to draw conclusions here.
[00:46:33.220 --> 00:46:39.580]   The one conclusion we can draw is that Movie Jam was better than these at the time of release.
[00:46:40.580 --> 00:46:53.120]   We are, like researchers, what we like to do at this point is to look into all of the technical reports of the prior work and see what they did differently and what did Movie Jam do differently.
[00:46:53.120 --> 00:46:56.640]   Because we'd like to conclude, right, what led to these improvements?
[00:46:56.640 --> 00:46:57.700]   Was it more compute?
[00:46:57.700 --> 00:46:59.000]   Was it flow matching?
[00:46:59.000 --> 00:47:01.700]   Was it better data filtration?
[00:47:01.700 --> 00:47:02.440]   Things like that.
[00:47:04.020 --> 00:47:10.160]   But it's unfortunately not possible in today's age to do that because we don't see research publications.
[00:47:10.160 --> 00:47:16.480]   But what we do know is that all of the technical details I just presented work, and they work really, really well.
[00:47:16.480 --> 00:47:21.700]   And they're a good starting point for anyone who's looking to improve text-to-video generation.
[00:47:21.700 --> 00:47:24.740]   And we hope the community does.
[00:47:24.740 --> 00:47:26.560]   Okay.
[00:47:26.740 --> 00:47:29.660]   The very last technical thing, scaling laws.
[00:47:29.660 --> 00:47:43.260]   I've talked throughout the whole talk today about architecture unification across modalities and learning objectives, and this was a really nice result that we found at the end of the project.
[00:47:44.040 --> 00:47:46.460]   So what you're seeing here is a scaling law graph.
[00:47:46.460 --> 00:48:01.620]   How we use these when we're training large language models is often when you start training like a, you know, a GPT or a LAMA or whatever, you have a certain training budget.
[00:48:01.620 --> 00:48:06.540]   This is how many months you have and how many GPUs you have for that period.
[00:48:06.540 --> 00:48:13.480]   But if you know that training compute budget, an open question is how big your model should be.
[00:48:13.480 --> 00:48:15.920]   What should be the optimal model size for that compute budget?
[00:48:15.920 --> 00:48:17.060]   It could be a very small model.
[00:48:17.060 --> 00:48:22.800]   You train for more, you train for like more restorations or a larger model.
[00:48:22.800 --> 00:48:23.680]   You train for less.
[00:48:23.680 --> 00:48:29.320]   These scaling law curves are for estimating the optimal model size for a given compute budget.
[00:48:29.320 --> 00:48:35.740]   So just looking at the blue crosses, we plotted a few of these data points for a movie gen.
[00:48:35.740 --> 00:48:39.500]   Remember movie gen, text-to-video model, LAMA 3 architecture.
[00:48:39.500 --> 00:48:43.160]   And looking at the blue crosses, we can see this nice correlation.
[00:48:43.160 --> 00:48:45.400]   We often see in scaling laws with transformers.
[00:48:45.400 --> 00:48:49.020]   We then overlaid the LAMA 3 scaling law.
[00:48:49.020 --> 00:48:51.080]   So this is the scaling law for the text model.
[00:48:51.080 --> 00:49:03.780]   And amazingly, we see that the LAMA 3 scaling law for this text-only model serves as a reasonable predictor for model size and compute for video generation.
[00:49:04.480 --> 00:49:12.320]   And this seems to hint that scaling laws for transformers are maybe modality independent, which is pretty fascinating.
[00:49:12.320 --> 00:49:18.920]   Okay, so we're on the last part now.
[00:49:18.920 --> 00:49:19.580]   What is next?
[00:49:23.080 --> 00:49:25.880]   Movie gen did not solve video generation.
[00:49:25.880 --> 00:49:31.380]   There are still lots of problems.
[00:49:31.380 --> 00:49:36.620]   The model will struggle with generating complex motions from complex prompts.
[00:49:37.720 --> 00:49:41.540]   An example here is a dramatic scene of two cars colliding at an intersection.
[00:49:43.580 --> 00:49:45.960]   So it's looking pretty good at this point.
[00:49:45.960 --> 00:49:53.660]   And then at some point near the end, they sort of, I don't know what you'd call that, they sort of independently implode.
[00:49:53.660 --> 00:49:59.680]   At one point, the silver car kind of turns into two cars as well.
[00:50:00.040 --> 00:50:02.200]   So this is a random generation from our model.
[00:50:02.200 --> 00:50:05.240]   So, you know, text-to-video generation is not solved.
[00:50:05.240 --> 00:50:17.240]   So my final slide is some ideas about where I think video generation is going next.
[00:50:17.240 --> 00:50:21.500]   Things that I'm sure we'll see some version of at some point soon.
[00:50:21.500 --> 00:50:24.140]   So what is next?
[00:50:24.140 --> 00:50:28.860]   How can we solve the issues that you saw in the previous slides?
[00:50:29.520 --> 00:50:35.540]   Well, the first kind of obvious one is scaling everything more.
[00:50:35.540 --> 00:50:41.920]   This has been like the story of machine learning for the last six years or something.
[00:50:41.920 --> 00:50:44.600]   And I think this would like definitely work.
[00:50:44.600 --> 00:50:47.120]   Movie gen was a 30 billion parameter model.
[00:50:47.120 --> 00:50:48.600]   It was based on Lama 3.
[00:50:48.600 --> 00:50:50.660]   The largest Lama 3 model was 405b.
[00:50:50.660 --> 00:50:56.440]   I think scaling everything more would definitely result in far higher quality generations.
[00:50:59.000 --> 00:51:03.960]   Some challenges there would be around scaling data by like an order of magnitude.
[00:51:03.960 --> 00:51:08.660]   Number two is reasoning.
[00:51:08.660 --> 00:51:18.380]   We've all seen the amazing benefits in language modeling that have come from reasoning in the last year or two.
[00:51:21.020 --> 00:51:31.560]   Here, the reasoning gives the model the ability to sort of pause, think, generate a chain of thoughts, self-correct before generating an answer.
[00:51:34.080 --> 00:51:39.920]   I think it's very clear that video generation models would benefit from this kind of reasoning capability as well.
[00:51:39.920 --> 00:51:41.680]   I think that could result in a step change.
[00:51:42.460 --> 00:51:47.520]   When all of us were looking at the videos on the previous slides, it was very clear, right, that something was wrong.
[00:51:47.520 --> 00:51:50.700]   It looked like very obvious to us.
[00:51:51.200 --> 00:52:06.580]   It doesn't seem too unfathomable to be able to imbue some video generation model with the capability to self-correct, maybe see that there are some errors in the video that it generates and correct it.
[00:52:08.940 --> 00:52:16.000]   There are lots of really interesting research questions here, like what does it mean to generate a reasoning trace for media generation?
[00:52:16.000 --> 00:52:21.580]   You might have seen these like chain of thoughts that are generated by like R1 or R3.
[00:52:22.860 --> 00:52:25.040]   I wonder what that looks like for media generation.
[00:52:25.040 --> 00:52:28.260]   The other issue is how to verify.
[00:52:28.260 --> 00:52:35.200]   So, these latest state-of-the-art reasoning approaches are all trained with RL.
[00:52:35.200 --> 00:52:40.440]   RL requires verification models to verify the correctness of the outputs.
[00:52:40.440 --> 00:52:44.820]   It's an open research question what that means for video generation.
[00:52:44.820 --> 00:52:47.100]   How do you verify the correctness of a video?
[00:52:49.700 --> 00:52:52.920]   Very lastly, we have native generation.
[00:52:52.920 --> 00:52:58.600]   So, recent large language models are natively multimodal.
[00:52:58.600 --> 00:53:03.740]   They can generate text, they can do image understanding, they can do video understanding.
[00:53:03.740 --> 00:53:05.900]   Some can even do image generation.
[00:53:05.900 --> 00:53:14.980]   So, it's an interesting question as to whether video generation would also benefit from being thrown into this native mix.
[00:53:16.320 --> 00:53:22.900]   And if so, there are interesting questions around how you would train such a thing.
[00:53:22.900 --> 00:53:26.840]   I've just talked you through how flow matching seems to work the best for video generation.
[00:53:26.840 --> 00:53:30.280]   Is there a way that you can have multiple learning objectives?
[00:53:30.280 --> 00:53:32.160]   Do you need to unify the learning objectives?
[00:53:32.160 --> 00:53:34.440]   Things like that.
[00:53:36.240 --> 00:53:42.060]   So, very lastly, it was a huge team that worked on MovieGen.
[00:53:42.060 --> 00:53:46.420]   These are a bunch of amazing researchers.
[00:53:46.420 --> 00:53:48.660]   I had so much fun on this project, learned so much.
[00:53:48.660 --> 00:53:50.220]   There are loads of good friends here.
[00:53:50.220 --> 00:53:54.560]   So, yeah, shout-outs to all of them.
[00:53:56.480 --> 00:54:03.200]   So, yeah, I'm going to leave it on this slide, but we can do questions now, if there are any.
[00:54:15.200 --> 00:54:20.140]   And a lot of these types of architectures are unit-based, the KOMNet kind of structures.
[00:54:20.140 --> 00:54:29.300]   And that, like, so the action-and-diffusion policy, surprisingly, like, the KOMNet architecture outperforms the transformer architecture for action-and-diffusion for robotics.
[00:54:29.300 --> 00:54:40.180]   And they make an argument that it has an inductive bias about smoothing, so that there's more consistency in the spatial and the time domain and all that great stuff.
[00:54:41.680 --> 00:54:43.040]   And, you know, what do you see that for that piece?
[00:54:43.040 --> 00:54:51.820]   Yeah, so I haven't read that particular paper, but it does sound like a familiar point.
[00:54:51.820 --> 00:55:09.620]   I guess the, you know, the whole theory around architecture unification is that we might have these specialized architecture, like CNNs, and they hold these inductive biases around visual data.
[00:55:09.620 --> 00:55:14.620]   Like, they prioritize these local interactions with the convolutional mask and so on.
[00:55:14.620 --> 00:55:21.980]   And the going idea has been that when you're training at small scale, having these inductive biases helps.
[00:55:21.980 --> 00:55:30.620]   But when you're training at large scale and you have enough data, you can sort of learn all of these yourself with a transformer in a less constrained setting.
[00:55:33.180 --> 00:55:41.720]   We have found that scaling transformers here works better than scaling these specialized architectures, for a few reasons.
[00:55:41.720 --> 00:55:46.680]   I mean, it's not even to say that I don't think CNNs could scale.
[00:55:46.680 --> 00:55:50.620]   It seems as though it's easier to scale transformers.
[00:55:50.620 --> 00:55:53.820]   It's more straightforward to know in which direction to scale.
[00:55:53.820 --> 00:55:55.720]   All the infrastructure already exists.
[00:55:57.780 --> 00:55:59.200]   But yeah, it's a very big debate.
[00:55:59.200 --> 00:56:00.760]   I'm not, I'm not, like, calling it.
[00:56:00.760 --> 00:56:01.820]   Yeah.
[00:56:01.820 --> 00:56:03.520]   Hey.
[00:56:03.520 --> 00:56:09.120]   Can this model and approach be used for 3D generation to, like, video games and stuff like that?
[00:56:09.120 --> 00:56:19.440]   So, if you go back to the architecture, it's totally modality independent.
[00:56:21.300 --> 00:56:27.220]   So, for any, this is for videos and images.
[00:56:27.220 --> 00:56:33.520]   The important thing here is that we've turned a modality into a sequence of tokens.
[00:56:33.520 --> 00:56:38.920]   At this point, after that, everything that's happening in the architecture is modality independent.
[00:56:38.920 --> 00:56:45.540]   So, really for any new kind of data, all you need is a way of turning it into a sequence of tokens.
[00:56:47.940 --> 00:56:54.700]   It may be more challenging to encode, like, that kind of data.
[00:56:54.700 --> 00:57:00.040]   But as long as you can encode it in some way to a series of tokens, you can use the exact same approach.
[00:57:00.040 --> 00:57:00.720]   Yeah.
[00:57:00.720 --> 00:57:06.940]   We have a lot of questions online as well.
[00:57:06.940 --> 00:57:10.300]   So, we can, I can read a few of those right now.
[00:57:10.940 --> 00:57:15.660]   So, one is, so, 16 seconds seems like the longest videos you can effectively generate right now.
[00:57:15.660 --> 00:57:19.920]   What are the main obstacles or things keeping us from getting to longer?
[00:57:19.920 --> 00:57:23.240]   For example, real movie length generations.
[00:57:23.240 --> 00:57:29.620]   So, the main issue is a computational one.
[00:57:29.620 --> 00:57:32.180]   Well, there is so many different answers to this.
[00:57:32.660 --> 00:57:37.380]   If you're thinking from the movie gen setup, the issue is sequence length.
[00:57:37.380 --> 00:57:46.420]   Given the level of compression that we had, 73K was pretty much the longest sequence length we could feasibly train at.
[00:57:46.420 --> 00:57:50.900]   If you want to train on 32-second videos, that's going to double.
[00:57:51.900 --> 00:57:53.260]   There are multiple ways around this.
[00:57:53.260 --> 00:57:56.680]   You could train an encoder with far more compression.
[00:57:56.680 --> 00:57:59.620]   And then you could get to videos that long.
[00:57:59.620 --> 00:58:04.880]   There's another question about learning objective.
[00:58:04.880 --> 00:58:07.980]   Here, we generate everything at once.
[00:58:07.980 --> 00:58:13.780]   There are lots of papers out there that will iteratively generate videos along the temporal axis.
[00:58:13.780 --> 00:58:18.140]   You will generate a chunk and then generate a new chunk conditioned on the previous trunk.
[00:58:18.360 --> 00:58:20.060]   It's kind of like next token prediction.
[00:58:20.060 --> 00:58:23.900]   So, I don't think there's necessarily.
[00:58:23.900 --> 00:58:26.060]   There are lots of ways around it.
[00:58:26.060 --> 00:58:31.260]   And there are lots of interesting papers that generate sort of infinite length videos using these like iterative processes.
[00:58:31.260 --> 00:58:37.560]   Let me see.
[00:58:37.560 --> 00:58:41.500]   There's some questions on like synthetic data compute.
[00:58:41.500 --> 00:58:46.160]   So, someone says, you know, meta is a rare example of having an abundance of training data.
[00:58:47.680 --> 00:58:51.260]   What if, you know, you run out of video, then what's next, I guess?
[00:58:51.260 --> 00:58:57.540]   I really know how to answer that.
[00:58:57.540 --> 00:59:01.260]   If we run out of video.
[00:59:01.260 --> 00:59:04.100]   Look, I think there's.
[00:59:08.960 --> 00:59:16.820]   I think that there's a lot of interesting work to be done on improving the data filtration steps.
[00:59:16.820 --> 00:59:22.860]   So, you know, in this slide, we were optimizing this for high precision.
[00:59:22.860 --> 00:59:26.240]   So, making sure that all the videos at the end were very high quality.
[00:59:26.240 --> 00:59:29.400]   Recall was sacrificed throughout this.
[00:59:29.400 --> 00:59:30.900]   These are like very computer vision terms.
[00:59:32.040 --> 00:59:36.140]   But we would have lost a lot of good data in this like very complex pipeline here.
[00:59:36.140 --> 00:59:43.200]   One like way forward for getting more data is moving to smarter ways of doing this process.
[00:59:43.200 --> 00:59:45.980]   Maybe completely language model based, for example.
[00:59:48.620 --> 00:59:49.060]   Yeah.
[00:59:49.060 --> 00:59:50.760]   I think that's one answer.
[00:59:50.760 --> 00:59:54.560]   A question about compute.
[00:59:54.560 --> 00:59:56.080]   This is more general, I guess.
[00:59:56.080 --> 01:00:02.580]   How can academic researchers contribute to video generation without having, you know, access to thousands of GPUs?
[01:00:04.280 --> 01:00:04.720]   Yeah.
[01:00:04.720 --> 01:00:06.780]   Yeah.
[01:00:06.780 --> 01:00:13.180]   It's obviously very tough to do this level of pre-training outside of industry labs.
[01:00:13.180 --> 01:00:18.840]   But, you know, throughout this paper, we've used a bunch of innovations that came from academia.
[01:00:18.840 --> 01:00:24.080]   For example, a lot of the flow matching work was done at universities.
[01:00:24.080 --> 01:00:28.880]   The main paper we take, Inspiration Forum, did come from Masa.
[01:00:29.700 --> 01:00:34.600]   But this kind of research can be done at small scale, and then all of us can learn from it.
[01:00:34.600 --> 01:00:36.880]   Yeah.
[01:00:36.880 --> 01:00:39.380]   The pre-training is very tough.
[01:00:39.380 --> 01:00:45.220]   Yeah.
[01:00:45.220 --> 01:00:52.420]   I think the pre-training is tough.
[01:00:52.420 --> 01:00:59.400]   But things like learning objectives, I think post-training schemes, we've seen a lot of, like, grade work coming out of academia.
[01:00:59.400 --> 01:01:00.740]   For that.
[01:01:00.740 --> 01:01:01.640]   Yeah.
[01:01:01.640 --> 01:01:06.700]   A few questions all related to text, I guess.
[01:01:06.700 --> 01:01:12.820]   Some folks, you know, are saying there's a lot of work of cleaning and processing video data.
[01:01:12.820 --> 01:01:23.140]   How do you make sure that the actual text, for example, the LAMA 3 generated captions are high quality and complete?
[01:01:26.180 --> 01:01:27.280]   Yeah, good question.
[01:01:27.280 --> 01:01:33.880]   We put a lot of work into training this LAMA 3 captioner, basically.
[01:01:33.880 --> 01:01:36.700]   So this is a video-conditioned LAMA model.
[01:01:36.700 --> 01:01:45.220]   This went through its own sort of large-scale training in order to generate good-looking captions that were aligned with what we wanted.
[01:01:46.640 --> 01:01:49.280]   But certainly, there's a lot of room for improvement there.
[01:01:49.280 --> 01:01:54.900]   These captions are not as good as human-written captions.
[01:01:54.900 --> 01:01:56.920]   There are a lot of architectural reasons for that.
[01:01:56.920 --> 01:02:03.520]   A lot of these, like, video-conditioned language models cannot see the whole video.
[01:02:03.660 --> 01:02:12.620]   If it's a 16-second video at 16 FPS, often it's far too much video for the model to be conditioned on.
[01:02:12.620 --> 01:02:19.860]   So often with a lot of these open-source models, like not only LAMA but Jemma and so on, you have to subsample frames.
[01:02:21.160 --> 01:02:24.600]   And so you're blocking the model, the language model, from seeing a lot of the video.
[01:02:24.600 --> 01:02:27.240]   It's going to lead to some issues, some missed things.
[01:02:27.240 --> 01:02:33.560]   So we do our best by training and post-training a captioning model, doing a bunch of evaluations on it.
[01:02:33.560 --> 01:02:35.740]   But that's definitely something that can be improved.
[01:02:35.740 --> 01:02:43.700]   And there's a bunch of really cool results out there from the text-to-image community showing that if you improve captions, your image quality gets better.
[01:02:44.020 --> 01:02:47.160]   It's not entirely clear why, but that keeps on happening.
[01:02:47.160 --> 01:02:55.120]   Someone asked a related thing, which is how much roller importance does the text-to-prompt encoder play?
[01:02:55.120 --> 01:03:00.780]   I think there were some image generation works which showed, like, replacing the text encoder.
[01:03:00.780 --> 01:03:05.560]   I think it was from clip to, like, T5, like, really helped improve performance.
[01:03:05.560 --> 01:03:10.420]   Did you guys play around with, like, several different text encoders?
[01:03:10.900 --> 01:03:17.280]   So this particular series of text encodings was sort of precedent in our team.
[01:03:17.280 --> 01:03:25.660]   We took motivation from a recent, like, state-of-the-art text-to-image paper that used this series of text encodings.
[01:03:25.660 --> 01:03:30.380]   But, you know, it's worth pointing out here that it is quite strange what we've done here.
[01:03:30.380 --> 01:03:37.660]   You would think it would be, like, intuitive that you want your best possible text representation here.
[01:03:39.040 --> 01:03:41.920]   All of these text representations are nowhere near state-of-the-art.
[01:03:41.920 --> 01:03:42.740]   They're not LAMA.
[01:03:42.740 --> 01:03:43.800]   They're not GPT.
[01:03:43.800 --> 01:03:55.580]   There's been a few works and empirical findings showing that, in this setup at least, decoder-only text representations don't work as well for some reason.
[01:03:58.800 --> 01:04:07.640]   Some reasons for that could be, or some have hypothesized, that you need a text representation that is more aligned with the media space.
[01:04:07.640 --> 01:04:11.440]   That's why a lot of people you'll see conditioning on clip, which is what we do.
[01:04:11.440 --> 01:04:15.940]   So, yeah, a bunch of cool work to do here.
[01:04:15.940 --> 01:04:18.320]   We didn't ablate this in this project, though.
[01:04:20.400 --> 01:04:23.140]   I have a question followed up on the text part.
[01:04:23.140 --> 01:04:27.300]   How well would this do with, like, very detailed prompts?
[01:04:27.300 --> 01:04:35.300]   Like, I want to move a video about this person wearing this specific color, and here's what happens later on.
[01:04:35.300 --> 01:04:41.020]   And then, like, a very detailed script, rather than, you know, just a video of some penguins, I guess.
[01:04:42.020 --> 01:04:52.120]   We definitely did observe that the model can do these sequential actions, but not always completely accurately.
[01:04:52.120 --> 01:04:57.980]   Some of that might be issues in the captioning of the pre-training data.
[01:04:57.980 --> 01:05:01.800]   Like, are you accurately captioning all of these things happening?
[01:05:01.800 --> 01:05:09.020]   But, yeah, that will be one of the places where it struggles, if you were to detail, like, three or four things happening in sequence.
[01:05:09.020 --> 01:05:09.760]   Yeah.
[01:05:11.160 --> 01:05:21.100]   We have one question, which is, could you somehow hard code in some priors related to physics and real-world common sense to improve the realism and accuracy of generated videos?
[01:05:21.100 --> 01:05:25.800]   I guess that might be related to that video of, like, the car splitting and all of that.
[01:05:25.800 --> 01:05:28.720]   Yeah.
[01:05:28.720 --> 01:05:35.000]   Yeah.
[01:05:35.000 --> 01:05:40.300]   So, in a way, it's kind of like the antithesis of...
[01:05:40.300 --> 01:05:48.160]   the things that we were trying here, of, like, removing all of the inductive biases and just scaling compute and data.
[01:05:48.160 --> 01:06:02.860]   But I do think those are interesting things to try, simply because maybe if you are trying to learn the laws of physics better, just random videos from, like, a large pool aren't maybe the best thing to use there.
[01:06:05.240 --> 01:06:12.100]   And there are other cool works that have been released where they're trained, like, entirely on video game data, things like that.
[01:06:12.100 --> 01:06:19.300]   Yeah, I think encoding some sort of priors would be cool.
[01:06:19.300 --> 01:06:22.740]   Yeah, because, you know, there are certain things about the natural world that we do know for sure.
[01:06:22.740 --> 01:06:26.240]   Certain, like, computer vision principles and so on.
[01:06:26.240 --> 01:06:28.320]   But, yeah, we didn't do that here.
[01:06:28.580 --> 01:06:30.780]   Do you know how to possibly encode those?
[01:06:30.780 --> 01:06:31.600]   Yeah.
[01:06:31.600 --> 01:06:34.040]   That's, like, a super open question.
[01:06:34.040 --> 01:06:35.000]   Super open question.
[01:06:35.000 --> 01:06:35.960]   Okay, makes sense.
[01:06:35.960 --> 01:06:39.260]   We've got a couple others online, and then we can go back to in-person.
[01:06:39.260 --> 01:06:44.720]   One's more on, you know, deep fakes and malicious use of video generation models.
[01:06:44.720 --> 01:06:48.400]   Is there any work on things like watermarking to sort of deal with that?
[01:06:49.920 --> 01:06:52.460]   There's definitely a bunch of work on watermarking.
[01:06:52.460 --> 01:07:02.140]   We, yeah, there's definitely a bunch of work on watermarking coming from a few groups.
[01:07:02.140 --> 01:07:05.380]   DeepMind has released a few interesting papers on it.
[01:07:05.380 --> 01:07:08.000]   Masa has a team working on this as well.
[01:07:08.000 --> 01:07:10.780]   So, yeah, very important work to be done.
[01:07:11.300 --> 01:07:19.380]   And then we can go back to some in-person questions.
[01:07:19.380 --> 01:07:21.660]   One's about GANs, actually.
[01:07:21.660 --> 01:07:28.260]   I've noticed some other models have a GAN discriminator before or in the decoder for temporal coherence.
[01:07:28.260 --> 01:07:31.860]   Is this still useful, or does scale overcome this need?
[01:07:31.860 --> 01:07:35.740]   They mean in the VAE decoder?
[01:07:35.740 --> 01:07:38.240]   I think so.
[01:07:38.900 --> 01:07:41.660]   Yeah, so we also have, again, discriminator there.
[01:07:41.660 --> 01:07:47.440]   It's not necessarily for temporal consistency.
[01:07:47.440 --> 01:07:51.060]   That might be one of the outcomes.
[01:07:51.060 --> 01:07:54.820]   There's sort of a historical precedent for this.
[01:07:54.820 --> 01:07:59.760]   When you are training these, where is it?
[01:07:59.760 --> 01:08:06.060]   When you're training these VAEs, folk found, it was the stable diffusion researchers, actually,
[01:08:06.060 --> 01:08:08.480]   while they were still at college in Germany.
[01:08:09.040 --> 01:08:14.240]   They published this paper called VQGAN back in 2021, I think.
[01:08:14.240 --> 01:08:21.180]   And they showed that normally how you train these VAEs is that you just use L1 losses between the input and the output.
[01:08:22.780 --> 01:08:27.180]   But they found that the amount of compression you could do was very limited when you were doing that.
[01:08:27.180 --> 01:08:32.340]   So what they started doing was adding some adversarial losses from the GAN literature.
[01:08:32.340 --> 01:08:40.800]   What this does is it tells the VAE that I don't have to decode exactly what was given to me.
[01:08:41.880 --> 01:08:45.700]   Because the GAN losses, they're not L1 losses, they're not pixel level losses.
[01:08:45.700 --> 01:08:50.860]   These losses are just how well the GAN can tell if it's a real image or a fake one.
[01:08:51.640 --> 01:09:00.260]   So when folks started training VAEs with these losses, the outputs were given a bit more freedom.
[01:09:00.260 --> 01:09:03.720]   So the model could generate a range of things for a sudden input.
[01:09:04.200 --> 01:09:07.440]   And it's not getting penalized from the loss as long as they look real.
[01:09:07.440 --> 01:09:10.780]   And I realize there's a bunch of detail there.
[01:09:10.780 --> 01:09:16.220]   But basically, by adding these losses, we were able to get another 2x level of compression.
[01:09:16.760 --> 01:09:22.180]   So we are also using adversarial losses in the VAE, if that was their question.
[01:09:22.180 --> 01:09:25.520]   Someone added an interesting question just now, which is,
[01:09:25.520 --> 01:09:30.960]   how might you make sure all the videos in your training data are real?
[01:09:30.960 --> 01:09:32.700]   What if some of them are fake?
[01:09:32.700 --> 01:09:37.280]   I guess that's related to some work nowadays in language models.
[01:09:37.280 --> 01:09:44.620]   But once more and more training data becomes synthetically generated, does that lead to any issues, I guess?
[01:09:45.980 --> 01:09:51.140]   Definitely this idea of, like, data set poisoning, it's often called, is a problem.
[01:09:51.140 --> 01:09:57.020]   I think there are a couple interesting answers to this.
[01:09:57.020 --> 01:10:03.800]   Firstly, in our pre-training data, if it's low quality, then we don't want to train on it.
[01:10:03.800 --> 01:10:06.320]   And hopefully, we would find it and get rid of it.
[01:10:06.320 --> 01:10:10.040]   But training on generated data is not always a bad thing.
[01:10:10.040 --> 01:10:14.980]   Most contemporary post-training approaches for language models
[01:10:14.980 --> 01:10:17.360]   are based upon training on generated data.
[01:10:17.360 --> 01:10:20.000]   You train on generations from the model itself.
[01:10:20.000 --> 01:10:23.460]   So it's not like training on generated data is always bad.
[01:10:23.460 --> 01:10:28.480]   If there's some really, like, bad generated videos in the pre-training data,
[01:10:28.480 --> 01:10:29.780]   we do want to get rid of those.
[01:10:29.780 --> 01:10:33.440]   But it's not always bad.
[01:10:35.880 --> 01:10:38.420]   We've got time for a couple more in-person questions.
[01:10:38.420 --> 01:10:39.000]   If...
[01:10:39.000 --> 01:10:45.140]   In the paper, we included, like, full details of the training infrastructure.
[01:10:45.140 --> 01:10:53.320]   I don't think we included, like, in the paper, like, full details of the training infrastructure.
[01:10:53.320 --> 01:10:53.800]   That will be there.
[01:10:53.800 --> 01:11:02.820]   I don't think we included any details about the inference infrastructure.
[01:11:02.820 --> 01:11:07.180]   In the paper, we included, like, full details of the training infrastructure.
[01:11:07.180 --> 01:11:08.880]   That will be there.
[01:11:08.880 --> 01:11:14.320]   I don't think we included any details about the inference infrastructure.
[01:11:14.320 --> 01:11:16.700]   There are lots of details on the inference infrastructure.
[01:11:16.700 --> 01:11:20.240]   There are lots of details on the inference in the paper.
[01:11:20.240 --> 01:11:26.580]   There are lots of details on the inference infrastructure that I've shown here.
[01:11:26.580 --> 01:11:27.580]   Any other questions?
[01:11:27.580 --> 01:11:33.240]   I don't know if I missed that, but for the videos you generated, do they come with audio?
[01:11:33.240 --> 01:11:41.860]   Yeah, so this text-to-video model that I've shown here, it generates video.
[01:11:41.860 --> 01:11:52.980]   But with the publication, we released a, well, published about a, where is it?
[01:11:52.980 --> 01:11:55.940]   Actually, no, we're not going over that problem again.
[01:11:55.940 --> 01:11:59.160]   There's no audio.
[01:11:59.160 --> 01:12:01.480]   Yes.
[01:12:01.480 --> 01:12:08.500]   So there were, yeah, there was a separate MovieGen audio model that we trained that will add audio
[01:12:08.500 --> 01:12:09.500]   to a generated video.
[01:12:09.500 --> 01:12:19.560]   Video asked two separate models, and the audio is, like, another level of complexity where
[01:12:19.560 --> 01:12:23.800]   there are, like, multiple chats, and if you want to train on mini-files, whatever.
[01:12:23.800 --> 01:12:33.560]   So what is, like, your current progress in this oil generation?
[01:12:33.560 --> 01:12:44.200]   So, we have a really great audio research team that works on this.
[01:12:44.200 --> 01:12:49.320]   One very nice thing to do, I think, would be to generate everything at once, like video
[01:12:49.320 --> 01:12:51.240]   and audio.
[01:12:51.240 --> 01:12:53.120]   The two modalities are very correlated.
[01:12:53.120 --> 01:12:54.620]   There's a lot of shared information.
[01:12:54.620 --> 01:13:00.680]   So, theoretically, both modalities should benefit from being trained together.
[01:13:00.680 --> 01:13:04.680]   The audio even encodes some information about videos that are not present in the video.
[01:13:04.680 --> 01:13:09.360]   So, the issue is one of data.
[01:13:09.360 --> 01:13:11.360]   It's very hard to get high-quality video data.
[01:13:11.360 --> 01:13:15.240]   It's even harder to get high-quality video with good audio data.
[01:13:15.240 --> 01:13:23.920]   So, that's part of the reason why we didn't do that for this project.
[01:13:23.920 --> 01:13:24.920]   Awesome.
[01:13:24.920 --> 01:13:28.300]   Thanks so much, Andrew, for the very insightful talk and answering all our questions.
[01:13:28.300 --> 01:13:29.300]   Thanks.
[01:13:29.300 --> 01:13:30.300]   Thanks.
[01:13:30.300 --> 01:14:00.280]   Thank you.

