
[00:00:00.000 --> 00:00:10.000]   [BLANK_AUDIO]
[00:00:10.000 --> 00:00:25.440]   The site, but if anybody has any resources for signal processing in APL, I'd be interested.
[00:00:25.440 --> 00:00:28.160]   I did a quick search, but I didn't do an exhaustive one.
[00:00:28.160 --> 00:00:31.120]   So, like I said, I'll put something up on the site.
[00:00:31.120 --> 00:00:35.520]   But feel free to add something in the chat if anybody knows anything.
[00:00:35.520 --> 00:00:35.840]   Thanks.
[00:00:35.840 --> 00:00:43.280]   >> It might be worth searching for the kind of things you would use for signal processing,
[00:00:43.280 --> 00:00:48.960]   like look on APL Wiki and stuff like Fourier transform or Kalman filter.
[00:00:48.960 --> 00:00:51.440]   >> Yeah, true.
[00:00:51.440 --> 00:00:52.320]   >> Evolution.
[00:00:56.320 --> 00:00:58.640]   Interesting to hear what you find anyway.
[00:00:58.640 --> 00:00:59.600]   >> Yeah, thank you.
[00:00:59.600 --> 00:01:24.400]   >> Okay, so I remember we were up to auditioned in close.
[00:01:25.280 --> 00:01:30.400]   >> Has anybody skipped ahead to figure out what that is?
[00:01:30.400 --> 00:01:39.760]   [BLANK_AUDIO]
[00:01:39.760 --> 00:01:40.240]   >> It's not me.
[00:01:40.240 --> 00:01:45.040]   >> What button do we press for in close again?
[00:01:45.040 --> 00:01:48.080]   [BLANK_AUDIO]
[00:01:48.080 --> 00:01:48.720]   Let's see.
[00:01:48.720 --> 00:01:58.720]   [BLANK_AUDIO]
[00:01:58.720 --> 00:02:07.140]   Sorry.
[00:02:07.140 --> 00:02:16.880]   >> Oh, so for me, it seems like it was doing, say, if on the left-hand side you have 1, 2, 3,
[00:02:16.880 --> 00:02:24.080]   it would enclose the first one one time at like three elements on each side, 1, 2, 3 on each side.
[00:02:24.080 --> 00:02:26.480]   >> Well, could you explain maybe the version we've got here?
[00:02:26.480 --> 00:02:27.120]   Does this make sense?
[00:02:27.120 --> 00:02:29.680]   We've got 0101 enclosed 1234.
[00:02:29.680 --> 00:02:32.160]   >> Oh, yeah, sure.
[00:02:32.160 --> 00:02:40.080]   I mean 0101, let me make sure it does what I think it does.
[00:02:40.080 --> 00:02:45.520]   >> So it's giving us 23 in the first cell and four in the second cell.
[00:02:45.520 --> 00:02:47.120]   [BLANK_AUDIO]
[00:02:47.120 --> 00:02:47.600]   >> Apparently.
[00:02:47.600 --> 00:02:52.160]   [BLANK_AUDIO]
[00:02:52.160 --> 00:02:52.640]   >> It is.
[00:02:52.640 --> 00:02:57.280]   [BLANK_AUDIO]
[00:02:57.280 --> 00:03:00.560]   >> Okay, that is my understanding was wrong.
[00:03:00.560 --> 00:03:01.040]   [LAUGH]
[00:03:01.040 --> 00:03:02.080]   >> Okay, all right.
[00:03:02.080 --> 00:03:03.840]   All the more interesting.
[00:03:03.840 --> 00:03:04.720]   [BLANK_AUDIO]
[00:03:04.720 --> 00:03:05.840]   >> Oh, well, okay.
[00:03:05.840 --> 00:03:08.800]   Yeah, I played with it a bit and thought I knew what it did.
[00:03:08.800 --> 00:03:17.760]   [LAUGH]
[00:03:17.760 --> 00:03:19.280]   >> I'm getting a sense of what it is.
[00:03:19.280 --> 00:03:22.800]   It's looked like the ones are defining groups.
[00:03:22.800 --> 00:03:29.920]   So it's taking where the first one is and giving us the numbers there,
[00:03:29.920 --> 00:03:35.440]   the letters in this case, then the second group is defined here, the letters there.
[00:03:35.440 --> 00:03:40.000]   >> Yeah, did you look on the APL Wiki?
[00:03:40.000 --> 00:03:42.000]   >> I haven't done anything at all.
[00:03:42.000 --> 00:03:45.600]   This is the first time I've- >> Okay, I was just looking it up
[00:03:45.600 --> 00:03:51.840]   in the background and I think it's starting to explain basically what you were saying.
[00:03:51.840 --> 00:03:52.880]   >> Didn't they?
[00:03:52.880 --> 00:03:55.840]   >> It looked like it was a pretty good definition at least starting out.
[00:03:55.840 --> 00:04:01.120]   [BLANK_AUDIO]
[00:04:01.120 --> 00:04:07.520]   >> That second paragraph, oh.
[00:04:07.520 --> 00:04:16.720]   >> Yeah, it indicates where divisions begin.
[00:04:16.720 --> 00:04:21.360]   [BLANK_AUDIO]
[00:04:21.360 --> 00:04:25.200]   Cool, it seems pretty straightforward.
[00:04:27.520 --> 00:04:31.600]   So each one is the start of a new division.
[00:04:31.600 --> 00:04:38.480]   The APL Wiki example's a bit clearer, I think.
[00:04:38.480 --> 00:04:40.880]   [BLANK_AUDIO]
[00:04:40.880 --> 00:04:41.920]   >> Or at least that one is.
[00:04:41.920 --> 00:04:42.960]   [LAUGH]
[00:04:42.960 --> 00:04:44.160]   >> Yeah, that's what I mean, this one.
[00:04:44.160 --> 00:04:47.200]   [BLANK_AUDIO]
[00:04:47.200 --> 00:04:56.320]   Okay, so then they're saying some dialects by which I assume they mean dialogues included.
[00:04:56.320 --> 00:04:58.480]   [BLANK_AUDIO]
[00:04:58.480 --> 00:05:04.000]   Okay, so that's just saying create two partitions, make this the second.
[00:05:04.000 --> 00:05:05.680]   [BLANK_AUDIO]
[00:05:05.680 --> 00:05:08.880]   Have two partitions after the first and then three partitions after that.
[00:05:08.880 --> 00:05:12.000]   So it's just creating some empty partitions.
[00:05:12.000 --> 00:05:17.120]   [BLANK_AUDIO]
[00:05:17.120 --> 00:05:19.440]   All right, well, that seems straightforward enough.
[00:05:19.440 --> 00:05:22.240]   [BLANK_AUDIO]
[00:05:22.240 --> 00:05:27.760]   Sorry, keep moving along then.
[00:05:27.760 --> 00:05:33.040]   Looks like the next one is left shoe underbar.
[00:05:33.040 --> 00:05:43.040]   [BLANK_AUDIO]
[00:05:48.000 --> 00:05:55.200]   Which is written as shift C, I guess, right, shift C, okay.
[00:05:55.200 --> 00:05:59.520]   [BLANK_AUDIO]
[00:05:59.520 --> 00:06:00.800]   Starting to get the hang of this.
[00:06:00.800 --> 00:06:11.760]   [BLANK_AUDIO]
[00:06:11.760 --> 00:06:17.680]   Oops. [BLANK_AUDIO]
[00:06:17.680 --> 00:06:22.240]   On edit, left shoe underbar means nest.
[00:06:22.240 --> 00:06:28.480]   [BLANK_AUDIO]
[00:06:28.480 --> 00:06:30.560]   Let's check API Wiki as well, shall we?
[00:06:30.560 --> 00:06:33.120]   [BLANK_AUDIO]
[00:06:33.120 --> 00:06:34.960]   >> It's like- >> Yep.
[00:06:34.960 --> 00:06:35.920]   [BLANK_AUDIO]
[00:06:35.920 --> 00:06:39.840]   >> It has some, it's kind of like enclosed with some
[00:06:39.840 --> 00:06:43.280]   extra logic so that it doesn't nest too many times.
[00:06:43.280 --> 00:06:45.760]   If you nest and nest and nest, it doesn't do that.
[00:06:45.760 --> 00:06:49.920]   [BLANK_AUDIO]
[00:06:49.920 --> 00:06:53.760]   >> Okay, let's have a look at this example, shall we?
[00:06:53.760 --> 00:06:59.280]   So this is, that's H, isn't it?
[00:06:59.280 --> 00:07:02.080]   And I think this means, is it an element of?
[00:07:02.080 --> 00:07:05.040]   [BLANK_AUDIO]
[00:07:05.040 --> 00:07:12.080]   And so this adds up how many times an A appears in each word?
[00:07:12.080 --> 00:07:20.080]   [BLANK_AUDIO]
[00:07:20.080 --> 00:07:22.240]   Okay, it's counting out the words, no worries.
[00:07:22.240 --> 00:07:25.120]   But if the user only gives one word,
[00:07:25.120 --> 00:07:29.840]   it'll count the A's in each letter because it's going H, yes.
[00:07:31.520 --> 00:07:39.520]   You can apply nest, [BLANK_AUDIO]
[00:07:39.520 --> 00:07:46.800]   Okay, so, [BLANK_AUDIO]
[00:07:46.800 --> 00:07:48.080]   They've got some examples.
[00:07:48.080 --> 00:07:55.680]   I quite like that they're saying like an example of why it would be useful in API Wiki.
[00:07:55.680 --> 00:07:59.840]   Even if the examples are a bit complicated.
[00:07:59.840 --> 00:08:09.200]   [BLANK_AUDIO]
[00:08:09.200 --> 00:08:11.920]   Now that's the same as normal and close, right?
[00:08:11.920 --> 00:08:15.520]   [BLANK_AUDIO]
[00:08:15.520 --> 00:08:17.040]   And we can check that.
[00:08:17.040 --> 00:08:22.080]   [BLANK_AUDIO]
[00:08:22.080 --> 00:08:26.880]   By using the tally thing.
[00:08:26.880 --> 00:08:28.480]   [BLANK_AUDIO]
[00:08:28.480 --> 00:08:30.080]   No, the other thing match.
[00:08:30.080 --> 00:08:33.920]   [BLANK_AUDIO]
[00:08:33.920 --> 00:08:34.800]   Okay, they're the same.
[00:08:34.800 --> 00:08:45.600]   [BLANK_AUDIO]
[00:08:45.600 --> 00:08:46.560]   Is this one different?
[00:08:46.560 --> 00:08:52.880]   [BLANK_AUDIO]
[00:08:52.880 --> 00:08:55.200]   No, this is different.
[00:08:55.200 --> 00:09:07.280]   [BLANK_AUDIO]
[00:09:07.280 --> 00:09:10.560]   Okay, I see.
[00:09:10.560 --> 00:09:12.240]   So what's the rule it's using?
[00:09:12.240 --> 00:09:22.480]   [BLANK_AUDIO]
[00:09:22.480 --> 00:09:24.880]   If y is simple, what does simple mean?
[00:09:24.880 --> 00:09:31.280]   [BLANK_AUDIO]
[00:09:31.280 --> 00:09:35.520]   I think simple means that it's an array that doesn't contain any arrays.
[00:09:35.520 --> 00:09:38.160]   [BLANK_AUDIO]
[00:09:38.160 --> 00:09:51.360]   So I think if we did two, three, reshape, iota six, that's the same because this is simple.
[00:09:51.360 --> 00:09:54.000]   [BLANK_AUDIO]
[00:09:54.000 --> 00:10:00.400]   I don't know, I didn't type down where I got the definition, but a simple array is an array
[00:10:00.400 --> 00:10:04.240]   of depth one with all primitive values such as a string or array of numbers.
[00:10:04.240 --> 00:10:04.480]   [BLANK_AUDIO]
[00:10:04.480 --> 00:10:10.720]   Oh, perfect. By the way, what happened to our thing that shows like the little squiggle
[00:10:10.720 --> 00:10:13.920]   or thing that tells us, you know, the end shows us that it'll arrows.
[00:10:13.920 --> 00:10:15.840]   Is that some different kind of boxing?
[00:10:15.840 --> 00:10:20.000]   Oh, we've got min, I don't want min, max.
[00:10:20.000 --> 00:10:24.800]   Okay, I think that tells us whether something's simple.
[00:10:24.800 --> 00:10:29.840]   [BLANK_AUDIO]
[00:10:29.840 --> 00:10:31.120]   Yes, okay.
[00:10:31.120 --> 00:10:36.720]   [BLANK_AUDIO]
[00:10:36.720 --> 00:10:43.760]   So if I do this, that's considered, so I think squiggle might mean simple.
[00:10:43.760 --> 00:10:45.520]   [BLANK_AUDIO]
[00:10:45.520 --> 00:10:47.760]   And this thing might mean not simple, maybe.
[00:10:47.760 --> 00:10:54.160]   [BLANK_AUDIO]
[00:10:54.160 --> 00:10:58.640]   All right, great. So if it's just a, so basically if it's just an array,
[00:10:59.360 --> 00:11:05.680]   like, or tensor, I guess, then it's gonna return it unchanged.
[00:11:05.680 --> 00:11:18.560]   [BLANK_AUDIO]
[00:11:18.560 --> 00:11:20.080]   Oh, no, sorry, yes, I see.
[00:11:20.080 --> 00:11:24.720]   If it's an array, then it encloses it. Is that what it's saying?
[00:11:24.720 --> 00:11:27.680]   [BLANK_AUDIO]
[00:11:27.680 --> 00:11:28.400]   Yeah, that's it.
[00:11:28.400 --> 00:11:31.120]   [BLANK_AUDIO]
[00:11:31.120 --> 00:11:36.560]   Okay, so if it's an array, it encloses it.
[00:11:36.560 --> 00:11:38.560]   Okay, so they're right, right, so that's enclosed.
[00:11:38.560 --> 00:11:40.800]   So if it's an array, it encloses it.
[00:11:40.800 --> 00:11:44.160]   Anything else, it does nothing at all.
[00:11:44.160 --> 00:11:46.960]   [BLANK_AUDIO]
[00:11:46.960 --> 00:11:49.680]   Okay, so they're the three possibilities, so I guess we should show them.
[00:11:49.680 --> 00:11:53.360]   [BLANK_AUDIO]
[00:11:53.360 --> 00:11:57.920]   And left shoe would have done the same thing, no? In fact, I just tried it on sleep.
[00:11:57.920 --> 00:12:01.760]   In the example, it also worked.
[00:12:01.760 --> 00:12:08.160]   Right, a left shoe does the same in the case of an array,
[00:12:08.160 --> 00:12:12.960]   but not in the case of a scalar or a non-simple object.
[00:12:12.960 --> 00:12:15.520]   [BLANK_AUDIO]
[00:12:15.520 --> 00:12:16.400]   Oh, so sleep.
[00:12:16.400 --> 00:12:18.480]   So that's why you can see here, this is the same.
[00:12:18.480 --> 00:12:23.360]   [BLANK_AUDIO]
[00:12:23.360 --> 00:12:24.560]   But this is not the same.
[00:12:24.560 --> 00:12:26.640]   As you can see, these are different.
[00:12:26.640 --> 00:12:37.120]   [BLANK_AUDIO]
[00:12:37.120 --> 00:12:37.600]   Okay.
[00:12:37.600 --> 00:12:41.760]   [BLANK_AUDIO]
[00:12:41.760 --> 00:12:47.280]   Okay, so in the case of a scalar, right, enclosed does nothing.
[00:12:47.280 --> 00:12:50.320]   Okay, so this is called nest.
[00:12:50.320 --> 00:12:55.520]   [BLANK_AUDIO]
[00:12:55.520 --> 00:13:01.760]   Okay, so they're exactly the same in the scalar case and the simple array case,
[00:13:01.760 --> 00:13:08.560]   but they're different in the nested array case.
[00:13:08.560 --> 00:13:11.200]   If it's already a nested array, it doesn't nest it anymore.
[00:13:11.200 --> 00:13:20.720]   [BLANK_AUDIO]
[00:13:20.720 --> 00:13:21.200]   Great.
[00:13:21.200 --> 00:13:28.480]   [BLANK_AUDIO]
[00:13:28.480 --> 00:13:41.760]   So then, dyadic is partition rather than partitioned in close.
[00:13:41.760 --> 00:13:51.760]   [BLANK_AUDIO]
[00:13:51.760 --> 00:13:54.400]   Oh, I see.
[00:13:54.400 --> 00:13:59.680]   It's something about that the partitions are now defined in a different way,
[00:13:59.680 --> 00:14:01.120]   rather than ones and zeros.
[00:14:01.120 --> 00:14:03.120]   [BLANK_AUDIO]
[00:14:03.120 --> 00:14:04.960]   It's whenever the left argument.
[00:14:04.960 --> 00:14:08.800]   [BLANK_AUDIO]
[00:14:08.800 --> 00:14:09.440]   New division.
[00:14:09.440 --> 00:14:10.960]   [BLANK_AUDIO]
[00:14:10.960 --> 00:14:13.360]   Therefore, an element is greater than the nape and it's left.
[00:14:13.360 --> 00:14:16.640]   So here's a new spot.
[00:14:16.640 --> 00:14:19.920]   [BLANK_AUDIO]
[00:14:19.920 --> 00:14:20.400]   Cool.
[00:14:20.400 --> 00:14:25.120]   [BLANK_AUDIO]
[00:14:25.120 --> 00:14:27.520]   Okay, and you can skip by setting a zero.
[00:14:27.520 --> 00:14:29.600]   [BLANK_AUDIO]
[00:14:29.600 --> 00:14:30.400]   Seems powerful.
[00:14:30.400 --> 00:14:37.200]   [BLANK_AUDIO]
[00:14:37.200 --> 00:14:38.720]   Okay, so by definition,
[00:14:38.720 --> 00:14:41.760]   [BLANK_AUDIO]
[00:14:41.760 --> 00:14:44.480]   You can split on spaces, for example.
[00:14:44.480 --> 00:14:46.320]   [BLANK_AUDIO]
[00:14:46.320 --> 00:14:53.360]   So here is a place where it's gone down and therefore it's gonna skip the fourth element,
[00:14:53.360 --> 00:14:54.240]   which is a space.
[00:14:54.240 --> 00:14:59.520]   And then this here goes up again, so it's gonna create a new partition, a new group.
[00:14:59.520 --> 00:15:01.840]   [BLANK_AUDIO]
[00:15:01.840 --> 00:15:08.480]   Okay, so this is, [BLANK_AUDIO]
[00:15:08.480 --> 00:15:15.120]   I guess maybe a good time to talk about forks because their example here is a fork.
[00:15:15.120 --> 00:15:18.960]   [BLANK_AUDIO]
[00:15:18.960 --> 00:15:26.000]   So I guess let's start with, [BLANK_AUDIO]
[00:15:26.000 --> 00:15:27.920]   Does this example make sense to everybody?
[00:15:27.920 --> 00:15:47.440]   [BLANK_AUDIO]
[00:15:47.440 --> 00:15:48.640]   Does that make sense so far?
[00:15:48.640 --> 00:15:50.320]   >> It does make- >> Cool.
[00:15:50.320 --> 00:15:57.440]   >> It does make sense, but it seems like it's quite involved to what it can do.
[00:15:57.440 --> 00:16:01.840]   And the differences between the operators that we've seen here on close.
[00:16:01.840 --> 00:16:08.480]   I'm just curious how much of this was in the original specification of APL,
[00:16:08.480 --> 00:16:10.640]   and how much of this evolved over time?
[00:16:10.640 --> 00:16:14.080]   So essentially, how much of this is coming from the CANI person's paper?
[00:16:14.080 --> 00:16:16.160]   [BLANK_AUDIO]
[00:16:16.160 --> 00:16:19.360]   It's just curious.
[00:16:19.360 --> 00:16:22.640]   [BLANK_AUDIO]
[00:16:22.640 --> 00:16:25.680]   >> Yeah, I assume this classic edition thing would be closer.
[00:16:25.680 --> 00:16:30.560]   There is a APL dictionary on the J software website,
[00:16:30.560 --> 00:16:34.000]   which I guess would be a good place to answer that question.
[00:16:34.000 --> 00:16:37.520]   [BLANK_AUDIO]
[00:16:37.520 --> 00:16:45.760]   I thought, [BLANK_AUDIO]
[00:16:45.760 --> 00:16:46.640]   Maybe I'm wrong.
[00:16:46.640 --> 00:16:48.560]   [BLANK_AUDIO]
[00:16:48.560 --> 00:16:51.360]   Go to the API dictionary.
[00:16:51.360 --> 00:16:54.640]   [BLANK_AUDIO]
[00:16:54.640 --> 00:16:56.160]   Yeah, yeah, dictionary of APL.
[00:16:56.160 --> 00:16:57.440]   [BLANK_AUDIO]
[00:16:57.440 --> 00:16:58.240]   >> Wow, cool.
[00:16:58.240 --> 00:17:01.840]   [BLANK_AUDIO]
[00:17:01.840 --> 00:17:04.640]   >> Okay, so here's all the symbols, I guess.
[00:17:04.640 --> 00:17:08.160]   [BLANK_AUDIO]
[00:17:08.160 --> 00:17:10.160]   >> And the way- >> There's an enclose here.
[00:17:10.160 --> 00:17:10.800]   [BLANK_AUDIO]
[00:17:10.800 --> 00:17:12.400]   Oh, except it's called superset.
[00:17:12.400 --> 00:17:13.120]   That's interesting.
[00:17:13.120 --> 00:17:15.120]   [BLANK_AUDIO]
[00:17:15.120 --> 00:17:17.760]   >> So the way he arrived on this was even without,
[00:17:17.760 --> 00:17:21.840]   before he, there was no implementation initially, right?
[00:17:21.840 --> 00:17:24.240]   It was just trying to find the notation.
[00:17:24.240 --> 00:17:24.400]   [BLANK_AUDIO]
[00:17:24.400 --> 00:17:26.160]   This was written in 1987.
[00:17:26.160 --> 00:17:28.880]   So this was well after there was an implementation.
[00:17:28.880 --> 00:17:29.440]   [BLANK_AUDIO]
[00:17:29.440 --> 00:17:30.000]   >> Right.
[00:17:30.000 --> 00:17:31.600]   >> Yeah, the original notation,
[00:17:31.600 --> 00:17:34.560]   I don't know what that kind of official.
[00:17:34.560 --> 00:17:37.040]   [BLANK_AUDIO]
[00:17:37.040 --> 00:17:39.520]   Oh, all right, I guess going back here.
[00:17:39.520 --> 00:17:40.320]   [BLANK_AUDIO]
[00:17:40.320 --> 00:17:42.960]   Here we are, A programming language, 1962.
[00:17:42.960 --> 00:17:45.040]   So that was a point when there wasn't an implementation.
[00:17:45.040 --> 00:17:46.240]   [BLANK_AUDIO]
[00:17:46.240 --> 00:17:47.120]   >> Cool.
[00:17:47.120 --> 00:17:48.560]   >> And I think this would be interesting too,
[00:17:48.560 --> 00:17:52.400]   cuz this is where they actually designed IBM computer systems
[00:17:52.400 --> 00:17:54.560]   using APL as a notation.
[00:17:54.560 --> 00:17:56.320]   [BLANK_AUDIO]
[00:17:56.320 --> 00:17:58.720]   >> Yeah, this sounds like a very interesting read.
[00:17:58.720 --> 00:17:59.680]   >> And this book I have.
[00:17:59.680 --> 00:18:00.320]   >> Thank you so much for sharing this.
[00:18:00.320 --> 00:18:00.960]   [BLANK_AUDIO]
[00:18:00.960 --> 00:18:01.840]   >> This book I have.
[00:18:01.840 --> 00:18:04.400]   [BLANK_AUDIO]
[00:18:04.400 --> 00:18:05.360]   >> What is it?
[00:18:05.360 --> 00:18:07.360]   Oh, it's its elementary functions?
[00:18:07.360 --> 00:18:08.560]   [BLANK_AUDIO]
[00:18:08.560 --> 00:18:14.640]   >> Yeah, it's basically a math textbook for
[00:18:14.640 --> 00:18:17.760]   designed at kind of high school level, if I remember correctly.
[00:18:17.760 --> 00:18:22.160]   [BLANK_AUDIO]
[00:18:22.160 --> 00:18:25.600]   >> Let's see, one semester pre-calculus course, yeah.
[00:18:25.600 --> 00:18:35.200]   [BLANK_AUDIO]
[00:18:35.200 --> 00:18:38.080]   >> So he worked with the Fox Lane High School teachers.
[00:18:38.080 --> 00:18:42.960]   [BLANK_AUDIO]
[00:18:42.960 --> 00:18:47.680]   >> So yeah, it's like kind of normal stuff, circular functions, inverse, reciprocal,
[00:18:47.680 --> 00:18:51.840]   slope, exponential polynomials.
[00:18:51.840 --> 00:18:54.240]   [BLANK_AUDIO]
[00:18:54.240 --> 00:18:59.600]   >> But using-
[00:18:59.600 --> 00:19:00.320]   >> That is so cool.
[00:19:00.320 --> 00:19:01.200]   [BLANK_AUDIO]
[00:19:01.200 --> 00:19:02.080]   >> This notation.
[00:19:02.080 --> 00:19:03.840]   [BLANK_AUDIO]
[00:19:03.840 --> 00:19:08.480]   >> The environment or where this was devised and-
[00:19:08.480 --> 00:19:09.280]   >> Yeah.
[00:19:09.280 --> 00:19:11.200]   >> The law of APL is-
[00:19:11.760 --> 00:19:16.880]   >> Although interestingly, he's got superscripts here.
[00:19:16.880 --> 00:19:18.080]   [BLANK_AUDIO]
[00:19:18.080 --> 00:19:22.800]   >> Which is not what we're using nowadays, we're using star.
[00:19:22.800 --> 00:19:24.240]   [BLANK_AUDIO]
[00:19:24.240 --> 00:19:28.880]   Although these reductions are the same, and he's got subscripts, that's also interesting.
[00:19:28.880 --> 00:19:39.680]   [BLANK_AUDIO]
[00:19:39.680 --> 00:19:43.040]   So anyways, so yeah, it starts off by talking about programming stuff,
[00:19:43.040 --> 00:19:45.040]   and then he's got a chapter about functions.
[00:19:45.040 --> 00:19:50.160]   [BLANK_AUDIO]
[00:19:50.160 --> 00:19:50.640]   All right.
[00:19:50.640 --> 00:19:52.880]   [BLANK_AUDIO]
[00:19:52.880 --> 00:19:54.320]   >> This was fascinating.
[00:19:54.320 --> 00:19:56.000]   Thank you so much Jeremy for sharing this.
[00:19:56.000 --> 00:19:57.840]   Now I know where to look them up.
[00:19:57.840 --> 00:19:58.560]   >> Yeah, no worries.
[00:19:58.560 --> 00:20:05.520]   Yeah, the J software website, jsoftware.com/papers has, yeah, a lot of,
[00:20:06.560 --> 00:20:13.680]   they seem to spend a lot of time scanning in and even though CRing a lot of stuff.
[00:20:13.680 --> 00:20:17.760]   [BLANK_AUDIO]
[00:20:17.760 --> 00:20:20.560]   >> I guess we can do the second example, can we?
[00:20:20.560 --> 00:20:23.200]   >> Yeah, so that's why I was saying we're gonna do forks next.
[00:20:23.200 --> 00:20:25.120]   [BLANK_AUDIO]
[00:20:25.120 --> 00:20:25.440]   Yeah.
[00:20:25.440 --> 00:20:26.800]   [BLANK_AUDIO]
[00:20:26.800 --> 00:20:28.240]   >> Same left, does that work?
[00:20:28.240 --> 00:20:29.600]   [BLANK_AUDIO]
[00:20:29.600 --> 00:20:30.800]   >> So that's a fork.
[00:20:30.800 --> 00:20:31.280]   Forks.
[00:20:31.280 --> 00:20:34.400]   [BLANK_AUDIO]
[00:20:34.400 --> 00:20:36.240]   Okay, so we've already talked about one fork.
[00:20:36.240 --> 00:20:45.040]   So the basic kind of idea that Adam said that maybe we can steal it directly.
[00:20:45.040 --> 00:20:48.400]   So I'm not gonna do as good a job as he did.
[00:20:48.400 --> 00:20:55.200]   [BLANK_AUDIO]
[00:20:55.200 --> 00:21:00.880]   Where did he mention forks?
[00:21:00.880 --> 00:21:03.120]   Oh, maybe it was after the last study session.
[00:21:03.120 --> 00:21:08.560]   [BLANK_AUDIO]
[00:21:08.560 --> 00:21:09.040]   Yep.
[00:21:09.040 --> 00:21:19.040]   [BLANK_AUDIO]
[00:21:19.040 --> 00:21:29.040]   [BLANK_AUDIO]
[00:21:29.040 --> 00:21:40.640]   Okay, well, let's try his example.
[00:21:44.320 --> 00:21:49.760]   So maybe, [BLANK_AUDIO]
[00:21:49.760 --> 00:21:57.200]   If we could do [BLANK_AUDIO]
[00:21:57.200 --> 00:22:05.760]   The reciprocal of three plus
[00:22:05.760 --> 00:22:10.960]   [BLANK_AUDIO]
[00:22:10.960 --> 00:22:15.120]   e to the power of three.
[00:22:15.120 --> 00:22:21.600]   And so here we've got f plus g where f is reciprocal and g is exp.
[00:22:21.600 --> 00:22:24.160]   And then we're adding them together.
[00:22:24.160 --> 00:22:29.120]   And so according to his example, that should be the same as
[00:22:29.120 --> 00:22:39.120]   [BLANK_AUDIO]
[00:22:39.280 --> 00:22:45.040]   that, which it is.
[00:22:45.040 --> 00:22:47.600]   Does that make sense?
[00:22:47.600 --> 00:22:54.720]   [BLANK_AUDIO]
[00:22:54.720 --> 00:22:58.000]   So first applies this to three, then it applies this to three,
[00:22:58.000 --> 00:23:00.480]   and then it applies this to the results.
[00:23:00.480 --> 00:23:06.400]   So the example we saw a little earlier was
[00:23:06.400 --> 00:23:10.000]   [BLANK_AUDIO]
[00:23:10.000 --> 00:23:13.600]   The very famous definition of the main,
[00:23:13.600 --> 00:23:19.840]   which is the sum divided by the count.
[00:23:19.840 --> 00:23:24.720]   [BLANK_AUDIO]
[00:23:24.720 --> 00:23:25.680]   So here's a function.
[00:23:25.680 --> 00:23:27.680]   [BLANK_AUDIO]
[00:23:27.680 --> 00:23:31.760]   >> I think we might be in the situation where we cannot see the-
[00:23:31.760 --> 00:23:32.640]   >> Sorry, how's that?
[00:23:32.640 --> 00:23:34.480]   >> Yeah, that's perfect.
[00:23:34.480 --> 00:23:38.320]   >> There's a function, there's a function, there's a function.
[00:23:38.320 --> 00:23:41.040]   So make sure you put this operator with the function on its left.
[00:23:41.040 --> 00:23:43.280]   [BLANK_AUDIO]
[00:23:43.280 --> 00:23:47.440]   Plus slash, there's the middle function, there's the right hand.
[00:23:47.440 --> 00:23:53.280]   So that's f, that's g, and that's what we're using instead of plus, using divide.
[00:23:53.280 --> 00:23:56.080]   So the sum divided by the count.
[00:23:56.080 --> 00:24:03.360]   [BLANK_AUDIO]
[00:24:03.360 --> 00:24:07.680]   So that is equal to two plus five plus eight plus nine divided by four.
[00:24:07.680 --> 00:24:09.280]   [BLANK_AUDIO]
[00:24:09.280 --> 00:24:10.080]   Does that make sense?
[00:24:10.080 --> 00:24:16.320]   [BLANK_AUDIO]
[00:24:16.320 --> 00:24:21.520]   So plus slash of 2589 divided by tally of 2589.
[00:24:21.520 --> 00:24:24.000]   [BLANK_AUDIO]
[00:24:24.000 --> 00:24:27.840]   And so something that's very interesting about this is that if we defined a function,
[00:24:27.840 --> 00:24:32.480]   and this is something that Aaron Shue talks about in his ArrayCast
[00:24:32.480 --> 00:24:38.240]   interview, we could define a function called mean.
[00:24:38.240 --> 00:24:41.040]   And that's how we would define it, right?
[00:24:41.040 --> 00:24:45.680]   [BLANK_AUDIO]
[00:24:45.680 --> 00:24:46.480]   And we could run it.
[00:24:46.480 --> 00:24:53.840]   And so the interesting point though is that the word mean has the same number
[00:24:53.840 --> 00:24:55.440]   of characters as its definition.
[00:24:56.960 --> 00:25:05.600]   So why define a function for this, rather than just use the definition anytime you
[00:25:05.600 --> 00:25:10.240]   want to use it, because that way you're being more explicit.
[00:25:10.240 --> 00:25:12.960]   That's a very good way to spell mean,
[00:25:12.960 --> 00:25:15.840]   because it actually tells you exactly how to do it.
[00:25:15.840 --> 00:25:20.400]   So it's a totally different way of thinking about software engineering is,
[00:25:20.400 --> 00:25:26.240]   yeah, not to create abstractions when you end up with an interaction
[00:25:26.320 --> 00:25:32.640]   where the number of letters in its name is the same as the number of characters in its definition.
[00:25:32.640 --> 00:25:36.320]   [BLANK_AUDIO]
[00:25:36.320 --> 00:25:37.600]   So I think that's interesting.
[00:25:37.600 --> 00:25:39.440]   So here's another interesting example.
[00:25:39.440 --> 00:25:44.480]   Okay, so before we do it, we need this one.
[00:25:44.480 --> 00:25:56.480]   [BLANK_AUDIO]
[00:25:56.480 --> 00:26:06.480]   So, [BLANK_AUDIO]
[00:26:06.480 --> 00:26:20.880]   So this one, which is a little thing pointing rightward, there's that, yeah, okay, backslash.
[00:26:20.880 --> 00:26:31.280]   [BLANK_AUDIO]
[00:26:31.280 --> 00:26:34.080]   Okay, this is called right tack, which makes sense.
[00:26:34.080 --> 00:26:35.760]   It does look like a tack pointing right.
[00:26:36.560 --> 00:26:40.080]   [BLANK_AUDIO]
[00:26:40.080 --> 00:26:41.040]   Right tack.
[00:26:41.040 --> 00:26:48.000]   [BLANK_AUDIO]
[00:26:48.000 --> 00:26:54.640]   And monadic is called same, and it's what we would normally call the identity function.
[00:26:54.640 --> 00:26:57.040]   [BLANK_AUDIO]
[00:26:57.040 --> 00:26:59.520]   And it just returns whatever it's passed.
[00:26:59.520 --> 00:27:09.360]   [BLANK_AUDIO]
[00:27:09.360 --> 00:27:11.120]   Okay, not much we can say about that, right?
[00:27:11.120 --> 00:27:18.080]   [BLANK_AUDIO]
[00:27:18.080 --> 00:27:25.520]   Diatic is called right, and it always returns its right argument.
[00:27:25.520 --> 00:27:35.520]   [BLANK_AUDIO]
[00:27:35.520 --> 00:27:46.320]   Okay, and I am pretty sure that left tack will do the exact opposite.
[00:27:46.320 --> 00:27:48.240]   [BLANK_AUDIO]
[00:27:48.240 --> 00:27:49.680]   Except monadic will be the same.
[00:27:49.680 --> 00:27:52.000]   [BLANK_AUDIO]
[00:27:52.000 --> 00:28:00.160]   So left tack, [BLANK_AUDIO]
[00:28:00.160 --> 00:28:01.920]   This vertical bar makes sense.
[00:28:01.920 --> 00:28:03.840]   [BLANK_AUDIO]
[00:28:03.840 --> 00:28:07.200]   Starting to get the hang of the mnemonics for the letters now.
[00:28:07.200 --> 00:28:12.080]   [BLANK_AUDIO]
[00:28:12.080 --> 00:28:15.520]   Generally you shift to get the kind of the other version of the same thing.
[00:28:15.520 --> 00:28:18.640]   [BLANK_AUDIO]
[00:28:18.640 --> 00:28:19.120]   Okay.
[00:28:19.120 --> 00:28:29.120]   [BLANK_AUDIO]
[00:28:29.120 --> 00:28:32.160]   Oops, I forgot to change this.
[00:28:32.160 --> 00:28:42.080]   [BLANK_AUDIO]
[00:28:42.080 --> 00:28:44.160]   Okay, that's pretty straightforward, yeah.
[00:28:44.160 --> 00:28:48.800]   [BLANK_AUDIO]
[00:28:48.800 --> 00:28:50.800]   So this next one is a fork.
[00:28:50.800 --> 00:28:54.560]   [BLANK_AUDIO]
[00:28:54.560 --> 00:29:03.760]   Which, okay, this one here might help to see each bit separately first maybe.
[00:29:03.760 --> 00:29:04.960]   [BLANK_AUDIO]
[00:29:04.960 --> 00:29:07.360]   Oh, this is a dyadic fork.
[00:29:07.360 --> 00:29:12.000]   [BLANK_AUDIO]
[00:29:12.000 --> 00:29:13.680]   I think a dyadic fork.
[00:29:13.680 --> 00:29:18.000]   [BLANK_AUDIO]
[00:29:18.000 --> 00:29:19.440]   I'm pretty sure, yes.
[00:29:19.440 --> 00:29:27.920]   [BLANK_AUDIO]
[00:29:27.920 --> 00:29:32.640]   Or a dyadic fork.
[00:29:32.640 --> 00:29:33.920]   [BLANK_AUDIO]
[00:29:33.920 --> 00:29:53.280]   H of f, oops, f and j past the left hand side and the right hand side.
[00:29:53.280 --> 00:29:55.760]   [BLANK_AUDIO]
[00:29:55.760 --> 00:30:01.280]   So this one's pretty straightforward.
[00:30:01.280 --> 00:30:03.040]   That's just gonna return the right hand side.
[00:30:03.040 --> 00:30:05.520]   [BLANK_AUDIO]
[00:30:05.520 --> 00:30:09.520]   So we can then combine those together.
[00:30:09.520 --> 00:30:13.600]   [BLANK_AUDIO]
[00:30:13.600 --> 00:30:14.160]   To say.
[00:30:14.160 --> 00:30:23.040]   [BLANK_AUDIO]
[00:30:23.040 --> 00:30:24.000]   Left hand side.
[00:30:24.000 --> 00:30:31.520]   [BLANK_AUDIO]
[00:30:31.520 --> 00:30:33.520]   And then the enclose.
[00:30:33.520 --> 00:30:36.640]   [BLANK_AUDIO]
[00:30:36.640 --> 00:30:40.160]   Then the right hand side, which I don't have to put in parentheses, but I'm just going to.
[00:30:40.160 --> 00:30:43.120]   [BLANK_AUDIO]
[00:30:43.120 --> 00:30:45.440]   Okay, now look, these are the same, right?
[00:30:45.440 --> 00:30:47.120]   [BLANK_AUDIO]
[00:30:47.120 --> 00:30:52.240]   Because this fork means that the left hand side and the right hand side are passed to this.
[00:30:52.240 --> 00:30:53.200]   [BLANK_AUDIO]
[00:30:53.200 --> 00:30:54.400]   And they're passed to this.
[00:30:54.400 --> 00:30:55.040]   [BLANK_AUDIO]
[00:30:55.040 --> 00:30:56.800]   And then this takes the two results.
[00:30:56.800 --> 00:30:57.920]   [BLANK_AUDIO]
[00:30:57.920 --> 00:31:06.880]   So this fork is something that will separate the string by spaces.
[00:31:06.880 --> 00:31:13.120]   And again, you could, well, not just by spaces, but by whatever's on the left.
[00:31:13.120 --> 00:31:18.320]   So we could create a function for that called split.
[00:31:18.320 --> 00:31:21.440]   But the name of the function will actually be more characters
[00:31:21.440 --> 00:31:23.280]   than the three characters it takes to define it.
[00:31:23.280 --> 00:31:25.760]   [BLANK_AUDIO]
[00:31:25.760 --> 00:31:26.560]   Does that make sense?
[00:31:26.560 --> 00:31:34.160]   [BLANK_AUDIO]
[00:31:34.160 --> 00:31:38.160]   Wouldn't it be more readable to use alpha and omega in such cases?
[00:31:38.160 --> 00:31:39.200]   [BLANK_AUDIO]
[00:31:39.200 --> 00:31:40.240]   This is very cryptic.
[00:31:40.240 --> 00:31:41.920]   [BLANK_AUDIO]
[00:31:41.920 --> 00:31:46.160]   I mean, everything's cryptic when you don't know it, right?
[00:31:46.160 --> 00:31:46.800]   [BLANK_AUDIO]
[00:31:46.800 --> 00:31:57.840]   I mean, if you do any work with math notation, in math notation, it's very cryptic.
[00:31:57.840 --> 00:31:58.880]   [LAUGH]
[00:31:58.880 --> 00:32:02.160]   So yeah, sure, it's very cryptic when you don't know it.
[00:32:02.160 --> 00:32:05.120]   [BLANK_AUDIO]
[00:32:05.120 --> 00:32:11.520]   I think it's error than alpha and omega once you know,
[00:32:11.520 --> 00:32:17.040]   because there's less to, at least for me, less to keep in my head.
[00:32:17.040 --> 00:32:24.240]   So the alpha and omega version, if you didn't want to do a fork, would be.
[00:32:24.240 --> 00:32:26.240]   [BLANK_AUDIO]
[00:32:26.240 --> 00:32:29.120]   >> You're replacing the space.
[00:32:29.120 --> 00:32:32.560]   >> Split would be defined as.
[00:32:32.560 --> 00:32:37.040]   [BLANK_AUDIO]
[00:32:37.040 --> 00:32:44.880]   >> Yeah. >> Alpha not equal to omega.
[00:32:44.880 --> 00:32:48.160]   [BLANK_AUDIO]
[00:32:48.160 --> 00:32:52.560]   Alpha omega, oops.
[00:32:52.560 --> 00:32:55.920]   [BLANK_AUDIO]
[00:32:55.920 --> 00:33:01.600]   >> You essentially have to do this in your head, if you want to, if I, right?
[00:33:01.600 --> 00:33:02.320]   [BLANK_AUDIO]
[00:33:02.320 --> 00:33:08.400]   I mean, kind of, like, yeah, same thing.
[00:33:08.400 --> 00:33:11.840]   [BLANK_AUDIO]
[00:33:11.840 --> 00:33:16.720]   I think once you get comfortable with abstractions, you kind of don't.
[00:33:16.720 --> 00:33:20.880]   Like, it just slots in there.
[00:33:20.880 --> 00:33:25.360]   I feel like this version, you have to do it in your head.
[00:33:26.240 --> 00:33:32.880]   For this version, I think you could read it as, like, fairly directly in English as,
[00:33:32.880 --> 00:33:38.560]   what's this name of this character, dyadic, I don't quite remember, whatever it is, match,
[00:33:38.560 --> 00:33:39.040]   or whatever.
[00:33:39.040 --> 00:33:44.640]   So it'd be like, you know, you could say, like, I should actually say the right words.
[00:33:44.640 --> 00:33:48.560]   [BLANK_AUDIO]
[00:33:48.560 --> 00:33:49.040]   Oops.
[00:33:49.040 --> 00:33:59.040]   [BLANK_AUDIO]
[00:33:59.040 --> 00:34:00.320]   Unique mask.
[00:34:00.320 --> 00:34:01.840]   Okay, so if you say.
[00:34:01.840 --> 00:34:07.520]   [BLANK_AUDIO]
[00:34:07.520 --> 00:34:12.080]   Unique mask partitions, the right hand side.
[00:34:12.080 --> 00:34:14.880]   [BLANK_AUDIO]
[00:34:14.880 --> 00:34:20.400]   You know, I think that's probably something that one could become comfortable
[00:34:20.400 --> 00:34:21.600]   thinking about that directly.
[00:34:21.600 --> 00:34:22.400]   [BLANK_AUDIO]
[00:34:22.400 --> 00:34:23.200]   I can see that.
[00:34:23.200 --> 00:34:26.400]   [BLANK_AUDIO]
[00:34:26.400 --> 00:34:29.600]   It reminds me of your surprise the other day when I mentioned, you know, my daughter
[00:34:29.600 --> 00:34:35.200]   found it to understand APL than the normal math notation.
[00:34:35.200 --> 00:34:40.560]   But, like, I think we're just kind of, like, reflecting our own years of studying, you know?
[00:34:40.560 --> 00:34:42.160]   [BLANK_AUDIO]
[00:34:42.160 --> 00:34:50.800]   I actually think, yeah, so, I don't know, like, I'm not an APL speaker by any means, so.
[00:34:50.800 --> 00:34:54.080]   [BLANK_AUDIO]
[00:34:54.080 --> 00:34:58.560]   All right, I think that's super interesting anyway, it's fun.
[00:34:58.560 --> 00:35:00.000]   [BLANK_AUDIO]
[00:35:00.000 --> 00:35:01.680]   I think that's what's intriguing to me.
[00:35:01.680 --> 00:35:05.600]   Like, it's interesting research to kind of think about this alternative notation and
[00:35:05.600 --> 00:35:08.000]   what it might mean to be comfortable with it.
[00:35:08.000 --> 00:35:11.120]   And, you know, hopefully my daughter will teach me.
[00:35:11.120 --> 00:35:12.160]   [BLANK_AUDIO]
[00:35:12.160 --> 00:35:17.520]   That by doing it.
[00:35:17.520 --> 00:35:18.160]   [BLANK_AUDIO]
[00:35:18.160 --> 00:35:19.280]   Okay, let's do these errors.
[00:35:19.280 --> 00:35:25.920]   [BLANK_AUDIO]
[00:35:25.920 --> 00:35:32.400]   I'm gonna do them before partition and stuff because I want to segue into fork.
[00:35:32.400 --> 00:35:38.800]   [BLANK_AUDIO]
[00:35:38.800 --> 00:35:43.120]   So, we're using forks and trains interchangeably, or trains are-
[00:35:43.120 --> 00:35:46.800]   >> So, trains are great questions.
[00:35:46.800 --> 00:35:52.080]   So, trains just refer to a bunch of functions next to each other with no other punctuation.
[00:35:52.080 --> 00:36:02.560]   So, a train, you know, an example of a train would be the one that we did for the power operator.
[00:36:02.560 --> 00:36:03.600]   >> Yeah.
[00:36:03.600 --> 00:36:09.920]   >> Super fun, at least I thought so.
[00:36:09.920 --> 00:36:14.480]   [BLANK_AUDIO]
[00:36:14.480 --> 00:36:15.360]   This is a train.
[00:36:15.360 --> 00:36:19.040]   [BLANK_AUDIO]
[00:36:19.040 --> 00:36:22.800]   Now, this train, we had
[00:36:22.800 --> 00:36:26.960]   [BLANK_AUDIO]
[00:36:26.960 --> 00:36:30.320]   Function, operator, function, operator, function.
[00:36:30.320 --> 00:36:31.440]   So, it's different, right?
[00:36:31.440 --> 00:36:35.120]   So, I guess this is a function and then this is an operator and this is a function.
[00:36:35.120 --> 00:36:37.200]   I think you'd still call that a train.
[00:36:37.200 --> 00:36:45.920]   Another example of a train would be- >> We did a two train today.
[00:36:45.920 --> 00:36:47.520]   [BLANK_AUDIO]
[00:36:47.520 --> 00:36:48.640]   Did we do a two train today?
[00:36:48.640 --> 00:36:49.200]   When was that?
[00:36:49.200 --> 00:36:50.240]   [BLANK_AUDIO]
[00:36:50.240 --> 00:36:55.440]   >> Yeah, it was, I think, under dyadic partition.
[00:36:55.440 --> 00:37:05.280]   >> The one that you copied from, oh, here, line 31.
[00:37:05.280 --> 00:37:09.200]   [BLANK_AUDIO]
[00:37:09.200 --> 00:37:10.400]   That's a two train, right?
[00:37:10.400 --> 00:37:13.120]   >> There's no train here.
[00:37:13.120 --> 00:37:16.240]   [BLANK_AUDIO]
[00:37:16.240 --> 00:37:17.920]   >> No, this is a three train, no?
[00:37:17.920 --> 00:37:21.280]   >> This is a three train, which is called a fork.
[00:37:21.280 --> 00:37:26.000]   >> Yes, that's why we're- >> Right, so you're looking for a two train.
[00:37:26.000 --> 00:37:27.840]   I just want to come up with an example of a two train.
[00:37:27.840 --> 00:37:31.760]   So, a two train, for example, two trains are much easier to understand because they're
[00:37:31.760 --> 00:37:35.040]   exactly the same as beside or jot.
[00:37:35.040 --> 00:37:49.360]   So, if we did to the power of the reciprocal, we don't even need that, right?
[00:37:49.360 --> 00:37:54.000]   Then it's going to just, you just read right from it, one over three, e to the power of that.
[00:37:54.000 --> 00:37:59.680]   Right, so that's the same as- >> No special rules, right?
[00:37:59.680 --> 00:38:02.480]   >> Yeah, no special rules.
[00:38:02.480 --> 00:38:11.760]   And in the dyadic case, then like that, then I believe it does three divided by
[00:38:11.760 --> 00:38:15.040]   three first, and then does e to the power of that.
[00:38:15.040 --> 00:38:16.560]   So, that's going to be e to the power of one.
[00:38:16.560 --> 00:38:19.920]   >> Okay, that's interesting.
[00:38:19.920 --> 00:38:22.800]   >> And then this case is different, right?
[00:38:22.800 --> 00:38:24.480]   Because now it's treating it as this.
[00:38:24.480 --> 00:38:30.960]   So, that's going to be three to the power of the third, which will be the cube root of three.
[00:38:30.960 --> 00:38:39.760]   Now, in j, this means something else.
[00:38:39.760 --> 00:38:43.920]   This means something else, just to this way.
[00:38:44.960 --> 00:38:49.440]   It would be the same as- >> Three on both sides.
[00:38:49.440 --> 00:38:51.520]   >> It would be the same as putting three on both sides.
[00:38:51.520 --> 00:38:54.000]   And that in j is called a hook.
[00:38:54.000 --> 00:39:02.400]   So, Adam's point is that we don't need a special thing for hook because we can always use-
[00:39:02.400 --> 00:39:07.440]   >> Until the- >> We can always use same.
[00:39:09.840 --> 00:39:16.080]   We can put it there or we can put it on the other side to say, yeah, or you can use total diuresis.
[00:39:16.080 --> 00:39:20.640]   Yeah, okay.
[00:39:20.640 --> 00:39:25.280]   So, yeah, I think trains are just bunches of functions next to each other.
[00:39:25.280 --> 00:39:32.960]   Okay, so let's do the arrows, which I do see a lot.
[00:39:32.960 --> 00:39:35.040]   So, it'd be nice to know what they mean.
[00:39:38.640 --> 00:39:40.640]   Presumably, they're going to call this up arrow.
[00:39:40.640 --> 00:39:41.280]   One would hook.
[00:39:41.280 --> 00:39:47.920]   Needs a space.
[00:39:47.920 --> 00:39:51.440]   Up arrow.
[00:39:51.440 --> 00:39:59.440]   How about that?
[00:40:07.840 --> 00:40:10.960]   All right, and it's called, oh gosh, what's this again?
[00:40:10.960 --> 00:40:13.920]   I think elk version is two, isn't it?
[00:40:13.920 --> 00:40:17.600]   One, okay.
[00:40:17.600 --> 00:40:20.320]   So, it's called mix.
[00:40:20.320 --> 00:40:26.560]   Does anybody know why one would change this quad ML thing?
[00:40:26.560 --> 00:40:30.240]   I remember it refers to kind of like the version of the language or something.
[00:40:30.240 --> 00:40:34.000]   Mix or take.
[00:40:37.680 --> 00:40:39.280]   I like it.
[00:40:39.280 --> 00:40:44.400]   Maybe it's just for kind of compatibility.
[00:40:44.400 --> 00:40:48.480]   Mix.
[00:40:48.480 --> 00:40:52.400]   Mix hip hop.
[00:40:52.400 --> 00:41:01.520]   Okay, so.
[00:41:01.520 --> 00:41:12.320]   It looks like it's doing the opposite of that.
[00:41:12.320 --> 00:41:17.120]   It seems to kind of go the opposite direction before, didn't we?
[00:41:17.120 --> 00:41:19.840]   From here to here.
[00:41:19.840 --> 00:41:22.400]   What's the rule?
[00:41:22.400 --> 00:41:26.960]   What's the rule of this rank of this?
[00:41:26.960 --> 00:41:29.040]   This one here.
[00:41:29.040 --> 00:41:31.920]   So, this is going to be, so the shape of this is going to be two, three.
[00:41:31.920 --> 00:41:43.600]   Where else the shape of this is two.
[00:41:43.600 --> 00:41:49.120]   Yeah.
[00:41:49.120 --> 00:41:56.000]   Does anybody remember how to go from the matrix to the
[00:41:58.240 --> 00:41:59.600]   two enclosed versions?
[00:41:59.600 --> 00:42:03.840]   Wasn't that the left shoe?
[00:42:03.840 --> 00:42:07.760]   Let me try.
[00:42:07.760 --> 00:42:18.640]   This one?
[00:42:18.640 --> 00:42:21.760]   Destroyed, I don't know, I'm guessing.
[00:42:21.760 --> 00:42:23.360]   They're just wrap signals.
[00:42:23.360 --> 00:42:24.480]   No, that's not what you want.
[00:42:24.480 --> 00:42:30.240]   Right.
[00:42:30.240 --> 00:42:32.480]   We could do that with each, I guess.
[00:42:32.480 --> 00:42:40.240]   How about row to reshape?
[00:42:40.240 --> 00:42:45.680]   That's not going to be the same thing because you want to actually
[00:42:45.680 --> 00:42:52.080]   enclose them.
[00:42:53.200 --> 00:42:55.600]   Oh, yeah, an H. Oh.
[00:42:55.600 --> 00:43:01.120]   What about the rank operator?
[00:43:01.120 --> 00:43:03.280]   Which one's the rank operator again?
[00:43:03.280 --> 00:43:03.920]   Is this one?
[00:43:03.920 --> 00:43:05.920]   Yes.
[00:43:05.920 --> 00:43:18.240]   Okay.
[00:43:18.240 --> 00:43:20.720]   I'm sure we had a better way than that.
[00:43:21.520 --> 00:43:24.960]   All right.
[00:43:24.960 --> 00:43:25.360]   So.
[00:43:25.360 --> 00:43:44.880]   It's going to look at what it's defined as.
[00:43:44.880 --> 00:43:57.200]   An array whose items may be uniform in rank and shape or they might differ.
[00:43:57.200 --> 00:44:00.800]   Okay.
[00:44:00.800 --> 00:44:03.200]   Let's ignore the non-uniform case for a while.
[00:44:03.200 --> 00:44:07.840]   So then R is an array composed of the items of Y
[00:44:07.840 --> 00:44:13.440]   assembled into a higher rank array with one less level of nesting.
[00:44:14.720 --> 00:44:15.200]   Okay.
[00:44:15.200 --> 00:44:16.960]   That's exactly what we saw.
[00:44:16.960 --> 00:44:21.120]   So we started out with a rank one array and we got a rank two array.
[00:44:21.120 --> 00:44:23.760]   And we have one less level of nesting.
[00:44:23.760 --> 00:44:26.640]   So the depth used to be true and I guess the depth is now one.
[00:44:26.640 --> 00:44:29.520]   If I remember the definition of depth correctly.
[00:44:29.520 --> 00:44:35.360]   If they have different ranks, each item is extended in rank
[00:44:35.360 --> 00:44:40.720]   to that of its greatest rank by padding with leading ones.
[00:44:42.720 --> 00:44:45.360]   Oh, the rank is padded with relating ones.
[00:44:45.360 --> 00:44:46.240]   Okay.
[00:44:46.240 --> 00:44:49.040]   So for their example here.
[00:44:49.040 --> 00:45:09.600]   Yeah.
[00:45:09.600 --> 00:45:12.320]   So this is a vector.
[00:45:12.320 --> 00:45:13.200]   This is a scalar.
[00:45:13.200 --> 00:45:14.160]   This is a scalar.
[00:45:14.160 --> 00:45:19.040]   So this would get padded to become a one element vector.
[00:45:19.040 --> 00:45:26.000]   This would become a one element vector.
[00:45:26.000 --> 00:45:37.360]   So presumably if we did that manually.
[00:45:37.360 --> 00:45:43.600]   We would get the same thing.
[00:45:43.600 --> 00:45:51.600]   And then y.
[00:45:51.600 --> 00:45:53.120]   Yep.
[00:45:53.120 --> 00:45:54.160]   That's the same thing.
[00:45:54.160 --> 00:46:04.240]   So that's what they're saying is being done implicitly.
[00:46:06.320 --> 00:46:08.720]   Okay, so if they're different ranks, you get the ones.
[00:46:08.720 --> 00:46:10.560]   Okay, then I got different shapes, which they do.
[00:46:10.560 --> 00:46:15.680]   So now each is padded with the corresponding prototype.
[00:46:15.680 --> 00:46:23.520]   I think that a prototype is the kind of like base default value of a type.
[00:46:23.520 --> 00:46:26.240]   So for a number, the prototype is zero.
[00:46:26.240 --> 00:46:31.440]   I wish these kind of things had hyperlinks though to definitions.
[00:46:31.440 --> 00:46:35.120]   So that's why we ended up with zeros.
[00:46:36.080 --> 00:46:42.400]   So in other words, we could do the same thing by doing it manually.
[00:46:42.400 --> 00:46:47.280]   So there's the same thing.
[00:46:47.280 --> 00:46:49.040]   Okay.
[00:46:49.040 --> 00:46:56.480]   So let's do the dyadic version, shall we?
[00:46:56.480 --> 00:47:01.920]   Oh, there we go.
[00:47:04.480 --> 00:47:07.840]   Yeah, so if anybody can figure out how to go from the matrix back to the
[00:47:07.840 --> 00:47:14.720]   array of arrays more conveniently than my ugly version, let me know.
[00:47:14.720 --> 00:47:16.480]   Oh, there's things in the chat.
[00:47:16.480 --> 00:47:22.640]   You can do it by providing access to the shoe operator.
[00:47:22.640 --> 00:47:26.080]   Okay, great.
[00:47:26.080 --> 00:47:28.000]   Thanks, Vish.
[00:47:29.040 --> 00:47:37.920]   So although Adam's told us to kind of avoid access, but there we go.
[00:47:37.920 --> 00:47:44.240]   Hang on, I'm trying to go the other direction.
[00:47:44.240 --> 00:47:46.000]   I'm trying to start with the matrix.
[00:47:46.000 --> 00:47:49.280]   Oh yeah, which is what this has got it.
[00:47:49.280 --> 00:47:51.920]   And then Molly's got an example.
[00:47:57.600 --> 00:48:00.480]   Okay, so what this is going to do is it's going to be
[00:48:00.480 --> 00:48:06.880]   a three by three matrix containing one, two, zero, three, zero, zero, four, five, six.
[00:48:06.880 --> 00:48:10.480]   And I don't think these parentheses are needed, are they Molly?
[00:48:10.480 --> 00:48:14.320]   Hey.
[00:48:14.320 --> 00:48:21.120]   Thank you.
[00:48:21.120 --> 00:48:24.880]   All right.
[00:48:27.120 --> 00:48:27.600]   Take.
[00:48:27.600 --> 00:48:31.280]   Well, this looks nice and easy.
[00:48:31.280 --> 00:48:35.600]   In other languages, I think we'd call this head.
[00:48:35.600 --> 00:48:38.240]   Oh, or if you do negative, it's tail.
[00:48:38.240 --> 00:48:39.920]   I like that.
[00:48:39.920 --> 00:48:42.800]   I love that they don't create more functions than needed.
[00:48:42.800 --> 00:48:46.960]   Why not just use negative?
[00:48:46.960 --> 00:48:54.560]   Okay, so that just takes the first n characters or the last n characters.
[00:48:55.360 --> 00:49:15.680]   Okay, so let's create a matrix.
[00:49:18.320 --> 00:49:25.440]   Of three by four of iota 12.
[00:49:25.440 --> 00:49:41.360]   And why do they go straight to the hard one?
[00:49:41.360 --> 00:49:44.080]   Let's just start with, okay, what if we do that?
[00:49:47.840 --> 00:49:49.520]   And let me print this out, shall we?
[00:49:49.520 --> 00:49:54.960]   What's the keyboard shortcut for quad?
[00:49:54.960 --> 00:49:55.440]   Here it is.
[00:49:55.440 --> 00:50:01.760]   Bar, vertical bar.
[00:50:01.760 --> 00:50:02.960]   Wait, I'm confused.
[00:50:02.960 --> 00:50:06.000]   I thought that was, that's that.
[00:50:06.000 --> 00:50:12.160]   It's an L.
[00:50:12.160 --> 00:50:13.760]   Oh, it's an L.
[00:50:13.760 --> 00:50:16.000]   Thank you.
[00:50:17.520 --> 00:50:19.360]   All right, great.
[00:50:19.360 --> 00:50:22.880]   So this is going to grab the first two rows of the matrix.
[00:50:22.880 --> 00:50:24.560]   Cool.
[00:50:24.560 --> 00:50:28.480]   And this is the first two rows and the last three columns of the matrix.
[00:50:28.480 --> 00:50:34.880]   Okay, so here's a nice easy way to index into contiguous sections of an array.
[00:50:34.880 --> 00:50:38.320]   Is everybody okay with that?
[00:50:38.320 --> 00:50:45.120]   So two minus three is going to be the first two rows, last three columns of this bit here.
[00:50:45.120 --> 00:50:48.560]   All right.
[00:50:48.560 --> 00:50:52.640]   Well, now I'm curious about what the other arrow is going to be.
[00:50:52.640 --> 00:51:03.600]   Oh, one other thing was taking more than the amount that was in the array.
[00:51:03.600 --> 00:51:04.720]   Oh, thank you.
[00:51:04.720 --> 00:51:08.160]   Taking more than the amount in the array.
[00:51:08.160 --> 00:51:12.400]   So like five rows, for example.
[00:51:12.400 --> 00:51:15.280]   Okay, so I get spaces in the case.
[00:51:15.280 --> 00:51:17.040]   Oh, I think that's going to be called its prototype.
[00:51:17.040 --> 00:51:21.680]   And for the matrix, you're going to get zeros.
[00:51:21.680 --> 00:51:22.960]   Okay, again, the prototype.
[00:51:22.960 --> 00:51:23.920]   Cool.
[00:51:23.920 --> 00:51:30.560]   So yes, I think the space is the prototype for a character and zero is a prototype for a number.
[00:51:30.560 --> 00:51:35.280]   Okay, is that all that?
[00:51:35.280 --> 00:51:39.200]   Have we missed anything else, Molly, or you think that's it?
[00:51:40.320 --> 00:51:47.520]   Um, well, in the case of, oh, here's an example that I wanted to share.
[00:51:47.520 --> 00:51:50.400]   Put it in chat very quick.
[00:51:50.400 --> 00:51:50.720]   Thanks.
[00:51:50.720 --> 00:51:54.240]   Because I found this behavior a bit odd.
[00:51:54.240 --> 00:51:59.280]   Sorry, not what I expected.
[00:51:59.280 --> 00:52:02.640]   Okay, let's see what you got.
[00:52:08.400 --> 00:52:11.520]   Okay.
[00:52:11.520 --> 00:52:14.560]   All right, so you've got.
[00:52:14.560 --> 00:52:22.320]   So the the empty one.
[00:52:22.320 --> 00:52:26.480]   Oh, you're getting too many things.
[00:52:26.480 --> 00:52:27.760]   Wait, what?
[00:52:27.760 --> 00:52:31.280]   Okay, so it's it's repeating the first one.
[00:52:31.280 --> 00:52:33.040]   Yeah, the first one.
[00:52:33.040 --> 00:52:33.920]   With prototypes.
[00:52:33.920 --> 00:52:35.200]   Okay.
[00:52:35.200 --> 00:52:37.680]   Okay, I'm not going to leave this in here,
[00:52:37.680 --> 00:52:41.280]   because that sounds like a weird edge case that people can figure out,
[00:52:41.280 --> 00:52:43.440]   but that is interesting and surprising.
[00:52:43.440 --> 00:52:51.120]   All right.
[00:52:51.120 --> 00:52:53.360]   How much battery have I got?
[00:52:53.360 --> 00:52:56.720]   Ten percent.
[00:52:56.720 --> 00:52:58.240]   Okay, shouldn't be too bad.
[00:53:05.840 --> 00:53:08.960]   Presumably, if I type down here, I'm going to get the down arrow.
[00:53:08.960 --> 00:53:12.720]   The down arrow does the thing that you wanted to do.
[00:53:12.720 --> 00:53:13.440]   Oh, all right.
[00:53:13.440 --> 00:53:15.600]   Yes, it does.
[00:53:15.600 --> 00:53:18.080]   Lovely.
[00:53:18.080 --> 00:53:21.360]   Great, let's deal now.
[00:53:21.360 --> 00:53:22.240]   Matrix then.
[00:53:22.240 --> 00:53:31.440]   And it's year.
[00:53:31.440 --> 00:53:34.640]   How about that?
[00:53:35.440 --> 00:53:38.480]   Well, that's that's exactly as it should be.
[00:53:38.480 --> 00:53:38.980]   Okay.
[00:53:38.980 --> 00:53:42.640]   And you can also do it with an axis.
[00:53:42.640 --> 00:53:46.560]   Okay, and then drop.
[00:53:46.560 --> 00:53:47.200]   That's great.
[00:53:47.200 --> 00:53:53.360]   Everything except for.
[00:53:53.360 --> 00:54:12.160]   I wonder how close we are to finishing.
[00:54:12.160 --> 00:54:14.000]   There's still a lot of symbols we haven't done.
[00:54:14.000 --> 00:54:18.400]   I feel like we've done a lot.
[00:54:18.400 --> 00:54:22.560]   Okay, everything except the first four.
[00:54:22.560 --> 00:54:25.600]   Now, what's this?
[00:54:25.600 --> 00:54:28.000]   Okay, makes sense.
[00:54:28.000 --> 00:54:31.760]   Everything except the last five.
[00:54:31.760 --> 00:54:35.600]   And it makes sense as well.
[00:54:35.600 --> 00:54:40.640]   Everything except the first two rows.
[00:54:40.640 --> 00:54:44.800]   And everything except those rows.
[00:54:44.800 --> 00:54:46.720]   Oh, well, actually, I'm not sure what this is going to do.
[00:54:46.720 --> 00:54:48.720]   Let's see if we can figure it out.
[00:54:49.520 --> 00:54:52.880]   Everything except these is something of a weird shape.
[00:54:52.880 --> 00:54:53.920]   So what's going to happen?
[00:54:53.920 --> 00:55:05.200]   Oh, I see none of the top two rows.
[00:55:05.200 --> 00:55:10.480]   And none of the last three columns means you're left with this.
[00:55:10.480 --> 00:55:12.080]   So this is actually doing something.
[00:55:12.080 --> 00:55:16.320]   Yeah, a bit different.
[00:55:16.320 --> 00:55:19.200]   So we get rid of all those columns.
[00:55:19.200 --> 00:55:20.640]   And we get rid of all these rows.
[00:55:20.640 --> 00:55:22.080]   And you're left with just the number nine.
[00:55:22.080 --> 00:55:29.280]   Okay, those sound like very useful things to know about.
[00:55:29.280 --> 00:55:36.160]   Anything else to chat about before we go?
[00:55:36.160 --> 00:55:41.760]   A productive day.
[00:55:41.760 --> 00:55:48.800]   Before the symbols, I will encourage other people to try to do the competition.
[00:55:48.800 --> 00:55:58.880]   Serato, did you use the arrows much in your competition?
[00:55:58.880 --> 00:56:00.320]   A lot.
[00:56:00.320 --> 00:56:01.360]   A lot.
[00:56:01.360 --> 00:56:01.600]   Great.
[00:56:01.600 --> 00:56:04.640]   Yeah, I feel like I see them around.
[00:56:04.640 --> 00:56:08.000]   Sorry.
[00:56:08.000 --> 00:56:14.480]   Excuse me, but is the competition available again?
[00:56:14.480 --> 00:56:17.760]   You're very hard to hear, Radek.
[00:56:18.080 --> 00:56:19.280]   You're very...
[00:56:19.280 --> 00:56:20.720]   I think it should be better now.
[00:56:20.720 --> 00:56:22.000]   Oh, yes, that's much better.
[00:56:22.000 --> 00:56:22.720]   Thank you.
[00:56:22.720 --> 00:56:24.160]   Sorry, sorry, switch to...
[00:56:24.160 --> 00:56:31.680]   So I'm wondering if the competition is back available again for this year, the 2022.
[00:56:31.680 --> 00:56:37.120]   I don't know, but based on the test case they show in the screen,
[00:56:37.120 --> 00:56:43.040]   you should be able to try working on it as well.
[00:56:43.040 --> 00:56:45.520]   Perfect.
[00:56:45.520 --> 00:56:46.320]   Yeah.
[00:56:46.320 --> 00:56:53.520]   But when you submit, you'll find out they actually have more edge case in the test,
[00:56:53.520 --> 00:56:55.680]   so you get your head around it.
[00:56:55.680 --> 00:56:59.840]   I can always do it previously as one, as Serato mentioned before.
[00:56:59.840 --> 00:57:03.360]   And there are write-ups on the forums.
[00:57:03.360 --> 00:57:04.800]   They are awesome.
[00:57:04.800 --> 00:57:12.880]   So combining, trying to do the competition with looking at the forums after a couple of tries,
[00:57:13.600 --> 00:57:17.680]   that sounds like a really nice way of learning this stuff.
[00:57:17.680 --> 00:57:24.880]   I don't see a way to see the current year's ones, because it tells you...
[00:57:24.880 --> 00:57:29.760]   Yeah, I don't see it on their webpage.
[00:57:29.760 --> 00:57:31.680]   It might be...
[00:57:31.680 --> 00:57:34.640]   Yeah, I might have to wait.
[00:57:34.640 --> 00:57:40.640]   But last time they have the PDF done, maybe I can post it.
[00:57:40.640 --> 00:57:42.400]   Yeah, please do, because I don't see it.
[00:57:43.040 --> 00:57:45.280]   Yeah, and then you can just space on the test case.
[00:57:45.280 --> 00:57:45.280]   That'd be great.
[00:57:45.280 --> 00:57:51.360]   They only have four test cases, and then at least you have some time return to work on.
[00:57:51.360 --> 00:58:00.320]   Or alternatively, maybe post a notebook or something with the questions,
[00:58:00.320 --> 00:58:02.080]   but not the answers or something.
[00:58:02.080 --> 00:58:02.880]   I don't know.
[00:58:02.880 --> 00:58:03.120]   Yeah.
[00:58:03.120 --> 00:58:04.400]   Yeah.
[00:58:04.400 --> 00:58:04.880]   That'd be cool.
[00:58:04.880 --> 00:58:05.120]   Okay.
[00:58:05.120 --> 00:58:07.040]   Bye.
[00:58:07.040 --> 00:58:07.600]   Thanks.
[00:58:07.600 --> 00:58:08.320]   Bye, everybody.
[00:58:08.320 --> 00:58:10.480]   Have a good one.
[00:58:10.480 --> 00:58:10.720]   Bye.
[00:58:10.720 --> 00:58:11.540]   - Okay. - Thanks.
[00:58:11.540 --> 00:58:12.380]   - Yep.

