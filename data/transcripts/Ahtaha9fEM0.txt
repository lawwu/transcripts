
[00:00:00.000 --> 00:00:19.880]   Hey everyone. So we're gonna go ahead and get started here. We've got a nice
[00:00:19.880 --> 00:00:26.240]   close group here today and that's I think to everyone's benefit. This workshop is
[00:00:26.240 --> 00:00:29.800]   really for you. You know I love the sound of my own voice. I love talking. That's
[00:00:29.800 --> 00:00:35.380]   why I'm a developer advocate. But the purpose of this workshop is to help you
[00:00:35.380 --> 00:00:40.620]   get comfortable with SGLang. So if you have questions, if you have ideas, if you
[00:00:40.620 --> 00:00:48.160]   have bugs, ask your name or me. And we're definitely going to be able to tailor this
[00:00:48.160 --> 00:00:53.380]   workshop to you and your interests and what you're working on. So the title of
[00:00:53.380 --> 00:00:59.600]   this workshop is an introduction to LLM serving with SGLang. We're going to be
[00:00:59.600 --> 00:01:05.180]   talking about SGLang and a little quick introduction. So my co-speaker
[00:01:05.180 --> 00:01:10.740]   here, Yaneng, is a core maintainer of SGLang, has been involved with LMSys
[00:01:10.740 --> 00:01:16.820]   org for quite a while now, is the sort of like inference lead on the project,
[00:01:16.820 --> 00:01:23.420]   previously worked at Baidu and some other places, and also is, you're an author of a
[00:01:23.420 --> 00:01:29.000]   a few papers, including Flash Info. And I'm Phillip, and I got a B+ in linear algebra.
[00:01:29.000 --> 00:01:34.560]   So whether, you know, whether you're coming in here and you're super cracked, or you're
[00:01:34.560 --> 00:01:40.000]   brand new at SGLang, we're going to have something for you. Whatever your skill level, this is,
[00:01:40.000 --> 00:01:44.880]   this is the place to be. So what are we going to do today? We're going to, you know, introduce
[00:01:44.880 --> 00:01:50.060]   SGLang, get set up a little bit. We're going to talk about the history of SGLang,
[00:01:50.060 --> 00:01:56.020]   talk about deploying your first model, bunch of things you can do to optimize performance after
[00:01:56.020 --> 00:02:01.060]   that. And then we're also going to talk a little bit about the SGLang community and how you can get
[00:02:01.060 --> 00:02:05.540]   involved and even do a little bit of a tour of the code base in case you want to start making open
[00:02:05.540 --> 00:02:14.540]   source contributions. So by way of introduction, let's see. What is SGLang? So SGLang is an open
[00:02:14.540 --> 00:02:20.160]   source, fast-serving framework for large language models and large vision models. Generally, you use
[00:02:20.160 --> 00:02:27.760]   SGLang in a sentence along with either VLLM or TensorRT LLM. It's one of the multiple options for serving
[00:02:27.760 --> 00:02:35.540]   models in production. So the question is, why SGLang? Like, why should we, you know, invest in
[00:02:35.540 --> 00:02:43.540]   learning and building this library? And, you know, first off, it's very performant. SGLang offers
[00:02:43.540 --> 00:02:49.320]   excellent performance on a wide variety of GPUs. It's production-ready out of the box. It's got
[00:02:49.320 --> 00:02:56.660]   DayZero support for new model releases from labs like Quen and DeepSeq. And it's got a great community,
[00:02:56.660 --> 00:03:01.860]   strong open source ethos, which means that if something is broken in SGLang, if you don't like
[00:03:01.860 --> 00:03:09.860]   something, you can fix it, which is, which is pretty huge advantage. So who uses SGLang? Well,
[00:03:09.860 --> 00:03:16.740]   we do at Base 10. We use it as part of our inference stack for a variety of different models that we run.
[00:03:16.740 --> 00:03:25.860]   We also see SGLang being used very heavily by XAI for their Glock models, as well as a wide variety of
[00:03:25.860 --> 00:03:31.860]   inference providers and cloud providers and research labs, universities, and even product companies like
[00:03:31.860 --> 00:03:33.860]   Cursor.
[00:03:33.860 --> 00:03:41.860]   So quick history of SGLang. It's honestly really impressive to me how quickly this project has come up and gotten big.
[00:03:41.860 --> 00:03:47.860]   If you look at, you know, the archive paper was released in December 2023. That's 18 months ago.
[00:03:47.860 --> 00:03:55.860]   So in just 18 months, this project has gone from a paper to 15,000 GitHub stars, almost. You should all go star it so that we can
[00:03:55.860 --> 00:04:03.860]   get a little closer. And it's, you know, supporting all of those logos, all those companies we saw on the last slide.
[00:04:03.860 --> 00:04:11.860]   It's got a growing and vibrant community. It's got international adoption. So yeah, incredibly impressive what the team has done in
[00:04:11.860 --> 00:04:17.860]   that time. And I'm going to turn over to Yanang now to talk a little bit more about that history and also like how you got
[00:04:17.860 --> 00:04:19.860]   involved in the project.
[00:04:19.860 --> 00:04:29.860]   Okay. Hello. I'm Yanang. I'm the co-developer of the SGLang project. And I'm also the software engineer at Base 10. And before I joined
[00:04:29.860 --> 00:04:39.860]   base 10, I worked at Meituan. And at that time, I worked for the internal click-through rate, ranking model optimization,
[00:04:39.860 --> 00:04:47.860]   and the LM inference optimization. And at that time, the creator of SGLang named Lian Ming just reached out and then we
[00:04:47.860 --> 00:04:57.860]   have Google Meet. So at that time, when I left Meituan, I joined the SGLang project. So I worked closely with Lian Ming and
[00:04:57.860 --> 00:05:05.860]   Ying on SGLang. Also, you know, SGLang used Flash Infer heavily because we use Flash Infer as the attention
[00:05:05.860 --> 00:05:13.860]   kernel library and the sampling kernel library. So I also worked with Tzu Hao on the Flash Infer project. And
[00:05:13.860 --> 00:05:21.860]   yeah, currently, I'm the co-maintener of the SGLang project. And I'm also the team member at LMSys.org.
[00:05:21.860 --> 00:05:27.860]   And that's the little point of trivia. That's the same LMSys.org that just got $100 million to build
[00:05:27.860 --> 00:05:35.860]   Chatbot Arena from A16Z. I learned that while I was putting together the slides for this talk. So if you
[00:05:35.860 --> 00:05:43.860]   were here early, you were able to scan this QR code and get everything set up for the workshop. If not,
[00:05:43.860 --> 00:05:49.860]   definitely grab that right now. You've got the QR code, you've got the URL that takes you to the same
[00:05:49.860 --> 00:05:57.860]   place. Does anyone still need the QR code? Okay, I've got a couple people still. All right.
[00:06:05.860 --> 00:06:17.860]   Anyone still need the QR code? Going once. Going twice. Yep.
[00:06:17.860 --> 00:06:23.860]   To folks watching at home, you've got this great button on YouTube. It's called the Fast Forward
[00:06:23.860 --> 00:06:41.860]   button so you can just skip this part. All right. We are looking good. If you need this again,
[00:06:41.860 --> 00:06:49.860]   just let me know. I'll throw it back up there. So we're going to talk about how to deploy your first
[00:06:49.860 --> 00:07:09.860]   tool on SGLang. So if you go over to the GitHub. Yes.
[00:07:09.860 --> 00:07:17.860]   So in this step, we're just going to get familiar with the basic mechanics of SGLang. SGLang is basically
[00:07:17.860 --> 00:07:23.860]   just like a server command that you're going to run in your Docker container. There's a little bit
[00:07:23.860 --> 00:07:29.860]   of sort of difference with using it the way we're going to use it in the workshop right now versus how
[00:07:29.860 --> 00:07:34.860]   you might use it if you're working directly on a GPU. The difference is you're using something called
[00:07:34.860 --> 00:07:41.860]   truss to package it. Basically, you're putting in your SGLang dependencies and your command into this
[00:07:41.860 --> 00:07:57.860]   YAML file. You're bundling it and you're shipping it up to a GPU. The reason we are using truss is because that is the way that you can get on base 10 and the reason you are using base 10 is because that is the only company on earth that will give me free GPUs because I work there.
[00:07:57.860 --> 00:08:15.860]   So we're going to be working on all these examples on L4 GPUs because they are cheap and abundant and they also support FP8. But this same product works on H100, H200 and Blackwell is coming soon.
[00:08:15.860 --> 00:08:41.860]   Yeah, coming soon. So yeah, it's going to be basically like the same principles. If you go through here the configuration, you can actually in your trust config, you can change the hardware type to H100 if you want. And in the accelerator line right there.
[00:08:41.860 --> 00:09:10.860]   But yeah, so what is like the actual SGLang launch server command that we're running here? So it's basically just like a bunch of flags. That's the thing to understand about using SGLang. It's all about knowing what flags are available, knowing what configuration options are available, knowing the support matrix that exists for them, and knowing how they interact with each other. If you, you know, turn on a major speculation algorithm,
[00:09:10.860 --> 00:09:23.860]   And then you also jack your batch size way up. Well, that's probably not going to go so well for you. But if you want to do say like your, you know, quantization along with some of these other optimizations, those play nice.
[00:09:23.860 --> 00:09:52.860]   So yeah, what we're going to do, this is the fun part of leading a workshop, is the part where we just like stand around watching you type. What we're going to do is give everyone about five minutes to work through this first example. We're going to circulate the room if you have any questions. And then we're going to come back together after running the first example. Sound good? All right, let's do it. Can you cut the mics for five minutes?
[00:09:52.860 --> 00:09:57.860]   Pause. Skip. It's, it's great. They, these buttons, they're magical.
[00:09:57.860 --> 00:10:24.860]   As issues. Is anyone having issues where you're like stuck trying to get into base 10? Um, you're in like a waiting room and it won't let you out. Um, if you are, if you are a flag me, um, if anyone is having issues where you're getting like an error in your code, please don't show me show him.
[00:10:24.860 --> 00:10:31.860]   Kind of check on progress. Has anyone managed to get the first model deployed and running?
[00:10:31.860 --> 00:10:38.860]   It's deploying. Awesome. Let's hope it's deploying really fast.
[00:10:38.860 --> 00:10:51.860]   Let me, let me take a look here. All right. Sounds good. Can you take a look at the logs for me real quick?
[00:10:51.860 --> 00:10:58.860]   Wow. Wow. Our, our, our wifi is just amazing here. I promise base 10 is usually faster than this.
[00:10:58.860 --> 00:11:20.860]   Okay. Oh, okay. Well, it looks like it, it came up. Um, so you can, um, you can use the, um, sample code, um, in call.py. Oh, call.ipy.nb. Um, or like, you can just use an ordinary open AI client. Um, what you need to call.py.nb. Um, or like, you can just use an ordinary open AI client. Um, what you need to call.py.nb.
[00:11:20.860 --> 00:11:42.860]   Um, what you need to call it. If you go back to your base 10 workspace with the model, um, what you need is, uh, scroll back up a little bit for me. You need that model ID. That's what's going to, um, unlock your calling code.
[00:11:42.860 --> 00:11:53.860]   Um, that, yeah, paste it in right there. Um, you'll, you'll need to run an actual, run an actual Jupyter notebook to, to run that.
[00:11:53.860 --> 00:11:57.860]   All right. We've had our first successful deploy.
[00:11:57.860 --> 00:12:11.860]   If you want to call it using the open AI SDK, using the call.ipy.nb, uh, notebook, um, this thing up here, it's going to be different for everyone. Um, this within the UI is your model ID.
[00:12:11.860 --> 00:12:41.840]   That you use to put, uh, set up the URL. Um, hey everyone. We're going to come back together here. Um, it's about 9:45. Um, so we're going to move on to the next stage of the workshop where Yanang is going to do some really awesome demos. Um, if you are still getting everything set up, uh, no worries. All this stuff is going to be live on, um, GitHub. You've, oh, sorry. Yeah, on GitHub, um, the, the repository with the workshop information is going to stay up. Um, so you can,
[00:12:41.840 --> 00:12:54.840]   and keep following along. Um, this is also all going to be published. Um, so it's going to be easy to go back if you have any issues. Um, anyway, so the next thing that we're going to look at, um, now that we have a sort of basic idea of, okay.
[00:12:54.840 --> 00:13:09.840]   Actually laying is just like running a model server. Um, how are we going to actually make it fast? Um, so Yanang is going to show, um, one demo, which is the, um, CUDA. Um, what is it?
[00:13:09.840 --> 00:13:24.840]   Yes, CUDA graph match max BS flag, um, and how to set that to improve performance. Um, and then we're also going to take a look at Eagle three, which is a new specular of decoding algorithm, which, uh, also can improve performance.
[00:13:24.840 --> 00:13:46.840]   So take it away, Yanang. Yeah. Uh, can you see my screen? Yes. Yeah. Good, good call. Zoom it in a little bit. Um, we're using one pod because, uh, on base 10, you don't get SSH access into your GPUs because, uh, security or something, I guess. I don't know.
[00:13:46.840 --> 00:14:13.840]   Okay. So yeah, I will use the L4 GPU. Yeah. This is the L4 GPU and I have already installed the SGLine. Yeah. We can just use the PP install or install from source. And, uh, here is the, this command line, sorry.
[00:14:13.840 --> 00:14:28.840]   We launch the server and we use the Lama 3.18 B instruct model. And, uh, the attention backhand use FA3. This is the default. And when we,
[00:14:28.840 --> 00:14:55.840]   Okay. It just started loading the weights. So, uh, just to, just to give everyone a little bit of context, um, the top window you're seeing here is the, um, L4 that's, uh,
[00:14:55.840 --> 00:15:10.840]   actually running the SGLine server. The bottom window here, um, LM eval is a sort of industry standard benchmarking tool, um, that we're just going to use to throw a bunch of traffic at the running server.
[00:15:10.840 --> 00:15:18.840]   Yeah. Yeah. For sure. And, uh, yeah, we can see the, the log from, from the server. Uh, it shows that we capture CUDA graph.
[00:15:18.840 --> 00:15:33.840]   I think CUDA graph is turned on by default. But the CUDA graph max batch size for L4 for this model is eight. So, it only capture one, two, four, eight. And, uh, okay.
[00:15:33.840 --> 00:15:53.840]   The server is ready to run. And we can use the LM eval to send a request. Yeah, we can see that from, from the log. Here is the prefilled batch. And here is the decoder batch. And we can see, uh,
[00:15:53.840 --> 00:16:15.840]   under the decoder batch when the running request is 10, it means that there are 10 running requests. And the CUDA graph is false. Because the running request 10 is larger than the max CUDA graph size 8. That's why this one, this flag is false. And when this is false, uh, we get, uh,
[00:16:15.840 --> 00:16:37.840]   255 generation token per second. And we can use this one divided 10. So, I think per user nearly 15, uh, token per second. Okay. We can cue the client. And we can also cue the server.
[00:16:37.840 --> 00:16:58.840]   So, yeah. So, yeah. We, we can use this command as a base. And, uh, uh, say that the CUDA graph. Max, yes. CUDA graph. For example,
[00:16:58.840 --> 00:17:06.840]   we can adjust the state, uh, 32. You, you, you, you've got a, you've got a typo in there. Um. Oh, sorry.
[00:17:06.840 --> 00:17:33.840]   Okay. The network is not good. Here, everyone is learning a very important lesson in the value of latency. Okay. Yeah.
[00:17:33.840 --> 00:17:43.840]   It's loading weights. Yeah. And we can see that, uh, after we set the max CUDA graph website,
[00:17:43.840 --> 00:17:53.840]   the capture CUDA graph BS, uh, I think that the max is, uh, 32. It's larger than the 8. And the server is ready to roll.
[00:17:53.840 --> 00:18:00.840]   ready to roll. We also use the AME4 to send a request.
[00:18:00.840 --> 00:18:21.840]   Okay. So, first is the preview batch. And then we can -- here is the decoder batch. Oh, okay. And, uh, yeah. Here is the decoder batch. We can --
[00:18:21.840 --> 00:18:25.840]   Oh, wait for a moment. Decoder batch. We can --
[00:18:25.840 --> 00:18:29.840]   Oh, wait for a moment. Decoder batch.
[00:18:29.840 --> 00:18:31.300]   Hold the batch.
[00:18:31.300 --> 00:19:01.280]   Hold the batch.
[00:19:01.280 --> 00:19:11.460]   Yeah, for example, here is the decode batch, and there are 13 running requests, and the
[00:19:11.460 --> 00:19:18.100]   CUDA graph is true, and here is the generation throughout put.
[00:19:18.100 --> 00:19:29.400]   And I think per user should be 12, and we can compare with before.
[00:19:29.400 --> 00:19:33.780]   It's not easy to compare.
[00:19:33.780 --> 00:19:46.180]   Yeah, yeah, I think we have recording this video, and we can also see here CUDA graph, and we
[00:19:46.180 --> 00:19:51.580]   upload this one, CUDA graph max batch size demo.
[00:19:51.580 --> 00:19:56.960]   We want CUDA graph to be true during decode because I think this is very important for
[00:19:56.960 --> 00:20:04.060]   the decoding performance, but the default max batch size is 8 on L4.
[00:20:04.060 --> 00:20:08.440]   And when we used LME4 to send a request, we found that, oh, the max batch size is larger
[00:20:08.440 --> 00:20:09.440]   than 8.
[00:20:09.440 --> 00:20:13.440]   That's why we want to set or adjust the parameter.
[00:20:13.440 --> 00:20:19.820]   So here, when we set it to 32, we can handle the realistic batch during benchmark.
[00:20:19.820 --> 00:20:20.820]   Okay.
[00:20:20.820 --> 00:20:22.200]   Do we have any questions?
[00:20:22.200 --> 00:20:23.200]   Do you have any questions?
[00:20:23.200 --> 00:20:24.200]   Why would the commands do LME4?
[00:20:24.200 --> 00:20:25.200]   Yeah, yeah, yeah.
[00:20:25.200 --> 00:20:42.040]   I think LME4 is evaluation tool, and we needed to specify the model.
[00:20:42.040 --> 00:20:43.040]   And here is the model name.
[00:20:43.040 --> 00:20:50.800]   Here is the URL because I just used the run port to run this, and it used the same node.
[00:20:50.800 --> 00:20:53.600]   So that's why the URL is the local host.
[00:20:53.600 --> 00:20:57.480]   And we specify the port.
[00:20:57.480 --> 00:20:59.420]   This one, 8,000.
[00:20:59.420 --> 00:21:04.380]   That's why we used 8,000, and we used the OpenAI compatible server.
[00:21:04.380 --> 00:21:09.680]   And here, the number concurrent or the batch size is 128.
[00:21:09.680 --> 00:21:13.260]   We set the max generation tokens.
[00:21:13.260 --> 00:21:14.260]   We just used GSMNK.
[00:21:14.260 --> 00:21:18.800]   I think it's a classical evaluation data set.
[00:21:18.800 --> 00:21:25.440]   And because we used the chat completion API interface, that's why we need to apply chat complete.
[00:21:25.440 --> 00:21:27.560]   And I just used few short 8.
[00:21:27.560 --> 00:21:38.660]   And the limit means that because, you know, the GSMNK, it has 1,319 promotes, and when
[00:21:38.660 --> 00:21:47.940]   we use the limit 0.15, I think it's nearly 200 promotes.
[00:21:47.940 --> 00:21:52.360]   I can also share this command line in the repo.
[00:21:52.360 --> 00:21:53.360]   Yeah.
[00:21:53.360 --> 00:21:54.360]   Yeah.
[00:21:54.360 --> 00:21:55.360]   Yeah.
[00:21:55.360 --> 00:21:56.360]   Yeah.
[00:21:56.360 --> 00:21:58.360]   Maybe I can add it.
[00:21:58.360 --> 00:22:00.360]   Oh, sorry.
[00:22:00.360 --> 00:22:01.360]   Yeah.
[00:22:01.360 --> 00:22:09.480]   So just to be clear, this command is running on the actual GPU itself.
[00:22:09.480 --> 00:22:10.480]   Yeah.
[00:22:10.480 --> 00:22:16.020]   So this is for when you have SSH access into the GPU you're running.
[00:22:16.020 --> 00:22:21.780]   On the service we're all using, on the base 10 GPUs, you can't SSH in.
[00:22:21.780 --> 00:22:27.460]   But if you do have the access to a GPU where you can get SSH access, then you would use
[00:22:27.460 --> 00:22:34.560]   this LM eval tool in order to simulate that traffic.
[00:22:34.560 --> 00:22:42.360]   If you're using a more like standard HTTP connection to a, you know, remote GPU, then you would use
[00:22:42.360 --> 00:22:45.780]   a different benchmarking tool that's, you know, request-based.
[00:22:45.780 --> 00:22:46.780]   Yeah.
[00:22:46.780 --> 00:22:47.780]   Yeah.
[00:22:47.780 --> 00:22:48.780]   Okay.
[00:22:48.780 --> 00:22:52.780]   And do you have any other questions for CUDA graph?
[00:22:52.780 --> 00:22:57.560]   Why is default 8?
[00:22:57.560 --> 00:22:58.560]   Yeah, yeah.
[00:22:58.560 --> 00:23:03.460]   I think the default 8 is because the L4 GPU fee memory.
[00:23:03.460 --> 00:23:04.460]   Yeah.
[00:23:04.460 --> 00:23:07.460]   And we have some default configuration.
[00:23:07.460 --> 00:23:09.140]   We will, yeah.
[00:23:09.140 --> 00:23:10.140]   Set the...
[00:23:10.140 --> 00:23:16.240]   When you didn't set the CUDA graph max batch size, the default value is none.
[00:23:16.240 --> 00:23:22.140]   And when the default value is none, we will set it internally for specific hardware, for specific
[00:23:22.140 --> 00:23:23.140]   model.
[00:23:23.140 --> 00:23:24.140]   Yeah.
[00:23:24.140 --> 00:23:25.140]   Yeah.
[00:23:25.140 --> 00:23:30.140]   For example, it's TP1 and it's on L4, so the default is just 8.
[00:23:30.140 --> 00:23:31.140]   Yeah.
[00:23:31.140 --> 00:23:38.140]   So what if someone, by mistake, like, he adds a higher one for a large model or something
[00:23:38.140 --> 00:23:39.140]   before it?
[00:23:39.140 --> 00:23:40.140]   Yeah, you can just try that.
[00:23:40.140 --> 00:23:45.140]   Because when you launch the server, you can see the startup parameters.
[00:23:45.140 --> 00:23:46.140]   And then...
[00:23:46.140 --> 00:23:48.140]   Well, you have a workload, right?
[00:23:48.140 --> 00:23:52.140]   And you use the LME402 benchmark, for example.
[00:23:52.140 --> 00:23:54.140]   And then you can analyze the server log.
[00:23:54.140 --> 00:23:58.140]   And you find that, oh, during the decoding, the CUDA graph is disabled.
[00:23:58.140 --> 00:23:59.140]   And we...
[00:23:59.140 --> 00:24:01.140]   Actually, we want to enable CUDA graph.
[00:24:01.140 --> 00:24:06.140]   That's why we increase the max CUDA graph batch size.
[00:24:06.140 --> 00:24:07.140]   Yeah.
[00:24:07.140 --> 00:24:08.140]   Okay.
[00:24:08.140 --> 00:24:09.140]   Awesome.
[00:24:09.140 --> 00:24:10.140]   So let's...
[00:24:10.140 --> 00:24:11.140]   Let's see.
[00:24:11.140 --> 00:24:16.140]   Do you want to show the Eagle stuff or do you want to show the code-based stuff?
[00:24:16.140 --> 00:24:17.140]   Yeah, yeah, yeah.
[00:24:17.140 --> 00:24:18.140]   Okay.
[00:24:18.140 --> 00:24:22.140]   I think the next very important is about the Eagle stuff.
[00:24:22.140 --> 00:24:23.140]   Yeah.
[00:24:23.140 --> 00:24:27.140]   So Eagle 3 is a speculative decoding framework.
[00:24:27.140 --> 00:24:28.140]   It came out very recently, right?
[00:24:28.140 --> 00:24:29.140]   Yeah, yeah.
[00:24:29.140 --> 00:24:33.140]   The paper was released a few months ago.
[00:24:33.140 --> 00:24:36.140]   And so SGLang supports Eagle 3.
[00:24:36.140 --> 00:24:45.140]   And with it, you can configure a wide variety of different parameters around how many tokens
[00:24:45.140 --> 00:24:48.140]   you're speculating, how deep you're speculating, that kind of stuff.
[00:24:48.140 --> 00:24:54.140]   And Eagle 3 can have much higher acceptance, token acceptance rate.
[00:24:54.140 --> 00:24:59.140]   So obviously when you're speculating the higher your token acceptance rate, the better performance
[00:24:59.140 --> 00:25:00.140]   you're going to get.
[00:25:00.140 --> 00:25:06.140]   So we can take a quick look at some of those parameters that you showed, and then maybe the
[00:25:06.140 --> 00:25:08.140]   benchmark script you were showing me the other day.
[00:25:08.140 --> 00:25:09.140]   Yeah, yeah.
[00:25:09.140 --> 00:25:14.140]   I think for the Eagle 3, we also provide the example.
[00:25:14.140 --> 00:25:20.140]   We can just change directory to this directory and then use trust push.
[00:25:20.140 --> 00:25:21.140]   It's very easy.
[00:25:21.140 --> 00:25:24.140]   I just want to explain some details.
[00:25:24.140 --> 00:25:28.140]   For example, we need to specify the speculative decoding algorithm.
[00:25:28.140 --> 00:25:33.140]   here is the Eagle, like this one.
[00:25:33.140 --> 00:25:34.140]   Yeah.
[00:25:34.140 --> 00:25:38.140]   We need to specify speculative decoding algorithm Eagle.
[00:25:38.140 --> 00:25:41.140]   And we also need to specify the draft model path.
[00:25:41.140 --> 00:25:47.140]   Because this one, the model path, this is the target model.
[00:25:47.140 --> 00:25:49.140]   And here is the draft model.
[00:25:49.140 --> 00:25:50.140]   Sorry.
[00:25:50.140 --> 00:25:55.140]   Here is the draft model for the Eagle 3.
[00:25:55.140 --> 00:26:04.140]   So one thing that's different about Eagle, all the different Eagle algorithms, is instead
[00:26:04.140 --> 00:26:11.140]   of like a standard draft target where you're, say, maybe using Lama 1B and Lama 8B together,
[00:26:11.140 --> 00:26:19.140]   Eagle works by pulling in multiple layers of the target model, using that to build a draft
[00:26:19.140 --> 00:26:20.140]   model.
[00:26:20.140 --> 00:26:25.140]   So the draft model is kind of derived directly from the target model versus being just a small
[00:26:25.140 --> 00:26:26.140]   model that you're also running.
[00:26:26.140 --> 00:26:27.140]   Yeah.
[00:26:27.140 --> 00:26:28.140]   Yeah.
[00:26:28.140 --> 00:26:29.140]   Yeah.
[00:26:29.140 --> 00:26:35.140]   And you also need to specify this parameter, the number of steps, the Eagle, TopK, and the
[00:26:35.140 --> 00:26:38.140]   draft verified tokens.
[00:26:38.140 --> 00:26:44.140]   For example, the depth of the draft team is three and the TopK is one.
[00:26:44.140 --> 00:26:49.140]   I think the most number of Java tokens should not be more than four.
[00:26:49.140 --> 00:26:51.140]   That's why we said four here.
[00:26:51.140 --> 00:26:59.140]   And, yeah, you can see more details about this configuration at the SGLAN official documentation.
[00:26:59.140 --> 00:27:04.140]   And I also will show something about how to turn in these parameters.
[00:27:04.140 --> 00:27:06.140]   You know, we have these parameters.
[00:27:06.140 --> 00:27:11.140]   I think the model path is fixed under the -- how about this one?
[00:27:11.140 --> 00:27:14.140]   The number of steps, the TopK, and the number of Java tokens.
[00:27:14.140 --> 00:27:16.140]   We can turn in these parameters.
[00:27:16.140 --> 00:27:18.140]   And I will show you how to turn in that.
[00:27:18.140 --> 00:27:27.140]   So in the SGLAN main repo, we have a script and we have a playground.
[00:27:27.140 --> 00:27:32.140]   Yeah, we have a bunch of speculative decoding.
[00:27:32.140 --> 00:27:33.140]   Okay.
[00:27:33.140 --> 00:27:38.140]   So we can just use this script to turn in these three parameters.
[00:27:38.140 --> 00:27:45.140]   For example, on a single GPU, when we want to -- this is the target model, Lama 2, 7b.
[00:27:45.140 --> 00:27:48.140]   And this is the draft model.
[00:27:48.140 --> 00:27:51.140]   Here is some default parameters.
[00:27:51.140 --> 00:27:55.140]   The batch size is from 1, 2, 4, 8, 16.
[00:27:55.140 --> 00:28:01.140]   And the step is here, 0, 1, 3, 5, 7.
[00:28:01.140 --> 00:28:03.140]   And the TopK is here.
[00:28:03.140 --> 00:28:05.140]   This is the number of Java tokens.
[00:28:05.140 --> 00:28:06.140]   What does that mean?
[00:28:06.140 --> 00:28:09.140]   I think it's very easy to understand.
[00:28:09.140 --> 00:28:13.140]   For example, we have different combinations of these different parameters.
[00:28:13.140 --> 00:28:17.140]   And this script will run all of these combinations.
[00:28:17.140 --> 00:28:19.140]   And you will get the result.
[00:28:19.140 --> 00:28:24.140]   And from the result, you will get to know that, oh, this -- for example,
[00:28:24.140 --> 00:28:25.140]   this combination is best.
[00:28:25.140 --> 00:28:33.140]   For example, at the batch size 8, the three steps, maybe -- and the TopK is 1.
[00:28:33.140 --> 00:28:35.140]   And the number of Java tokens is 4.
[00:28:35.140 --> 00:28:41.140]   You will get some result about the speed and about the accept rate.
[00:28:41.140 --> 00:28:46.140]   Then you can use this parameter for your online servering, for your production servering.
[00:28:46.140 --> 00:28:55.140]   And when you're running this benchmark, do be sure to set the prompts to things that are representative of your actual workload.
[00:28:55.140 --> 00:28:56.140]   Yeah, yeah, yeah.
[00:28:56.140 --> 00:29:13.140]   Because speculation in any format, including Eagle, is all about guessing future tokens, if you are benchmarking on data that is not representative of your actual inputs and outputs that you're seeing live in production, then you're probably going to end up with the wrong parameters.
[00:29:13.140 --> 00:29:18.140]   Speculation is a very topic and content-dependent optimization.
[00:29:18.140 --> 00:29:19.140]   Yeah, yeah.
[00:29:19.140 --> 00:29:20.140]   I think so.
[00:29:20.140 --> 00:29:22.140]   So you can also update these promotes.
[00:29:22.140 --> 00:29:29.140]   Here in this batch speculating decoding Python script, we have some promotes.
[00:29:29.140 --> 00:29:34.140]   And I think you can update these just according to your needs.
[00:29:34.140 --> 00:29:35.140]   Yep.
[00:29:35.140 --> 00:29:36.140]   Okay.
[00:29:36.140 --> 00:29:42.140]   So let's take a look at some of the stuff around, you know, the community and getting involved.
[00:29:42.140 --> 00:29:43.140]   Yeah, yeah, yeah.
[00:29:43.140 --> 00:29:49.140]   Also, I think, yeah, SGLAN currently has become very popular.
[00:29:49.140 --> 00:29:55.140]   And if you want to participate in this community and contribute some code, I think --
[00:29:55.140 --> 00:29:58.140]   Yeah, I'll show the slides real quick.
[00:29:58.140 --> 00:29:59.140]   Okay.
[00:29:59.140 --> 00:30:06.140]   Yeah, so, you know, SGLang does have a really great community.
[00:30:06.140 --> 00:30:11.140]   And, you know, some quick ways to get involved.
[00:30:11.140 --> 00:30:15.140]   You can start on GitHub, file issues and bug reports as you build.
[00:30:15.140 --> 00:30:20.140]   They have a great tagging system of first issues to get involved with, which GNN is going to show in a second.
[00:30:20.140 --> 00:30:30.140]   But the number one thing you can do is follow SGLang LMSysOrg on Twitter and then join the Slack to keep an eye out for online and in-person meetups.
[00:30:30.140 --> 00:30:33.140]   So this is a link to the community Slack.
[00:30:33.140 --> 00:30:39.140]   You can scan that real quick if you want to get involved with SGLang.
[00:30:39.140 --> 00:30:46.140]   These slides are also all in the -- these slides are all in the repo that you got from the workshop.
[00:30:46.140 --> 00:30:49.140]   So you can access this link and stuff later.
[00:30:49.140 --> 00:30:51.140]   It's also just slack.sglang.ai.
[00:30:51.140 --> 00:30:53.140]   Pretty simple link.
[00:30:53.140 --> 00:31:06.140]   So if you are going to get involved and you do want to, you know, start contributing to the code base, we can kind of show you some of the stuff.
[00:31:06.140 --> 00:31:11.140]   So at a high level, the code base has the SGLang runtime.
[00:31:11.140 --> 00:31:17.140]   It's got a domain-specific front-end language and it has a set of optimized kernels.
[00:31:17.140 --> 00:31:31.140]   You can go actually on this deep wiki page and get a really good tour of the code base as well as a tour from this other repository that we have linked,
[00:31:31.140 --> 00:31:38.140]   which is also by one of the SGLang people with some diagrams about like exactly how this stuff works.
[00:31:38.140 --> 00:31:47.140]   And then, yeah, Yanang is just going to show a quick overview of the code base on GitHub in case you're interested in getting involved and contributing.
[00:31:47.140 --> 00:31:48.140]   Yeah.
[00:31:48.140 --> 00:31:51.140]   I think that's the best way to get involved in this project.
[00:31:51.140 --> 00:31:59.140]   First, we need to use that and then you will find some issue or you will find some feature missing in this repo.
[00:31:59.140 --> 00:32:03.140]   And then, the first thing that is you can raise a new issue here.
[00:32:03.140 --> 00:32:06.140]   Oh, it's loading.
[00:32:06.140 --> 00:32:11.140]   Yeah, you can just create a new issue feature request or something like this.
[00:32:11.140 --> 00:32:20.140]   And also, I think, yeah, we have labeled something like good first issue or help wanted.
[00:32:26.140 --> 00:32:32.140]   Yeah, you can see that there are nearly 26.
[00:32:32.140 --> 00:32:44.140]   So, I think, yeah, if you are interested in this issue, for example, if you are interested in support or suffering VILM, VILA model, you can just start with this.
[00:32:44.140 --> 00:32:45.140]   So, yeah.
[00:32:45.140 --> 00:32:45.140]   I think, yeah.
[00:32:45.140 --> 00:32:51.140]   I think good first issue and help wanted issue, yeah, we are welcome to the contributions.
[00:32:51.140 --> 00:32:54.140]   And here is the development roadmap.
[00:32:54.140 --> 00:33:10.140]   So, yeah, if some feature is missing or if some feature you care about, you can find it in the roadmap, I think you can join us for this feature development.
[00:33:10.140 --> 00:33:14.140]   Or you can also, yeah, raise a new issue about this.
[00:33:14.140 --> 00:33:19.140]   And the last one is about the overall work through.
[00:33:19.140 --> 00:33:20.140]   Okay.
[00:33:20.140 --> 00:33:21.140]   So, yeah.
[00:33:21.140 --> 00:33:31.140]   In the SGLAN repo, we have some component.
[00:33:31.140 --> 00:33:33.140]   This one is the SGLAN kernel.
[00:33:33.140 --> 00:33:35.140]   It's an SGLAN kernel library.
[00:33:35.140 --> 00:33:42.140]   We implement attention, normalization, activation, GIM, all of them in this kernel library.
[00:33:42.140 --> 00:33:51.140]   And if you are familiar with CUDA kernels, and if you are interested with kernel programming, you can just contribute to this part.
[00:33:51.140 --> 00:33:53.140]   And here is the SGL router.
[00:33:53.140 --> 00:34:01.140]   Last year, we published SGLAN, the three version, and we supported the cache aware routing.
[00:34:01.140 --> 00:34:06.140]   If you are interested in this part, you can work on the SGL router.
[00:34:06.140 --> 00:34:14.140]   Currently, we use SGLAN as LM inference runtime.
[00:34:14.140 --> 00:34:20.140]   So, I think the Python part, the SRT, is the core part.
[00:34:20.140 --> 00:34:22.140]   We supported PD disaggregation.
[00:34:22.140 --> 00:34:24.140]   We supported constructed coding.
[00:34:24.140 --> 00:34:25.140]   We supported function coding.
[00:34:25.140 --> 00:34:26.140]   Yeah.
[00:34:26.140 --> 00:34:30.140]   We supported OpenAI compatible server.
[00:34:30.140 --> 00:34:32.140]   And we also supported a lot of models.
[00:34:32.140 --> 00:34:33.140]   Yeah.
[00:34:33.140 --> 00:34:40.140]   I think if you want to support the custom model, you can just take this as a reference.
[00:34:40.140 --> 00:34:43.140]   For example, you can take LAMA as a reference.
[00:34:43.140 --> 00:34:50.140]   I think the popular open source model, the architecture, is very, very similar.
[00:34:50.140 --> 00:34:58.140]   So, if the model you are interested in has not been implemented in the SGLAN, you can just take this as a reference and do some modification.
[00:34:58.140 --> 00:35:01.140]   And then we welcome contributions.
[00:35:01.140 --> 00:35:02.140]   Yeah.
[00:35:02.140 --> 00:35:03.140]   That's all.
[00:35:03.140 --> 00:35:04.140]   Awesome.
[00:35:04.140 --> 00:35:07.140]   So, if we get the slides back up here.
[00:35:07.140 --> 00:35:08.140]   Yeah.
[00:35:08.140 --> 00:35:11.140]   So, to, you know, wrap it up.
[00:35:11.140 --> 00:35:14.140]   First off, thank you so much for coming out.
[00:35:14.140 --> 00:35:15.140]   Thank you for bearing with us.
[00:35:15.140 --> 00:35:23.140]   Thank you for waiting for web pages to load on this wonderful internet connection that we all have.
[00:35:23.140 --> 00:35:30.140]   To kind of wrap things up, I do want to issue a couple invitations to everyone in this room today.
[00:35:30.140 --> 00:35:35.140]   Number one, we're having a really cool happy hour with the folks from Oxen AI.
[00:35:35.140 --> 00:35:38.140]   Oxen AI is a fine tuning company.
[00:35:38.140 --> 00:35:49.140]   Their CEO just had a really cool demo that he published a couple weeks ago where he took GPT 4.1 and made it, you know, do a SQL generation benchmark.
[00:35:49.140 --> 00:35:52.140]   Took the score, said, okay, I think I can do better than this.
[00:35:52.140 --> 00:35:54.140]   Took QN 0.6B.
[00:35:54.140 --> 00:35:55.140]   Yes, you heard me right.
[00:35:55.140 --> 00:35:57.140]   Less than a billion parameters.
[00:35:57.140 --> 00:36:05.140]   Fine tuned it on some SQL generation data and actually beat GPT 4.1 with a model that you can run on, like, three years ago iPhone.
[00:36:05.140 --> 00:36:10.140]   So, yeah, we're gonna be, you know, at this happy hour, we're gonna be talking about fine tuning and stuff.
[00:36:10.140 --> 00:36:12.140]   It's gonna be a great time.
[00:36:12.140 --> 00:36:17.140]   Second invitation I want to extend to everyone in this room is if you think this stuff is cool,
[00:36:17.140 --> 00:36:21.140]   if you are, you know, seeing all the stuff that Yanang was talking about around contributing to the code base,
[00:36:21.140 --> 00:36:25.140]   and you're like, yeah, I love CUDA programming, just come work at base 10.
[00:36:25.140 --> 00:36:28.140]   If you're bored in your job, you won't be bored here.
[00:36:28.140 --> 00:36:33.140]   We've got a lot of open roles for both infrastructure and for model performance.
[00:36:33.140 --> 00:36:35.140]   If you're at all interested, just come talk to me.
[00:36:35.140 --> 00:36:38.140]   I'm gonna be here all three days.
[00:36:38.140 --> 00:36:41.140]   So, yeah, that's pretty much our workshop today.
[00:36:41.140 --> 00:36:47.140]   Thank you so much for coming through and happy to take any questions in the remaining time we have.
[00:36:47.140 --> 00:36:48.140]   Yes.
[00:36:48.140 --> 00:36:52.140]   What are the main reasons why you use this?
[00:36:52.140 --> 00:36:54.140]   Yeah, that's a great question.
[00:36:54.140 --> 00:37:03.140]   You know, I think that what we -- based on, like, we use all sorts of different runtimes model to model.
[00:37:03.140 --> 00:37:07.140]   Sometimes you just want to use whatever one is best for your use case.
[00:37:07.140 --> 00:37:16.140]   But in general, I think that the reason that we've been really attracted to it is because of how configurable and extensible it is.
[00:37:16.140 --> 00:37:22.140]   Out of the box with basic parameters, you're gonna get more or less the same performance from anyone.
[00:37:22.140 --> 00:37:35.140]   But if you're able to, number one, have, like, a really deeply and well-documented code base, like SGLang, where you're able to really deeply understand all the different options that you have, that can get you a long way.
[00:37:35.140 --> 00:37:39.140]   And then, as we were just talking about, it's super easy to contribute.
[00:37:39.140 --> 00:37:43.140]   So, we're constantly, like, making fixes and contributing them back.
[00:37:43.140 --> 00:37:52.140]   And that means that, you know, if you're using a different library, you might be blocked waiting for the core developers to implement support for a model or something.
[00:37:52.140 --> 00:37:55.140]   SGLang, you can unblock yourself.
[00:37:55.140 --> 00:37:56.140]   Yes.
[00:37:56.140 --> 00:38:11.140]   When there are multiple vendors and different kind of applications around the endpoint or within the subnet you are defining, how would you define your cybersecurity or security protocols?
[00:38:11.140 --> 00:38:14.140]   How would you enhance your protocols?
[00:38:14.140 --> 00:38:15.140]   Yeah.
[00:38:15.140 --> 00:38:16.140]   I mean, that's a great question.
[00:38:16.140 --> 00:38:25.140]   I don't really think that your choice of runtime engine, like, affects that too much because, you know, you're just packaging it up in a container.
[00:38:25.140 --> 00:38:36.140]   You know, within base 10, we've thought a lot about this in a sort of runtime agnostic way, where we're thinking about, of course, like, least privilege.
[00:38:36.140 --> 00:38:42.140]   We're thinking about, you know, making sure that there's a good deal of isolation built into the system.
[00:38:42.140 --> 00:38:53.140]   But from a runtime perspective, I don't think there's anything special we have to do for security with SGLang, right, compared to, like, VLM or anything else.
[00:38:53.140 --> 00:38:54.140]   Thank you.
[00:38:54.140 --> 00:38:58.140]   So, I'm from the Department of Defense Center.
[00:38:58.140 --> 00:38:59.140]   Oh, awesome.
[00:38:59.140 --> 00:39:02.140]   So, extensive experience in financial applications.
[00:39:02.140 --> 00:39:18.140]   So, to do some product developments in-house, do you think I can do the entire product development in-house within a subnet?
[00:39:18.140 --> 00:39:19.140]   Yeah.
[00:39:19.140 --> 00:39:20.140]   You don't have to go back and forth.
[00:39:20.140 --> 00:39:21.140]   Right now, for example, just throwing an example.
[00:39:21.140 --> 00:39:22.140]   Yeah.
[00:39:22.140 --> 00:39:37.140]   One of those CMMC cybersecurity certifications, I have to go through the endpoint controls and define the endpoint control and then go connect to the chat -- open AI and chat CPT.
[00:39:37.140 --> 00:39:38.140]   Gotcha.
[00:39:38.140 --> 00:39:39.140]   Kind of.
[00:39:39.140 --> 00:39:40.140]   Yeah, yeah.
[00:39:40.140 --> 00:39:42.140]   So, in that case, this would actually help you out a lot.
[00:39:42.140 --> 00:40:00.140]   Instead of relying on that remote server, you can just spin up a cluster, like, within the same VPC or, like, within the same physical data center as the workload that's relying on the AI model.
[00:40:00.140 --> 00:40:15.140]   You can clone SGLang, you can cut, you know, take a release and fully inspect the code because it's open source and then fix on that release so that there's nothing changing under the hood.
[00:40:15.140 --> 00:40:21.140]   And then, yeah, with that, you'd be able to, you know, run the models just directly on the GPU.
[00:40:21.140 --> 00:40:31.140]   As you saw in Yaneng's demo when he was doing the CUDA graph stuff, you're able to, you know, call it on even a local host basis and run inference.
[00:40:31.140 --> 00:40:42.140]   So, yeah, it gives you all the tools you need if you're trying to build even, like, a sort of AOGAP type of system with, you know, all of these open source runtimes.
[00:40:42.140 --> 00:40:48.140]   You can pull that code in, inspect it, lock it, and then build off of it.
[00:40:48.140 --> 00:40:49.140]   Very impressive.
[00:40:49.140 --> 00:40:55.140]   And also, currently, I'm working on, I'm also a PhD student.
[00:40:55.140 --> 00:40:56.140]   Yeah.
[00:40:56.140 --> 00:41:03.140]   So, I'm working on blockchain-based and part-time computing and some kind of AI deliverables.
[00:41:03.140 --> 00:41:08.140]   So, how do you circumvent within your product?
[00:41:08.140 --> 00:41:13.140]   Can you, so blockchain is completely another community-based code development.
[00:41:13.140 --> 00:41:14.140]   Yeah.
[00:41:14.140 --> 00:41:24.140]   So, how do you, can we integrate different community-based or a combination of both hybrid community-based protocol?
[00:41:24.140 --> 00:41:36.140]   Or, so, what is, because blockchain is kind of a decentralized network, whereas this one is kind of .
[00:41:36.140 --> 00:41:37.140]   Yeah.
[00:41:37.140 --> 00:41:42.140]   To be perfectly honest, like, I haven't really experienced anything with that.
[00:41:42.140 --> 00:41:49.140]   Pretty much all of the use cases that I've run with SGLang are just traditional client server applications.
[00:41:49.140 --> 00:41:51.140]   Any other questions?
[00:41:51.140 --> 00:41:52.140]   Yeah.
[00:41:52.140 --> 00:41:53.140]   .
[00:41:53.140 --> 00:41:53.140]   Yeah.
[00:41:53.140 --> 00:41:54.140]   Great.
[00:41:54.140 --> 00:41:55.140]   So, yeah.
[00:41:55.140 --> 00:42:07.140]   So, in base 10, like, what we do is we call it, like, the base 10 inference stack, where we're
[00:42:07.140 --> 00:42:22.140]   taking all of these different providers, the VLM, the SGLang, and the TensorRT LLM, which we actually
[00:42:22.140 --> 00:42:24.140]   probably use the most heavily of the three, and taking them in, customizing them, doing all that stuff I'm supposed to say for marketing purposes, but we are customizing it quite a bit.
[00:42:24.140 --> 00:42:41.140]   Anyway, where we generally pick VLLM, I'm sorry, I'm talking about them during your SGLang talk, but where we use VLLM is oftentimes for compatibility.
[00:42:41.140 --> 00:42:57.140]   For example, like, I know our Gemma models that we have up in the library are using VLLM because, like, it's what was supported when it dropped.
[00:42:57.140 --> 00:43:06.140]   So, yeah, that's, in my mind, like, the best use case for VLLM is, like, super broad compatibility.
[00:43:06.140 --> 00:43:11.140]   Any other questions?
[00:43:11.140 --> 00:43:12.140]   Awesome.
[00:43:12.140 --> 00:43:19.140]   Well, like I said, we're going to be around all day, and I'm going to be at the base 10 booth for the next three days.
[00:43:19.140 --> 00:43:28.140]   So, if you have any questions about SGLang, model serving, model inference in general, or if you want one of them jobs I was talking about, we are hiring very aggressively.
[00:43:28.140 --> 00:43:35.140]   So, definitely stop by the booth, hang out, grab one of these shirts, and, yeah, thank you so much for coming.
[00:43:35.140 --> 00:43:42.140]   Thank you so much for coming.

