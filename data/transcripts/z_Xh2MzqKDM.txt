
[00:00:00.000 --> 00:00:19.060]   All right, well hi everyone! Thanks so much for joining us today. So today I get
[00:00:19.060 --> 00:00:23.580]   the great opportunity of introducing SambaNova and some of our capabilities
[00:00:23.580 --> 00:00:29.400]   around reaching over a thousand tokens per second using Llama 3. Today I'm gonna
[00:00:29.400 --> 00:00:34.400]   spend a little bit of time getting you oriented around SambaNova some of the
[00:00:34.400 --> 00:00:38.900]   capabilities that we provide as an AI platform and also some of the
[00:00:38.900 --> 00:00:42.900]   underlying technologies that are providing the means of achieving some of
[00:00:42.900 --> 00:00:47.340]   the accomplishments like a thousand tokens per second. Before I start jumping
[00:00:47.340 --> 00:00:50.940]   into the content I want to take the opportunity to introduce some of my
[00:00:50.940 --> 00:00:55.800]   colleagues really quick. So joining me today I have Petro Milan who is a
[00:00:55.800 --> 00:01:00.660]   principal AI engineer he's gonna also be leading our workshop component and be
[00:01:00.660 --> 00:01:05.560]   here as we're getting hands-on with the technology. I also have Varun Krishna who
[00:01:05.560 --> 00:01:12.080]   is a senior senior principal AI solutions engineer joining me as well and I'm
[00:01:12.080 --> 00:01:16.080]   Michelle Maturne I'm our director of solutions engineering I serve our global
[00:01:16.080 --> 00:01:22.040]   customer base at SambaNova. So before jumping into our content I just want to
[00:01:22.040 --> 00:01:24.980]   cover what are we going to be talking about today. So we're going to start off
[00:01:24.980 --> 00:01:29.000]   with a little bit of housekeeping, talk a little bit about the prerequisites we are
[00:01:29.000 --> 00:01:32.860]   going to be getting hands-on today and also introduce our discord channel which is
[00:01:32.860 --> 00:01:35.900]   where we're going to be communicating with one another and also sharing some
[00:01:35.900 --> 00:01:40.800]   content and information that you're going to need such as files and other like API
[00:01:40.800 --> 00:01:45.920]   and keys and things like that. I'm going to talk about SambaNova just get you
[00:01:45.920 --> 00:01:52.280]   oriented around who are we and how are we achieving 1000 tokens per second. Then I'm
[00:01:52.280 --> 00:01:57.040]   going to pass it off to Petro he's going to talk you through our workshop today how
[00:01:57.040 --> 00:02:02.040]   we're going to get hands-on get you oriented around how to get started and
[00:02:02.040 --> 00:02:05.420]   we're actually going to go through a live build and we'll support you along the way.
[00:02:05.420 --> 00:02:10.520]   We'll also spend some time around questions just in case that you have any
[00:02:10.520 --> 00:02:13.400]   questions about SambaNova our technology or anything that we're doing in the
[00:02:13.400 --> 00:02:17.960]   hands-on component. So before we get started I want to talk a little bit about
[00:02:17.960 --> 00:02:22.100]   prerequisites so first of all we are going to be using our laptops so hopefully you
[00:02:22.100 --> 00:02:25.760]   have them today and we're also going to need internet access to get through our
[00:02:25.760 --> 00:02:30.320]   workshop. We're going to be working in a Python environment so hopefully we have
[00:02:30.320 --> 00:02:34.100]   Python set up and ready and also we're going to be needing to install some
[00:02:34.100 --> 00:02:40.760]   packages through PIP. We are going to be working in Discord so if you don't mind I'm
[00:02:40.760 --> 00:02:45.800]   going to give everybody just a second to hopefully get on Discord and and join our
[00:02:45.800 --> 00:02:49.600]   channel. So I'll just get everyone a quick moment to get set up.
[00:02:49.600 --> 00:03:01.600]   Once you're set up just maybe give me a thumbs up so I know.
[00:03:01.600 --> 00:03:09.600]   Question?
[00:03:09.600 --> 00:03:18.220]   Time to build capital T capital T capital B. The general one not the one that says speaker.
[00:03:18.220 --> 00:03:25.720]   Okay, so just to repeat it's AI engineer the password is time to build with a
[00:03:25.720 --> 00:03:29.220]   capital T and a capital B.
[00:03:29.220 --> 00:03:38.220]   Okay all it's all capitalized each word but concatenated.
[00:03:42.220 --> 00:03:49.720]   Good? Were you able to join? Okay, awesome, cool. Just want to make sure there's no problems.
[00:03:49.720 --> 00:03:54.220]   So we'll give everyone a couple minutes. We've just got Wi-Fi access.
[00:03:54.220 --> 00:04:01.720]   All right. In case you haven't got a chance to set up maybe just take a picture of this really quick. We'll also go back to it before we kick off the hands-on component.
[00:04:01.720 --> 00:04:07.220]   But want to spend a little bit of time just getting you oriented around us as Somba Nova.
[00:04:07.220 --> 00:04:16.720]   So Somba Nova, we are a full stack AI platform and we've existed since 2017.
[00:04:16.720 --> 00:04:26.220]   We were founded out of Stanford University.
[00:04:26.220 --> 00:04:35.720]   So two of our co-founders are actually Stanford professors, Kunle and also Chris.
[00:04:35.720 --> 00:04:45.220]   Both of them and including Rodrigo each bring a unique perspective to our founding team including previous startups that were acquired and had various exits.
[00:04:45.220 --> 00:04:58.220]   Also building other AI startups that are pretty well known in the industry such as Snorkel, Together AI and also a really depth of experience around building out hardware and chips.
[00:04:58.220 --> 00:05:11.220]   We are building the full stack from the ground up so that means we build our own chip I'll go into that a little bit later later but also all the way through the system level and the software layer.
[00:05:11.220 --> 00:05:17.220]   We're on our fourth generation chip and we build our own chip.
[00:05:17.220 --> 00:05:23.220]   I'll go into that a little bit later but also all the way through the system level and the software layer.
[00:05:23.220 --> 00:05:37.220]   We're on our fourth generation chip and we have built an entire stack that allows you to both fine tune models, pre-train models and also deploy those models with really high performance inference.
[00:05:37.220 --> 00:05:48.220]   We have achieved over a billion dollars in funding from various well known names like BlackRock or Google Ventures, Intel, GIC.
[00:05:48.220 --> 00:05:55.220]   And so we are really well established to solve the challenge around building and deploying AI hardware.
[00:05:55.220 --> 00:06:02.220]   So what exactly are we targeting and what exactly are we trying to solve for?
[00:06:02.220 --> 00:06:08.220]   Our customer base comes from a wide variety of enterprises and also to government organizations.
[00:06:08.220 --> 00:06:23.220]   So we're really aiming to deliver capabilities that can help service the enterprise grade AI capabilities that companies and governments require to deliver unique and differentiated capabilities and also things like sovereign AI.
[00:06:23.220 --> 00:06:32.220]   Our underlying platform is delivering the means to actually achieve the scale of a trillion parameters plus.
[00:06:32.220 --> 00:06:36.220]   And we're doing that through delivering full stack capabilities.
[00:06:36.220 --> 00:06:43.220]   When I say full stack, many folks have probably utilized many of these technologies on this slide.
[00:06:43.220 --> 00:06:47.220]   We're not necessarily trying to compete with every single layer involved here.
[00:06:47.220 --> 00:06:53.220]   But what we are trying to do is ease the process of getting started and ease the journey along the way.
[00:06:53.220 --> 00:07:07.220]   And so instead of having to make a decision at every single one of these layers, we are actually integrating things into a very seamless experience from deciding on what chip is going to work with what compute.
[00:07:07.220 --> 00:07:11.220]   What compute and chip is going to work with what operation systems.
[00:07:11.220 --> 00:07:14.220]   What operation system works with what models.
[00:07:14.220 --> 00:07:19.220]   You don't have to actually make each of these decisions and know that they have to integrate with one another.
[00:07:19.220 --> 00:07:26.220]   We actually create this very seamless experience along the way where everything kind of orchestrates and works very nicely.
[00:07:26.220 --> 00:07:36.220]   And what we're doing at the end of this is actually delivering the capability to not only fine tune, but deliver really, really fast inference capabilities.
[00:07:36.220 --> 00:07:47.220]   So we're going to demo a little bit of this later, but recently we released a demo that you can actually go try live and we'll do so later called Samba 1 Turbo.
[00:07:47.220 --> 00:07:54.220]   This is exceeding world records around speed of inference, especially when it comes to Llama 3.
[00:07:54.220 --> 00:08:01.220]   And you can see that through some of the metrics that were recently published through artificial analysis.
[00:08:01.220 --> 00:08:17.220]   Artificial analysis did a benchmarking exercise to understand the different capabilities, the speed at which they are able to deliver inference throughput for a thousand tokens per second across various hardware providers.
[00:08:17.220 --> 00:08:26.220]   And what you can see is that we are far exceeding as a platform the throughput capabilities compared to some of the other providers out there.
[00:08:26.220 --> 00:08:32.220]   And so I want to kind of talk a little bit about how are we enabling such speed.
[00:08:32.220 --> 00:08:39.220]   So when it comes to the underlying technology, many of us have experienced some of these trends in the industry.
[00:08:39.220 --> 00:08:46.220]   Many of us got started with what you see on the right hand side of the slide, which is the large monolithic model.
[00:08:46.220 --> 00:08:51.220]   This is the likes of like an open AI, for example, or a Gemini or a Cloud.
[00:08:51.220 --> 00:08:56.220]   And many of us started our LLM journey or our generative AI journey using some of these technologies.
[00:08:56.220 --> 00:09:04.220]   But along the way, many other capabilities in the open source community started to pop up, specifically these smaller models.
[00:09:04.220 --> 00:09:13.220]   And these smaller models allowed us to do things like fine tuning and actually adapting some of these models to our enterprise data and our enterprise requirements.
[00:09:13.220 --> 00:09:16.220]   And so that really started to take off in the industry.
[00:09:16.220 --> 00:09:20.220]   And each of these started to see different pros and cons associated with them.
[00:09:20.220 --> 00:09:27.220]   When it came to large monolithic models, when we actually started to put these into practice when it came to enterprise applications,
[00:09:27.220 --> 00:09:34.220]   one of the reasons many of us leaned into this is because of the broad capabilities that the likes of open AI brought.
[00:09:34.220 --> 00:09:39.220]   And also the ease of integration in terms of open AI into the actual platform itself.
[00:09:39.220 --> 00:09:45.220]   It's super easy to manage, and it also is trained on the internet's data, and so it can handle a lot of different things.
[00:09:45.220 --> 00:09:56.220]   But when it came to actual enterprise applications, enterprises have unique capabilities required to deliver on some of the use cases and challenges they're trying to solve for.
[00:09:56.220 --> 00:10:09.220]   For example, enterprises have unique data that they, you know, oftentimes segregate from the internet, or most of the time segregate from the internet that's proprietary to them.
[00:10:09.220 --> 00:10:19.220]   And oftentimes they have spent the last 10 years trying to actually aggregate that data into the likes of data lakes and other kind of centralized capabilities.
[00:10:19.220 --> 00:10:23.220]   And so now how do you actually transform that into AI capabilities that you can leverage?
[00:10:23.220 --> 00:10:27.220]   That was very difficult when it came to large monolithic models.
[00:10:27.220 --> 00:10:33.220]   The other challenges that we saw is that many started to become very concerned about security when it came to open AI.
[00:10:33.220 --> 00:10:36.220]   They wanted to preserve data privacy.
[00:10:36.220 --> 00:10:40.220]   They wanted to also own and use the model as a differentiation for themselves.
[00:10:40.220 --> 00:10:46.220]   And then also as you start to see more and more adoption, that cost just started to skyrocket.
[00:10:46.220 --> 00:10:51.220]   Open AI and a lot of these closed-source models charge on a per-token rate.
[00:10:51.220 --> 00:11:00.220]   And so as you start to utilize more and more LLMs and utilize LLMs more heavily, the cost just starts to go up and up and up and up and up.
[00:11:00.220 --> 00:11:03.220]   And it's really, really hard to control.
[00:11:03.220 --> 00:11:13.220]   On the other hand, when it came to adopting the smaller expert models or the smaller open-source models like the likes of Llama 3.8b that we'll talk about later,
[00:11:13.220 --> 00:11:22.220]   We were able to address some of the enterprise accuracy concerns by actually pre-training, fine-tuning these models to adapt them to the enterprise requirements.
[00:11:22.220 --> 00:11:30.220]   While we were doing this at a smaller scale to address different capabilities and tasks that we needed to solve for in the enterprise,
[00:11:30.220 --> 00:11:37.220]   They weren't trying to solve a broad set of tasks and also adopt a broad set of general knowledge.
[00:11:37.220 --> 00:11:46.220]   Thus, manageability became a little bit challenging because now we have all of these micro models that we have to orchestrate and have them work together.
[00:11:46.220 --> 00:11:53.220]   But we were able to solve for some things like security, model ownership, data privacy, and data ownership.
[00:11:53.220 --> 00:12:00.220]   But again, because we had so many of these and we had to fine-tune each one of these, the cost also became very challenging.
[00:12:00.220 --> 00:12:06.220]   So, what are we trying to solve for through our capability of SambaOne?
[00:12:06.220 --> 00:12:17.220]   We're trying to bring the best of both of these paradigms together to deliver the capabilities of each in a very simplistic way.
[00:12:17.220 --> 00:12:23.220]   And the way that we actually deliver this is through four core capabilities.
[00:12:23.220 --> 00:12:27.220]   First of all, we take all of those expert models behind the scenes.
[00:12:27.220 --> 00:12:31.220]   So, let's just say we fine-tuned a model for our legal purposes.
[00:12:31.220 --> 00:12:35.220]   We fine-tuned a model for our HR purposes.
[00:12:35.220 --> 00:12:38.220]   We fine-tuned a model for coding capabilities.
[00:12:38.220 --> 00:12:44.220]   Each of those have different groups and tasks and use cases that are going to consume those.
[00:12:44.220 --> 00:12:49.220]   But we want to really ease the experience of having to integrate those into the application.
[00:12:49.220 --> 00:12:53.220]   So, we put all of those behind a secure single endpoint.
[00:12:53.220 --> 00:12:59.220]   And so, you only have to interface with one endpoint to gain access to all these various models.
[00:12:59.220 --> 00:13:05.220]   Now, we need to determine how are we going to actually use those or consume those various models behind the scenes.
[00:13:05.220 --> 00:13:08.220]   So, now we need capabilities around orchestration.
[00:13:08.220 --> 00:13:13.220]   So, one of the other capabilities we're delivering as a part of this is around routing.
[00:13:13.220 --> 00:13:17.220]   So, we're delivering the ability to determine based off of an incoming prompt.
[00:13:17.220 --> 00:13:22.220]   What is the best suited expert behind the scenes to solve that prompt?
[00:13:22.220 --> 00:13:24.220]   And we're doing so through a router.
[00:13:24.220 --> 00:13:27.220]   We're also bringing the means of dynamically fine-tuning.
[00:13:27.220 --> 00:13:32.220]   Every expert is going to have a different cadence in which fine-tuning is going to make sense.
[00:13:32.220 --> 00:13:39.220]   So, maybe your finance model gets adjusted annually when your policies are updated.
[00:13:39.220 --> 00:13:46.220]   But maybe your coding model, because you're pushing code so regularly, needs to get updated on a quarterly basis.
[00:13:46.220 --> 00:13:56.220]   And so, you want to actually be able to schedule your fine-tuning jobs and adjust and swap these models at the rate at which it makes sense to actually retrain these models.
[00:13:56.220 --> 00:14:00.220]   And lastly, you have a bunch of models under the scenes.
[00:14:00.220 --> 00:14:05.220]   Not every application or group is going to or should be able to access each of those models.
[00:14:05.220 --> 00:14:10.220]   So, now you need to figure out a way to manage the access controls for these.
[00:14:10.220 --> 00:14:15.220]   So, what we're also delivering as a part of this capability is model level RBAC.
[00:14:15.220 --> 00:14:23.220]   So, you can actually determine this application or this person or this group of people should be able to access this set of models.
[00:14:23.220 --> 00:14:36.220]   And it allows you a ton of efficiency from a computation and management operation standpoint with the security and fine-grained control that you need to actually manage access to these different models and data underlying these models.
[00:14:36.220 --> 00:14:41.220]   So, within Samba 1, we have two ways of delivering this.
[00:14:41.220 --> 00:14:47.220]   We have something called a flexible COE that allows you to kind of determine exactly what models lie under the hood.
[00:14:47.220 --> 00:14:52.220]   And we also have a pre-composed version of Samba 1, composition of experts.
[00:14:52.220 --> 00:15:01.220]   So, our pre-trained or pre-configured, I should say, or pre-composed version of this model has 92 underlying experts.
[00:15:01.220 --> 00:15:10.220]   And when I say experts, I'm really referring to a specific model that can bring different capabilities associated with it.
[00:15:10.220 --> 00:15:23.220]   And within those 92 experts, we have a broad range of languages that are covered within those models, a broad range of domains, and a diverse set of tasks that are very, very relevant to the enterprise.
[00:15:23.220 --> 00:15:36.220]   All of these models are supported by seven different foundation model architectures, including Llama 2, Llama 3, Mistral Falcon, Bloom, and even some multimodal capabilities such as, like, Lava, Clip, D-Plot.
[00:15:36.220 --> 00:15:41.220]   That is kind of starting to support some of the multimodal trends that are coming.
[00:15:41.220 --> 00:15:52.220]   And of all these 92 models, we are actually delivering and partnering with organizations to create and contribute back to the open source community.
[00:15:52.220 --> 00:16:01.220]   So, out of the 92 experts, 12 of them are actually ones that we've helped either develop ourselves or co-develop with organizations out there,
[00:16:01.220 --> 00:16:10.220]   including some of the language capabilities that we've delivered such as models that can support things like Thai or Japanese, Hungarian.
[00:16:10.220 --> 00:16:16.220]   And through that, we've developed a lot of experience on how to actually adapt models to different languages.
[00:16:16.220 --> 00:16:26.220]   We've also created a model for text-to-SQL capabilities and delivered really, really good results through that model for text-to-SQL.
[00:16:26.220 --> 00:16:38.220]   And lastly, we have contributed back to BloomChat. It's the second largest open source model, and it's also bringing a lot of the multilingual capabilities.
[00:16:38.220 --> 00:16:47.220]   So, organizations essentially, as they're constructing these different composition of experts, can add as many expert models as they need.
[00:16:47.220 --> 00:16:56.220]   As I mentioned before, while we have that pre-configured composition, this is really intended for you to be able to construct exactly what you need in terms of models under the hood.
[00:16:56.220 --> 00:16:59.220]   So, you can add as many as you need.
[00:16:59.220 --> 00:17:11.220]   So, our end goal with this is to really be able to bring the capabilities that enterprises need to handle the diverse set of use cases and capabilities they need to solve their problems.
[00:17:11.220 --> 00:17:18.220]   And so, one of the things that we've created along the way to measure ourselves against this is an enterprise-grade AI benchmarking set.
[00:17:18.220 --> 00:17:29.220]   And this is really tailored to understand our capabilities against the best-in-industry models across various enterprise-specific tasks and domains that are needed.
[00:17:29.220 --> 00:17:44.220]   Things like information extraction, that's where many, many enterprises are starting, but also broad set of capabilities like text SQL, coding, function calling, and we're measuring ourselves against GPT 3.5 Turbo and GPT 4.
[00:17:44.220 --> 00:17:52.220]   And what we can see is, along the way, we're meeting or exceeding the capabilities that OpenAI is bringing.
[00:17:52.220 --> 00:17:58.220]   But alongside the capabilities, you also need to orchestrate these models.
[00:17:58.220 --> 00:18:13.220]   I talked a little bit about this before, but one of the deliverables as far as Samba 1 from a product standpoint is we're bringing routing capabilities so that you can actually take a prompt, determine what is the best-suited expert, and then route to that.
[00:18:13.220 --> 00:18:18.220]   There's also scenarios where you may need to do something outside of routing.
[00:18:18.220 --> 00:18:21.220]   You may actually just want to directly call a specific model.
[00:18:21.220 --> 00:18:28.220]   Or, in the case that is popping up really, really regularly now with agentic AI, you may need to do model chaining.
[00:18:28.220 --> 00:18:37.220]   So that's another capability that we're bringing as a part of the product suite for Samba 1.
[00:18:37.220 --> 00:18:48.220]   And so how are we actually uniquely set up to deliver the composition of experts capability and also the really fast inference speed that we're going to see briefly?
[00:18:48.220 --> 00:18:54.220]   So I mentioned earlier, but we are a full-stack AI platform, but we also build our own chip.
[00:18:54.220 --> 00:18:59.220]   Our chip, we call that an RDU, or a reconfigurable data flow unit.
[00:18:59.220 --> 00:19:03.220]   So instead of a GPU, we refer to our chip as an RDU.
[00:19:03.220 --> 00:19:07.220]   And our current version of that chip is called SN40L.
[00:19:07.220 --> 00:19:12.220]   And what is unique about SN40L is actually the memory structure of this chip.
[00:19:12.220 --> 00:19:17.220]   So our chip supports a three-tiered memory architecture.
[00:19:17.220 --> 00:19:26.220]   So we have our on-chip memory, and then we have our high bandwidth memory, and then we have a huge memory capacity in DDR.
[00:19:26.220 --> 00:19:30.220]   And this really allows us to store a ton of models.
[00:19:30.220 --> 00:19:45.220]   And have those models be swapped in and out of various tiers within the memory to achieve really strong performance and also really, really efficient compute utilization.
[00:19:45.220 --> 00:19:47.220]   So what does this look like?
[00:19:47.220 --> 00:19:53.220]   As I mentioned before, we can store up to five trillion parameters on DDR.
[00:19:53.220 --> 00:19:58.220]   So that's like if we were to store like three to four open EIs on a single chip.
[00:19:58.220 --> 00:20:04.220]   And then, as we need to actually execute those models, they can move up the memory stack.
[00:20:04.220 --> 00:20:11.220]   And this allows us to, one, take into consideration what models need to be used at what time.
[00:20:11.220 --> 00:20:18.220]   And then, two, do so in a really performant way because the network connectivity between these three layers is really tight.
[00:20:18.220 --> 00:20:35.220]   So just to kind of go into some of the specs, our on-chip SRAM has four gigs, our high bandwidth memory has 512 gigs, and our DDR has up to six terabytes.
[00:20:35.220 --> 00:20:38.220]   So lots of memory to work with.
[00:20:38.220 --> 00:20:58.220]   And when we think about how does this compare to what you experience in the GPU world, when you think about the number, if you want to host a really large amount of models, when you have to do so on a GPU, you're basically needing to work with the memory that the GPU has on chip.
[00:20:58.220 --> 00:21:07.220]   But with us, because we have the DDR component, we're able to store a huge amount of models in a single system and keep it coupled with the other memory tiers.
[00:21:07.220 --> 00:21:15.220]   And so with GPUs, you're often, if you wanted to host 500 different models, you're going to have to actually align those models to various systems.
[00:21:15.220 --> 00:21:21.220]   And you're going to have to basically call various systems to actually access each of those models.
[00:21:21.220 --> 00:21:32.220]   With us, it's going to be one underlying system because we're able to store, again, up to five trillion parameters.
[00:21:32.220 --> 00:21:35.220]   So I'm going to hand it over to Pedro.
[00:21:35.220 --> 00:21:39.220]   What we're going to do next is actually get the chance to get hands-on.
[00:21:39.220 --> 00:21:42.220]   Thanks, Rochelle, for the presentation.
[00:21:42.220 --> 00:21:49.220]   So what we will be doing next is a demo of our Lama 3 and Samba 1 Turbo.
[00:21:49.220 --> 00:21:54.220]   And after this, we move to the hands-on portion of the workshop.
[00:21:54.220 --> 00:22:05.220]   So if you want to try out our Lama 3 endpoint, you can go to our website, sambanova.ai.
[00:22:05.220 --> 00:22:10.220]   And then click on Samba 1 Turbo.
[00:22:10.220 --> 00:22:14.220]   So this is where you can access our chat infra.
[00:22:14.220 --> 00:22:25.220]   And here you have options to select various models, you know, Lama 3, 8B, 7TB, our COE, MISTRO,
[00:22:25.220 --> 00:22:32.220]   and even some of our in-house models that we train ourselves, like somebody or others.
[00:22:32.220 --> 00:22:39.220]   So yeah, we'll do a demo of Lama 3, 8B, and I'll ask it the following question.
[00:22:39.220 --> 00:22:46.220]   So, you know, create a 3-day workout schedule for intermediate fitness level.
[00:22:46.220 --> 00:22:49.220]   Let me actually redo it again.
[00:22:49.220 --> 00:22:53.220]   You can see, you know, it gets instant response.
[00:22:53.220 --> 00:22:58.220]   And then for the performance metrics, so you can see the insights here.
[00:22:58.220 --> 00:23:01.220]   So a few things to note.
[00:23:01.220 --> 00:23:08.220]   So, of course, we have a pretty high throughput, which is 1,000 tokens per second.
[00:23:08.220 --> 00:23:11.220]   But that's not only the end of the story.
[00:23:11.220 --> 00:23:20.220]   We also have a pretty small time-to-first token, which is basically the input inference time of 0.09 seconds.
[00:23:20.220 --> 00:23:27.220]   And we also have a pretty small end-to-end total inference time of 0.65 seconds, right?
[00:23:27.220 --> 00:23:34.220]   So with our full-stack platform, we're going to achieve high throughput and very small inference time.
[00:23:34.220 --> 00:23:51.220]   And if you just want to do a comparison, let's say, with ChatGPT, for instance, if you ask the same question, just copy it.
[00:23:51.220 --> 00:23:57.220]   Yeah, you can clearly see the difference in speed.
[00:23:57.220 --> 00:24:12.220]   And the other cool thing which we built, so we have this real-time option where, as you write your prompt, you can instantly see the model's response.
[00:24:12.220 --> 00:24:17.220]   And as you change the prompt, you can also see the change in the response.
[00:24:17.220 --> 00:24:29.220]   So let's say, I don't know, hi, I want to write an email about blah, blah, blah, right?
[00:24:29.220 --> 00:24:36.220]   So the point here is that, you know, with this real-time option, you know, you can do real-time chatting.
[00:24:36.220 --> 00:24:45.220]   And this can be helpful, for instance, if you're drafting emails or even if you want to do some, like, real-time prompt engineering, let's say.
[00:24:45.220 --> 00:24:48.220]   So yeah, that's it for the SambaOne Turbo.
[00:24:48.220 --> 00:24:54.220]   I can give maybe a few minutes for folks to try it out before we move on to the hands-on.
[00:24:54.220 --> 00:25:01.220]   So, again, you go to our website, SambaNova.ai, and then you click on SambaOne Turbo.
[00:25:01.220 --> 00:25:04.220]   So you can do it from your laptop or from your cell phone.
[00:25:04.220 --> 00:25:08.220]   Yes?
[00:25:08.220 --> 00:25:11.220]   Another question. Can we tweak the generation parameters?
[00:25:11.220 --> 00:25:12.220]   Yes, yes, yes, yeah.
[00:25:12.220 --> 00:25:23.220]   Let me see how to do it on this UI.
[00:25:23.220 --> 00:25:30.220]   Okay, I think from this UI, it seems it is fixed.
[00:25:30.220 --> 00:25:39.220]   But in the hands-on, once you will be calling our endpoint from the API key, we will be changing some of the configs as well.
[00:25:39.220 --> 00:25:45.220]   Yeah, any other question?
[00:25:45.220 --> 00:26:12.220]   Yeah, were you able to try it out? Okay, great.
[00:26:12.220 --> 00:26:19.220]   Okay, so I think, yeah, we can move on to the hands-on portion.
[00:26:19.220 --> 00:26:30.220]   So what I'll do first is just introduce what I'll be talking about in this part, and then we'll dive in to the hands-on.
[00:26:30.220 --> 00:26:35.220]   So, yeah, we prepared two exercises for you today.
[00:26:35.220 --> 00:26:39.220]   So the first one is a basic example to get you started.
[00:26:39.220 --> 00:26:53.220]   So here, I'll be showing how you can load environment variables, set up the SambaNova API key, initialize the LLM, and do a simple inference call in Python.
[00:26:53.220 --> 00:27:00.220]   And the second example is a more practical one.
[00:27:00.220 --> 00:27:09.220]   So we will be building and deploying a Q&A system with Rack for enterprise search using our platform.
[00:27:09.220 --> 00:27:20.220]   And we will also be using other libraries and packages like, you know, Lanchain, various data loaders, E5-Large V2 embedding,
[00:27:20.220 --> 00:27:28.220]   ChromaDB vector store, and, of course, the Lama3 endpoint, which runs at the speed of 1,000 tokens per second.
[00:27:28.220 --> 00:27:34.220]   So, yeah, let's start with the basic example.
[00:27:34.220 --> 00:27:51.220]   And if you want to follow along, so you can go to Google, write AI StaticKit SambaNova, and then click on this link, or you can just write this URL.
[00:27:51.220 --> 00:27:57.220]   So this is our StaticKit repo.
[00:27:57.220 --> 00:28:03.220]   We have a collection of open source examples on Gen AI apps.
[00:28:03.220 --> 00:28:14.220]   And, yeah, once you get there, yeah, you can go to workshops, AI engineer 2024, basic examples.
[00:28:14.220 --> 00:28:24.220]   So I'll go over the readme and then do a live demo of the work of this exercise, and then I'll give you some time to try it out.
[00:28:24.220 --> 00:28:30.220]   So, yeah, first, you'll need to clone this repo here.
[00:28:30.220 --> 00:28:40.220]   And then you'll need to create a .end file in the repo root directory.
[00:28:40.220 --> 00:28:47.220]   So this is where we will be specifying the Samba Studio API key.
[00:28:47.220 --> 00:28:50.220]   Yeah, so let me show you how this is done.
[00:28:50.220 --> 00:29:13.220]   Yeah, I guess with the two mic, I need to find a way.
[00:29:13.220 --> 00:29:16.220]   Yeah, so I've already cloned the repo.
[00:29:16.220 --> 00:29:17.220]   Yeah, the repo.
[00:29:17.220 --> 00:29:25.220]   And then, at this level, this is where you will need to create the .end file.
[00:29:25.220 --> 00:29:31.220]   So, in the case, yeah, you'll have to do touch .end.
[00:29:31.220 --> 00:29:40.220]   And then, yeah, you can add these information here.
[00:29:40.220 --> 00:29:46.220]   So for the first hands-on, that's the only thing that you'll need.
[00:29:46.220 --> 00:29:52.220]   And you can access or copy those from our Discord channel.
[00:29:52.220 --> 00:30:13.220]   So, yeah, if you go to Discord events, yeah, so you can copy either of these keys.
[00:30:13.220 --> 00:30:17.220]   So we have two dedicated endpoints for this workshop.
[00:30:17.220 --> 00:30:28.220]   All right, and once we finish setting up the .env, the third step is basically, you know, installing the packages.
[00:30:28.220 --> 00:30:33.220]   So for this one, you can either do it with, you know, Conda or Python environment.
[00:30:33.220 --> 00:30:39.220]   So first, yeah, we will go to the basic examples repo.
[00:30:39.220 --> 00:30:42.220]   So just CD and then the repo path.
[00:30:42.220 --> 00:30:46.220]   Then you can create a Conda environment.
[00:30:46.220 --> 00:30:50.220]   So I would recommend using Python 3.10.
[00:30:50.220 --> 00:30:54.220]   And then you activate your Conda environment.
[00:30:54.220 --> 00:30:57.220]   And here we name it basic_x.
[00:30:57.220 --> 00:31:04.220]   And then, yeah, you just install the requirements with the pip install -r requirements.
[00:31:04.220 --> 00:31:11.220]   And then you can use this line to just link the kernel to your notebook.
[00:31:11.220 --> 00:31:12.220]   Okay.
[00:31:12.220 --> 00:31:32.220]   So if I go to my terminal, yeah, so we'll go to workshop, AI engineer, basic examples.
[00:31:32.220 --> 00:31:36.220]   Okay, so this is where you can create the Conda.
[00:31:36.220 --> 00:31:40.220]   So I've already done it beforehand, so I'm just going to activate the environment.
[00:31:40.220 --> 00:31:41.220]   Yeah, and this is the requirements file.
[00:31:41.220 --> 00:31:41.220]   So we only have, like, a few packages that is needed.
[00:31:41.220 --> 00:31:41.220]   Yeah, and that's it for the installation.
[00:31:41.220 --> 00:31:42.220]   So once this is done, we're going to go.
[00:31:42.220 --> 00:31:42.220]   So let's go.
[00:31:42.220 --> 00:31:42.220]   Yeah, and this is the requirements file.
[00:31:42.220 --> 00:31:42.220]   So we only have, like, a few packages that is needed.
[00:31:42.220 --> 00:31:42.220]   Yeah, and that's it for the installation.
[00:31:42.220 --> 00:31:44.220]   So once this is done, yeah, you should be able to do a few packages.
[00:31:44.220 --> 00:31:49.220]   Yeah, and that's it for the installation.
[00:31:49.220 --> 00:31:57.220]   So once this is done, yeah, you should be able to do a few packages that are needed.
[00:31:57.220 --> 00:32:10.220]   Yeah, and that's it for the installation.
[00:32:10.220 --> 00:32:14.220]   So once this is done, yeah, you should be able to open the notebook.
[00:32:14.220 --> 00:32:18.220]   And again, you can do it, you know, from the terminal, which will write you to a browser
[00:32:18.220 --> 00:32:20.220]   or through VS code.
[00:32:20.220 --> 00:32:30.220]   So if you want to do it through the terminal, you just write Jupyter notebook and then the
[00:32:30.220 --> 00:32:31.220]   name of the notebook.
[00:32:31.220 --> 00:32:38.220]   So it's going to be example with Samba Studio.ipy1b.
[00:32:38.220 --> 00:32:45.220]   I'm actually going to do the demo via VS code just because I can show you the time step.
[00:32:45.220 --> 00:32:52.220]   So I already have this set up.
[00:32:52.220 --> 00:32:57.220]   Okay, so you know we are in the basic examples repo and then example with Samba Studio.
[00:32:57.220 --> 00:33:02.220]   And again, if you're doing it with VS code, just make sure that you have the kernel set up.
[00:33:02.220 --> 00:33:05.220]   So this is a pretty basic script.
[00:33:05.220 --> 00:33:08.220]   So we will first, let me just restart it.
[00:33:08.220 --> 00:33:09.220]   Yeah.
[00:33:09.220 --> 00:33:10.220]   Yeah.
[00:33:10.220 --> 00:33:18.220]   So, yeah, we will be loading the libraries.
[00:33:18.220 --> 00:33:22.220]   So we actually have a wrapper with length chain.
[00:33:22.220 --> 00:33:28.220]   So this is where we will be initializing and calling our endpoints.
[00:33:28.220 --> 00:33:32.220]   The second step is to load the environment variables.
[00:33:32.220 --> 00:33:38.220]   So these are actually the information which we added in the .env file.
[00:33:38.220 --> 00:33:42.220]   And then we will initialize the LLM.
[00:33:42.220 --> 00:33:47.220]   So, yeah, we will be using the Samba Studio wrapper.
[00:33:47.220 --> 00:33:51.220]   And we set the Samba Studio API key.
[00:33:51.220 --> 00:33:53.220]   And then we specify the model configs.
[00:33:53.220 --> 00:33:56.220]   So I had a question earlier about the model configs.
[00:33:56.220 --> 00:34:00.220]   So this is where we can set this up and play with this.
[00:34:00.220 --> 00:34:03.220]   Again, I think most of you are familiar with these configs.
[00:34:03.220 --> 00:34:05.220]   So, you know, do a sample.
[00:34:05.220 --> 00:34:09.220]   If you set it to false, this is basically a deterministic output.
[00:34:09.220 --> 00:34:13.220]   If you set it to true, then it becomes probabilistic.
[00:34:13.220 --> 00:34:18.220]   You can change the temperature and also the max tokens to generate.
[00:34:18.220 --> 00:34:21.220]   And also, this is basically our CoE endpoint, right?
[00:34:21.220 --> 00:34:25.220]   So we have one endpoint through which you can actually call different models.
[00:34:25.220 --> 00:34:31.220]   And in this case, we set the export to MetaLama3HB instruct.
[00:34:31.220 --> 00:34:32.220]   Okay.
[00:34:32.220 --> 00:34:35.220]   So I'll be running the step.
[00:34:35.220 --> 00:34:39.220]   And yeah, we have now our model loaded.
[00:34:39.220 --> 00:34:40.220]   And now we're good to go.
[00:34:40.220 --> 00:34:48.220]   So I'll first show you how you can do an inference call using a simple invoke method in NankChain.
[00:34:48.220 --> 00:34:54.220]   So just write LLM.invoke and then add your prompt.
[00:34:54.220 --> 00:35:01.220]   And the prompt here is what is the capital of France.
[00:35:01.220 --> 00:35:11.220]   And what you'll notice is it gives the right answer, but also give you other stuff which you didn't ask for.
[00:35:11.220 --> 00:35:18.220]   And this is a common thing with open source models because when you ask a prompt, you need to include the special tags, right?
[00:35:18.220 --> 00:35:24.220]   So in the case of LLM3, you can get it from a meta model card.
[00:35:24.220 --> 00:35:30.220]   So you'll have to actually, in the prompt, add these special tags or tokens.
[00:35:30.220 --> 00:35:35.220]   In particular, you have to let the LLM know that this is the beginning of text.
[00:35:35.220 --> 00:35:40.220]   And this is where you will insert the user query, right?
[00:35:40.220 --> 00:35:44.220]   So, and then let the LLM know where it needs to answer.
[00:35:44.220 --> 00:35:50.220]   And once you have the special tags inserted, now you should be able to get the right response.
[00:35:50.220 --> 00:35:53.220]   So this is the first way to do the inference call.
[00:35:53.220 --> 00:35:58.220]   The other way is to do it via a LCL in NankChain.
[00:35:58.220 --> 00:36:05.220]   So basically, you can use the LCL to connect a prompt template with LLM and an output parser.
[00:36:05.220 --> 00:36:09.220]   And NankChain has very templates that you can use.
[00:36:09.220 --> 00:36:13.220]   So, we are asking the same prompt.
[00:36:13.220 --> 00:36:18.220]   It's just that the main difference here, we are adding the country as a placeholder.
[00:36:18.220 --> 00:36:22.220]   And then when you prompt the model, you can actually specify the value of this country, right?
[00:36:22.220 --> 00:36:28.220]   Yeah, so that's it for the basic example.
[00:36:28.220 --> 00:36:30.220]   And as I said, this is just to get you started.
[00:36:30.220 --> 00:36:36.220]   So, yeah, we can spend 10 minutes for you guys to try it out.
[00:36:36.220 --> 00:36:39.220]   Me, Varun, and Oshel will be here to help.
[00:36:39.220 --> 00:36:43.220]   And, yeah, then you can move on to the second exercise.
[00:37:04.220 --> 00:37:14.220]   Yeah, I'll move around if also people have questions.
[00:37:14.220 --> 00:37:20.220]   Do you have the right endpoint set, basically?
[00:37:20.220 --> 00:37:26.220]   Can you open your .nv?
[00:37:26.220 --> 00:37:28.220]   Well, actually, it's working, right?
[00:37:28.220 --> 00:37:29.220]   I don't know.
[00:37:29.220 --> 00:37:41.220]   Can you try the E4, the other one?
[00:37:41.220 --> 00:37:46.220]   Oh, yeah.
[00:37:46.220 --> 00:37:47.220]   Actually, the one here is outdated, basically.
[00:37:47.220 --> 00:37:49.220]   So, if you're using the one, the GitHub is outdated.
[00:37:49.220 --> 00:37:51.220]   So, yeah, you need to use the one from Discord.
[00:37:51.220 --> 00:37:52.220]   Discord.
[00:37:52.220 --> 00:37:56.220]   Yeah, because this is public, so everyone can actually -- sorry about that.
[00:37:56.220 --> 00:37:58.220]   Yeah, so you can use anyone.
[00:37:58.220 --> 00:38:00.220]   You have it working, right?
[00:38:00.220 --> 00:38:01.220]   Yeah.
[00:38:01.220 --> 00:38:02.220]   Yeah, yeah.
[00:38:02.220 --> 00:38:03.220]   Yeah, yeah.
[00:38:07.220 --> 00:38:15.220]   And, yeah, basically, for this workshop, the COE endpoint, we've only activated the LAMA 3.
[00:38:15.220 --> 00:38:22.220]   But eventually, if you were to activate the whole COE against just the same endpoint, then you can just switch between models, basically.
[00:38:22.220 --> 00:38:23.220]   And also --
[00:38:23.220 --> 00:38:32.220]   I don't think the other benchmarks for the LAMA 3 need to be in terms of tokens per second.
[00:38:32.220 --> 00:38:33.220]   You mean performance?
[00:38:33.220 --> 00:38:34.220]   Yeah, yeah.
[00:38:34.220 --> 00:38:35.220]   Yeah.
[00:38:35.220 --> 00:38:41.220]   So, I mean, there's the GPU numbers, right, which I think Oshel presented in the slide deck.
[00:38:41.220 --> 00:38:46.220]   So, we have, I think, 8 to 14x speed up with GPUs.
[00:38:46.220 --> 00:38:52.220]   And there are also, like, you know, other startups who have also, like, high inference speeds, like, basically, Grok.
[00:38:52.220 --> 00:38:57.220]   But, you know, one difference we have with Grok is they run with 576 chips.
[00:38:57.220 --> 00:38:59.220]   We only do it with 16 chips, basically.
[00:38:59.220 --> 00:39:01.220]   And you actually conserve the full precision.
[00:39:01.220 --> 00:39:04.220]   They do it with reduced precision, you know?
[00:39:04.220 --> 00:39:05.220]   So --
[00:39:05.220 --> 00:39:09.220]   It's weird to get a response that quickly.
[00:39:09.220 --> 00:39:10.220]   Yeah, yeah, yeah.
[00:39:10.220 --> 00:39:11.220]   Damn.
[00:39:11.220 --> 00:39:12.220]   Yeah.
[00:39:12.220 --> 00:39:19.220]   Yeah.
[00:39:19.220 --> 00:39:22.220]   Yeah.
[00:39:22.220 --> 00:39:27.220]   Yeah.
[00:39:27.220 --> 00:39:28.220]   Yeah.
[00:39:28.220 --> 00:39:32.220]   Yeah.
[00:39:32.220 --> 00:39:34.220]   Yeah.
[00:39:34.220 --> 00:39:36.220]   Yeah.
[00:39:36.220 --> 00:39:45.220]   Yeah.
[00:39:45.220 --> 00:39:48.220]   Were you able to get it right or you're not trying good?
[00:39:48.220 --> 00:39:49.220]   Yeah.
[00:39:49.220 --> 00:39:50.220]   That's fine.
[00:39:50.220 --> 00:39:54.220]   Let me know if you have questions.
[00:39:54.220 --> 00:39:55.220]   Okay.
[00:39:55.220 --> 00:39:58.220]   Nice.
[00:39:58.220 --> 00:39:59.220]   Yeah.
[00:39:59.220 --> 00:40:01.220]   Maybe you can have our stuff there.
[00:40:01.220 --> 00:40:02.220]   Yeah.
[00:40:02.220 --> 00:40:03.220]   Yeah.
[00:40:03.220 --> 00:40:05.220]   But this is simple if you want to try it out.
[00:40:05.220 --> 00:40:06.220]   Yeah.
[00:40:06.220 --> 00:40:07.220]   Okay.
[00:40:07.220 --> 00:40:08.220]   So no need for the migrate.
[00:40:08.220 --> 00:40:09.220]   Yeah.
[00:40:09.220 --> 00:40:21.220]   Which one are you using?
[00:40:21.220 --> 00:40:22.220]   Let's try both.
[00:40:22.220 --> 00:40:25.220]   Try the two that are in here, the P2 and E4.
[00:40:25.220 --> 00:40:26.220]   Yeah.
[00:40:26.220 --> 00:40:28.220]   Then maybe your internet connection then.
[00:40:28.220 --> 00:40:29.220]   I don't know.
[00:40:29.220 --> 00:40:30.220]   Yeah.
[00:40:30.220 --> 00:40:31.220]   Yeah.
[00:40:31.220 --> 00:40:32.220]   Yeah.
[00:40:32.220 --> 00:40:33.220]   No, it's not.
[00:40:33.220 --> 00:40:35.220]   Can you restart the notebook and then...
[00:40:35.220 --> 00:40:36.220]   Yeah.
[00:40:36.220 --> 00:40:37.220]   You did that.
[00:40:37.220 --> 00:40:38.220]   Okay.
[00:40:38.220 --> 00:40:40.220]   Let's try the next part.
[00:40:40.220 --> 00:40:41.220]   I wonder if there's...
[00:40:41.220 --> 00:40:42.220]   Yeah.
[00:40:42.220 --> 00:40:44.220]   If it's authenticating...
[00:40:44.220 --> 00:40:45.220]   Yeah.
[00:40:45.220 --> 00:40:49.220]   Like, this should be faster.
[00:40:49.220 --> 00:40:50.220]   But anyway, let's...
[00:40:50.220 --> 00:40:51.220]   No, yeah.
[00:40:51.220 --> 00:40:52.220]   I mean, this one should take, yeah, three seconds.
[00:40:52.220 --> 00:40:53.220]   Yeah.
[00:40:53.220 --> 00:40:54.220]   That's it.
[00:40:54.220 --> 00:40:55.220]   Yeah.
[00:40:55.220 --> 00:40:56.220]   But because this is without the special tags, right?
[00:40:56.220 --> 00:40:57.220]   So because it's a long...
[00:40:57.220 --> 00:40:58.220]   Yeah.
[00:40:58.220 --> 00:40:59.220]   This one, yeah, it should be just, yeah.
[00:40:59.220 --> 00:41:00.220]   Oh, I see.
[00:41:00.220 --> 00:41:01.220]   Yeah, yeah, yeah.
[00:41:01.220 --> 00:41:02.220]   Yeah, yeah, yeah.
[00:41:02.220 --> 00:41:03.220]   Yeah, yeah, yeah.
[00:41:03.220 --> 00:41:04.220]   No, because...
[00:41:04.220 --> 00:41:05.220]   It's one thing?
[00:41:05.220 --> 00:41:10.220]   No, it's basically waiting for the whole thing to complete and then you're outputting the answer,
[00:41:10.220 --> 00:41:11.220]   you know?
[00:41:11.220 --> 00:41:12.220]   So, yeah.
[00:41:12.220 --> 00:41:13.220]   Yeah.
[00:41:13.220 --> 00:41:14.220]   So the same question...
[00:41:14.220 --> 00:41:15.220]   Oh, it's putting...
[00:41:15.220 --> 00:41:16.220]   You have questions?
[00:41:16.220 --> 00:41:17.220]   Were you able to try it out or just...
[00:41:17.220 --> 00:41:18.220]   Yeah, yeah, yeah.
[00:41:18.220 --> 00:41:19.220]   Yeah.
[00:41:19.220 --> 00:41:20.220]   Okay.
[00:41:20.220 --> 00:41:21.220]   No, let me know if you have questions.
[00:41:21.220 --> 00:41:22.220]   Sure.
[00:41:22.220 --> 00:41:23.220]   Thanks.
[00:41:23.220 --> 00:41:24.220]   Yeah.
[00:41:24.220 --> 00:41:24.220]   Yeah.
[00:41:24.220 --> 00:41:25.220]   Yeah.
[00:41:25.220 --> 00:41:26.220]   So the first one...
[00:41:26.220 --> 00:41:27.220]   Yeah, it's the prompt gen.
[00:41:27.220 --> 00:41:28.220]   So the same question has been wrapped into...
[00:41:28.220 --> 00:41:29.220]   So what is the prompt gen.
[00:41:29.220 --> 00:41:29.220]   So what is the prompt gen.
[00:41:29.220 --> 00:41:30.220]   So prompt gen.
[00:41:30.220 --> 00:41:31.220]   So prompt gen.
[00:41:31.220 --> 00:41:40.400]   Yeah, so the first one, yeah, it's the prompt template.
[00:41:40.400 --> 00:41:46.000]   So the same question has been wrapped into what is the prompt template?
[00:41:46.000 --> 00:41:51.660]   So prompt template is basically template and using those tabs.
[00:41:51.660 --> 00:41:56.600]   So the language is the specific template.
[00:41:56.600 --> 00:42:00.100]   So you need to drive the instruction to the body in that template.
[00:42:00.100 --> 00:42:02.400]   So that's how the body would write kind of work.
[00:42:02.400 --> 00:42:06.640]   If you don't write any of them, the body just kind of gives you--
[00:42:06.640 --> 00:42:09.080]   And I think this is just one that I don't know.
[00:42:09.080 --> 00:42:11.720]   I don't know, this is just a small amount of time
[00:42:11.720 --> 00:42:15.560]   to try this with other .
[00:42:15.560 --> 00:42:18.600]   So that's what it is.
[00:42:18.600 --> 00:42:28.300]   In the next, we should move to the second one,
[00:42:28.300 --> 00:42:31.880]   or maybe just give it a little more.
[00:42:31.880 --> 00:42:32.380]   Yeah.
[00:42:36.840 --> 00:42:41.220]   Yeah, so I mean, you can get it from the--
[00:42:41.220 --> 00:42:45.380]   So if you go to Google, and then write meta 3, llama card,
[00:42:45.380 --> 00:42:46.380]   you get it there.
[00:42:46.380 --> 00:42:46.880]   Yeah.
[00:42:46.880 --> 00:42:52.040]   Yeah, so I mean, you can get it from the--
[00:42:52.040 --> 00:42:52.920]   The llama card.
[00:42:52.920 --> 00:42:58.620]   Yeah, so if you go to Google, and then write meta 3, llama card,
[00:42:58.620 --> 00:42:59.620]   you get it there.
[00:42:59.620 --> 00:43:00.120]   OK.
[00:43:00.120 --> 00:43:01.680]   So that would come up the entire file.
[00:43:01.680 --> 00:43:02.180]   Yeah.
[00:43:02.180 --> 00:43:02.680]   Yeah.
[00:43:02.680 --> 00:43:20.480]   I think we can move to the second one.
[00:43:20.480 --> 00:43:23.060]   Yeah, since everyone tried it out.
[00:43:23.060 --> 00:43:23.520]   Yeah.
[00:43:23.520 --> 00:43:28.020]   Yeah.
[00:43:28.020 --> 00:43:29.020]   Like, I--
[00:43:29.020 --> 00:43:29.600]   Yeah, yesterday.
[00:43:29.600 --> 00:43:41.140]   OK, cool.
[00:43:41.140 --> 00:43:46.720]   I think many of you were able to try out this simple exercise.
[00:43:46.720 --> 00:43:50.720]   So yeah, we'll move now to the second one.
[00:43:50.720 --> 00:43:51.560]   Everyone's going to--
[00:43:51.560 --> 00:43:56.220]   Yeah.
[00:44:05.720 --> 00:44:08.880]   Yeah, so as I said earlier, this is going
[00:44:08.880 --> 00:44:14.600]   to be a Q&A system with RAG.
[00:44:14.600 --> 00:44:20.040]   And if you want to follow along, again, from the same repo,
[00:44:20.040 --> 00:44:26.620]   go to workshop, AI engineer, 2024, and then EQR RAG.
[00:44:26.620 --> 00:44:30.580]   And like the previous exercise, I'll go through the readme,
[00:44:30.580 --> 00:44:33.140]   do a live demo of the installation and the run setup,
[00:44:33.140 --> 00:44:37.060]   and then give you some time to try it out.
[00:44:37.060 --> 00:44:40.880]   And the app here, we have two versions of it,
[00:44:40.880 --> 00:44:44.720]   one with Jupyter Notebook and the other one
[00:44:44.720 --> 00:44:47.940]   with Streamlit, which is a UI based.
[00:44:47.940 --> 00:44:52.060]   And before I jump into the hands-on,
[00:44:52.060 --> 00:44:56.660]   just wanted to give a brief overview of what RAG is,
[00:44:56.660 --> 00:44:58.220]   although I'm sure many of you already
[00:44:58.220 --> 00:45:02.900]   know this concept, but just for completeness.
[00:45:02.900 --> 00:45:05.600]   So yeah, so RAG is a technique that we
[00:45:05.600 --> 00:45:10.200]   can use to supplement LLM with additional information
[00:45:10.200 --> 00:45:14.720]   from various sources to improve the model's response.
[00:45:14.720 --> 00:45:17.140]   And RAG is very helpful if you want
[00:45:17.140 --> 00:45:23.080]   to use an off-the-shelf LLM to ask a question beyond its training
[00:45:23.080 --> 00:45:29.940]   data, or if you want to have the LLM access to up-to-date information
[00:45:29.940 --> 00:45:31.820]   without retraining it.
[00:45:31.820 --> 00:45:37.680]   Also, you know, RAG can help reduce hallucinations in some context.
[00:45:37.680 --> 00:45:49.640]   And a typical RAG workflow consists of the following steps.
[00:45:49.640 --> 00:45:53.340]   So we first have document loading and parsing.
[00:45:53.340 --> 00:45:58.880]   So this is where we can use a data loader to actually load the data
[00:45:58.880 --> 00:46:03.460]   into a digital text that we can edit and format.
[00:46:03.460 --> 00:46:10.760]   And various data loaders are available depending on the extension of the file you're using.
[00:46:10.760 --> 00:46:14.200]   So in a PDF, text, PowerPoint.
[00:46:14.200 --> 00:46:16.080]   After this, we have a splitting step.
[00:46:16.080 --> 00:46:22.300]   So this is where we will be splitting the document into smaller chunks.
[00:46:22.300 --> 00:46:28.040]   And you know, the chunk size and the overlap, all of these are hyperparams.
[00:46:28.040 --> 00:46:31.040]   And the next step is vectorization.
[00:46:31.040 --> 00:46:39.700]   So this is where we will be using an embedding model like E5 large V2 to map each chunk to
[00:46:39.700 --> 00:46:40.780]   a numerical vector.
[00:46:40.780 --> 00:46:49.020]   numerical vector and we can store, you know, the vectors along with the content and the metadata
[00:46:49.020 --> 00:46:51.660]   in a vector store like face and chroma DB.
[00:46:51.660 --> 00:46:55.660]   And today we will be using chroma DB, which is open source.
[00:46:55.660 --> 00:47:04.880]   And again, the whole goal of this embedding is that it allows us to do like semantic similarity
[00:47:04.880 --> 00:47:08.260]   and semantic search.
[00:47:08.260 --> 00:47:13.800]   And in the retrieval step, this is where we ask the question, which is going to also be
[00:47:13.800 --> 00:47:17.200]   embedded into the vector space.
[00:47:17.200 --> 00:47:23.520]   And then we have a retriever, which is going to retrieve the closest chunk vectors to the
[00:47:23.520 --> 00:47:28.040]   query vector according to some similarity metric.
[00:47:28.040 --> 00:47:37.420]   And we can also add a re-ranker, which can re-rank the retrieved chunks per relevance and also
[00:47:37.420 --> 00:47:40.600]   remove some of the unnecessary chunks.
[00:47:40.600 --> 00:47:43.520]   And the last step is basically Q&A generation.
[00:47:43.520 --> 00:47:52.120]   So this is where you provide the LLM with the query and the final retrieved chunk to get the
[00:47:52.120 --> 00:47:53.640]   grounded response.
[00:47:53.640 --> 00:48:02.020]   And yeah, I maybe also would like to precise that in this exercise, so the, we will be using
[00:48:02.020 --> 00:48:07.100]   third party tools for document loading, splitting and storage.
[00:48:07.100 --> 00:48:12.500]   For the embedding model, you can either run it on CPU or on our hardware.
[00:48:12.500 --> 00:48:15.300]   And we'll be doing both to show the differences.
[00:48:15.300 --> 00:48:19.020]   And for the LLM part, this is going to be done on our hardware.
[00:48:19.020 --> 00:48:23.540]   So yeah, that's it for the overview.
[00:48:23.540 --> 00:48:26.920]   And I think, yeah, we can move on to the readme.
[00:48:26.920 --> 00:48:30.980]   Yeah, so we first clone the repo.
[00:48:30.980 --> 00:48:36.540]   I think if you've done the other exercise, then you don't have to do this step.
[00:48:36.540 --> 00:48:43.000]   So the second thing, after this, we will set up the environment variable.
[00:48:43.000 --> 00:48:50.060]   So for this one, we will be using Samba Studio API for the LLM.
[00:48:50.060 --> 00:48:55.580]   And also, we will be using an embedding API as well.
[00:48:55.580 --> 00:48:57.960]   So both are available on Discord.
[00:48:57.960 --> 00:49:03.580]   Yeah, let me show you in the terminal.
[00:49:03.580 --> 00:49:10.980]   Yeah, and actually, yeah, I would also recommend to deactivate your previous environment.
[00:49:10.980 --> 00:49:19.100]   Okay, so we go to the EKRRAG repo.
[00:49:19.100 --> 00:49:26.480]   Yeah, actually, for the .n file, this one you'll have to put it at this level, the AI Sutter Kit.
[00:49:26.480 --> 00:49:36.480]   Okay, so for this one, we will need the embed endpoint and API key and also the Samba Studio endpoint and API key.
[00:49:38.760 --> 00:49:49.040]   All right, then we go back to the EKRRAG folder and then we are ready to go with the installation.
[00:49:49.040 --> 00:49:52.120]   So here, we will be needing more packages.
[00:49:52.120 --> 00:49:57.880]   So first, Tesseract, this is our OCR data extractor.
[00:49:57.880 --> 00:50:02.960]   So let's say you're using a Mac, just run brew install Tesseract.
[00:50:02.960 --> 00:50:07.160]   And this one, you can do it outside your local environment.
[00:50:07.160 --> 00:50:10.160]   It should take, you know, a few minutes to install.
[00:50:10.160 --> 00:50:16.960]   And you also need Poplar if you don't have it already, you can just do brew install Poplar.
[00:50:16.960 --> 00:50:22.840]   And then, yeah, we will need to set our virtual environment.
[00:50:22.840 --> 00:50:31.000]   So since this is a more complicated exercise, I would just recommend to use the, you know, default option.
[00:50:31.000 --> 00:50:36.960]   So the Python environment with a Python 3.10.
[00:50:36.960 --> 00:50:53.600]   So if you don't have a Python 3.10, let's say on a Mac, you can install it using this command here, and then you can add the path to your shell, like BashRC or ZSHRC using this command here.
[00:50:53.600 --> 00:50:58.840]   And then you can just source your shell file.
[00:50:58.840 --> 00:51:05.400]   Okay, and then, yeah, we will go to the repo if you haven't done this already.
[00:51:05.400 --> 00:51:08.600]   Create your Python environment.
[00:51:08.600 --> 00:51:18.400]   So, again, if you added this step here, then your laptop should recognize the Python 3.10, then -m, venv, and then the name of the environment.
[00:51:18.400 --> 00:51:24.600]   You activate that environment, and then you run the install script.
[00:51:24.600 --> 00:51:39.600]   So this should take, I would say, you know, five minutes if you have good Internet, and once this is done, you also need to install IPy kernel, and also link your kernel to your notebook.
[00:51:39.600 --> 00:51:53.600]   So when we tested this on different laptops, you know, some folks were having also sometimes NLTK and SSL Certificate, so you might also need to run this script here.
[00:51:53.600 --> 00:52:00.600]   Yes, it's in my bag, basically.
[00:52:00.600 --> 00:52:07.600]   Yeah, so let's activate the Python environment.
[00:52:07.600 --> 00:52:20.600]   Yeah, and this is the requirements file, and as you can see, right, we have more packages here.
[00:52:20.600 --> 00:52:27.600]   And then, yeah, this is the file which you may need to also run as well.
[00:52:27.600 --> 00:52:34.600]   Yeah, and once this is set up, that's all you need to run.
[00:52:34.600 --> 00:52:35.600]   That's fine.
[00:52:35.600 --> 00:52:36.600]   I can do it.
[00:52:36.600 --> 00:52:37.600]   Okay.
[00:52:37.600 --> 00:52:39.600]   Yeah, the notebook.
[00:52:39.600 --> 00:52:46.600]   And as I said earlier, right, so we have the app in a notebook and in a streamlet.
[00:52:46.600 --> 00:52:54.600]   So for the notebook, again, right, you can open it from the terminal or from VS Code.
[00:52:54.600 --> 00:53:09.600]   Yeah, so you'll go to the eqr.rag, repo, notebooks, and then raglcl.ipy1b, and this is going to be our main script, which is using actually, you know, files and models from other files.
[00:53:09.600 --> 00:53:24.600]   So, in particular, we will be using the document retrieval.py, and also some files from the VectorDB, which I'll explain in more details.
[00:53:24.600 --> 00:53:39.600]   All right, so let's go maybe first over the structure of the notebook.
[00:53:39.600 --> 00:53:46.600]   So we first import the libraries and set the required path.
[00:53:46.600 --> 00:53:55.600]   So you don't have to do anything at this point, but yeah, just know that the kit directory, this is the absolute path for your eqr.rag.
[00:53:55.600 --> 00:54:00.600]   And then the repo directory, this is the absolute path for the AIS of the kit.
[00:54:00.600 --> 00:54:03.600]   So let's run this repo.
[00:54:03.600 --> 00:54:18.600]   And then for the document loading and splitting, yeah, so we added, you know, various data loaders, you know, like PyPDF and unstructured.
[00:54:18.600 --> 00:54:27.600]   And which data loader you want, you can set this up in the config file, which is here.
[00:54:27.600 --> 00:54:35.600]   So yeah, I'm just going to do a test with PyPDF2 for now, but we can switch to other data loaders afterwards.
[00:54:35.600 --> 00:54:42.600]   And yeah, for the experiment, I will be using the SN40L paper.
[00:54:42.600 --> 00:54:47.600]   So this is an archive paper, which we recently submitted.
[00:54:47.600 --> 00:54:54.600]   So this contains like information about the stack, the hardware and our COE.
[00:54:54.600 --> 00:54:57.600]   I can show you the paper as well.
[00:54:57.600 --> 00:55:02.600]   We also have it in GitHub, but you can also upload your own PDF.
[00:55:02.600 --> 00:55:18.600]   And yeah, you'll have it to put it under data, temp, and then, yeah, this is the paper that I'll be using for the demo.
[00:55:18.600 --> 00:55:26.600]   All right, and let's go back to our VS code.
[00:55:26.600 --> 00:55:35.600]   So this is where, you know, we will be using PyPDF to actually load the content into a list.
[00:55:35.600 --> 00:55:41.600]   And then we are using the recursive splitter from LengChain.
[00:55:41.600 --> 00:55:47.600]   So what I'll do first is going to the notebook and then we can go into the functions and more details if you are interested.
[00:55:47.600 --> 00:56:00.600]   Yeah, so let's run this step.
[00:56:00.600 --> 00:56:08.600]   Yeah, and in the config, so I set the chunk size to 1200 and then the chunk overlap to 240.
[00:56:08.600 --> 00:56:10.600]   But again, you can change those configs.
[00:56:10.600 --> 00:56:17.600]   So for this 15-page PDF, we end up getting 89 chunks.
[00:56:17.600 --> 00:56:20.600]   The next step is the vectorization and storage.
[00:56:20.600 --> 00:56:27.600]   So this is where we will be using the embedding model to map each chunk to an embedding vector.
[00:56:27.600 --> 00:56:34.600]   And as I said earlier, right, so we can actually run the embedding model either on CPU or on RDU.
[00:56:34.600 --> 00:56:36.600]   So RDU is basically our AI chip.
[00:56:36.600 --> 00:56:46.600]   So if you want to do it on RDU, then you'll have to go to the config.yaml file and then set the type to Samba Studio.
[00:56:46.600 --> 00:56:52.600]   And then BAT size, so this one you can have it either 1 or 32.
[00:56:52.600 --> 00:56:57.600]   So 32 means that we are actually processing 32 chunks at the same time.
[00:56:57.600 --> 00:57:03.600]   And this is a standalone endpoint, so yeah, the COE is set to false.
[00:57:03.600 --> 00:57:12.600]   And I'll show later, if you want to run the endpoint for the embedding on your laptop, how you can change the configs for that.
[00:57:12.600 --> 00:57:17.600]   All right, and then, yeah, let's run the vectorization.
[00:57:17.600 --> 00:57:23.600]   And after this, we're actually storing or indexing the embedding vectors into the ChromaDB vector store.
[00:57:23.600 --> 00:57:28.600]   I think this should take around 10 seconds.
[00:57:28.600 --> 00:57:29.600]   Let me see what's happening.
[00:57:29.600 --> 00:57:46.600]   Yeah, always good to restart the notebooks.
[00:57:46.600 --> 00:57:49.600]   I'll just go over the steps again.
[00:57:49.600 --> 00:57:50.600]   Okay.
[00:57:50.600 --> 00:58:04.600]   Yeah, so it took, you know, four seconds to embed the whole thing.
[00:58:04.600 --> 00:58:10.600]   And yeah, this is where we will initialize our QA chain.
[00:58:10.600 --> 00:58:18.600]   So again, we have different wrappers and classes, which I can go over it in details afterwards.
[00:58:18.600 --> 00:58:20.600]   But for now, let's just execute the cell.
[00:58:20.600 --> 00:58:22.600]   Yeah, now you're ready to go.
[00:58:22.600 --> 00:58:24.600]   Ask a question.
[00:58:24.600 --> 00:58:31.600]   And then what happens is right through this QA chain, the question gets embedded to the vector space.
[00:58:31.600 --> 00:58:34.600]   We retrieve the top K chunks.
[00:58:34.600 --> 00:58:40.600]   So in this experiment, yeah, we have this set to three since I won't be using a Reranker.
[00:58:40.600 --> 00:58:43.600]   But I can also show you how to use the Reranker.
[00:58:43.600 --> 00:58:53.600]   And then, yeah, the question and the context are provided as basically context for the LLM to get the answer.
[00:58:53.600 --> 00:58:57.600]   So, yeah, what is a monolithic model?
[00:58:57.600 --> 00:59:00.600]   And you can see the response is instantaneous.
[00:59:00.600 --> 00:59:06.600]   Yeah, so that's it for the experiment.
[00:59:06.600 --> 00:59:09.600]   Let's maybe try ask it a bit more complicated question.
[00:59:09.600 --> 00:59:11.600]   So if I open the PDF again.
[00:59:21.600 --> 00:59:28.600]   I think, yeah, there was a table in the PDF.
[00:59:28.600 --> 00:59:35.600]   Yeah, like this is a table, you know, showing operation intensity versus fusion level.
[00:59:35.600 --> 00:59:43.600]   So, yeah, let's see if PyPDF is able to retrieve some of the information from this table here.
[00:59:43.600 --> 00:59:46.600]   So I already have the questions prepared.
[00:59:46.600 --> 00:59:49.600]   Let's try to access those.
[00:59:49.600 --> 00:59:52.600]   Yeah, so, yeah, we got the response, right?
[00:59:52.600 --> 00:59:54.600]   So 4.10.4 basically.
[00:59:54.600 --> 01:00:00.600]   And again, if you end up having more complicated tables in PDF, in this case, I would recommend
[01:00:00.600 --> 01:00:02.600]   to switch to the unstructured data loader.
[01:00:02.600 --> 01:00:11.600]   And for this, yeah, all you have to do is just go to the config file and then change PyPDF to unstructured.
[01:00:11.600 --> 01:00:17.600]   So, yeah, that's it for the second exercise.
[01:00:17.600 --> 01:00:28.600]   I can go into more details about each function if you're interested, or have you try it out first,
[01:00:28.600 --> 01:00:33.600]   and then you can maybe come back and then go over the functions.
[01:00:33.600 --> 01:00:37.600]   Yeah, so do you want to maybe try it out first, I guess?
[01:00:37.600 --> 01:00:38.600]   Okay, great.
[01:00:38.600 --> 01:00:39.600]   Thank you.
[01:00:39.600 --> 01:00:40.600]   Thank you.
[01:00:40.600 --> 01:00:41.600]   Thank you.
[01:00:41.600 --> 01:00:43.600]   Thank you.
[01:00:43.600 --> 01:00:44.600]   Thank you.
[01:00:44.600 --> 01:00:45.600]   Thank you.
[01:00:45.600 --> 01:00:46.600]   Thank you.
[01:00:46.600 --> 01:00:47.600]   Thank you.
[01:00:47.600 --> 01:00:48.600]   Thank you.
[01:00:48.600 --> 01:00:49.600]   Thank you.
[01:00:49.600 --> 01:00:50.600]   Thank you.
[01:00:50.600 --> 01:00:51.600]   Thank you.
[01:00:51.600 --> 01:00:52.600]   Thank you.
[01:00:52.600 --> 01:00:53.100]   you
[01:00:53.100 --> 01:00:55.160]   you
[01:00:55.160 --> 01:00:57.220]   you

