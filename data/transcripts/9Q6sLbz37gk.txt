
[00:00:00.000 --> 00:00:08.380]   Hi there, I'm Jeremy Howard from fast.ai and I'd like to tell you a bit about why I like Jupyter Notebooks and
[00:00:08.380 --> 00:00:13.820]   help you maybe find some new ways that might help you really like them as well.
[00:00:13.820 --> 00:00:17.060]   I feel like this is kind of a dangerous thing to say.
[00:00:17.060 --> 00:00:22.220]   I like notebooks because every time I do to a serious software engineer type
[00:00:22.220 --> 00:00:26.000]   they tell me all the reasons that I should not like Jupyter Notebooks.
[00:00:26.420 --> 00:00:31.380]   And they kind of act like I must just be ignorant and don't understand the better ways to code.
[00:00:31.380 --> 00:00:39.040]   But actually I've built a lot of good stuff in Jupyter Notebooks, and I've been coding for gosh about 30 years
[00:00:39.040 --> 00:00:41.800]   over that pretty much every day.
[00:00:41.800 --> 00:00:49.680]   I've used a lot of different IDEs, a lot of different editors, and Jupyter Notebooks seriously makes me at least twice as productive
[00:00:49.680 --> 00:00:51.680]   and I have a lot more fun.
[00:00:51.680 --> 00:00:55.180]   I've built a number of popular software libraries
[00:00:55.760 --> 00:00:57.760]   like these ones in Jupyter Notebooks.
[00:00:57.760 --> 00:01:02.640]   In particular, Fast.ai, which is perhaps the most popular
[00:01:02.640 --> 00:01:05.960]   PyTorch deep learning API,
[00:01:05.960 --> 00:01:15.000]   other than PyTorch itself, I guess, and is very widely used at many companies, many researchers, many universities, and so forth.
[00:01:15.000 --> 00:01:22.080]   One of the cool things you'll see in the Fast.ai library is that actually the
[00:01:22.880 --> 00:01:27.360]   documentation, which you see here, it's got all these
[00:01:27.360 --> 00:01:34.520]   examples scattered throughout it and most things like links to source code and links to papers and links to other parts of documentation.
[00:01:34.520 --> 00:01:41.760]   And actually you can click on any part of the documentation at the top and the opening collab button.
[00:01:41.760 --> 00:01:47.500]   And if you do that, then suddenly you'll see that entire documentation appear as an
[00:01:48.080 --> 00:01:54.640]   interactive, experimental playground you can play with yourself because you see all the documentation is written in Jupyter Notebooks.
[00:01:54.640 --> 00:02:00.680]   Actually, not just the documentation, but all of the code itself for the library and all of the tests.
[00:02:00.680 --> 00:02:03.000]   And they're actually all in the same notebook.
[00:02:03.000 --> 00:02:10.480]   So if you start looking at one piece, you can see everything. You can see, as you see here, the implementation of this combined cosine
[00:02:10.480 --> 00:02:14.080]   scheduler. You can see the examples. You can see the tests.
[00:02:14.080 --> 00:02:20.120]   You can see the documentation and you can start playing with it straight away to experiment with some different values and see how it works.
[00:02:20.120 --> 00:02:23.720]   Look at the inputs and outputs and so forth. I think that's really cool.
[00:02:23.720 --> 00:02:30.200]   The way that I do this is by using something called nbdev
[00:02:30.200 --> 00:02:32.840]   for notebook development.
[00:02:32.840 --> 00:02:38.880]   nbdev is a really amazing project which I'm going to tell you a lot about at the end of this talk, the second half of this talk.
[00:02:38.880 --> 00:02:45.660]   But basically what nbdev does is it lets you create Python modules directly from your notebooks.
[00:02:45.660 --> 00:02:51.840]   You can export changes from your editor back to your notebook if you want to change things in the editor or IDE directly.
[00:02:51.840 --> 00:02:58.200]   It automatically creates searchable documentation. It automatically creates PyPy and Conda installers.
[00:02:58.200 --> 00:02:59.720]   It will
[00:02:59.720 --> 00:03:04.720]   run your tests in parallel and the tests are in notebooks. It will handle continuous integration.
[00:03:04.720 --> 00:03:07.800]   It will handle version control stuff and so forth.
[00:03:08.200 --> 00:03:10.200]   It's really, really nice.
[00:03:10.200 --> 00:03:17.840]   I write all kinds of stuff in notebooks and here's an example of a little server I made.
[00:03:17.840 --> 00:03:24.220]   And so I made this little server and it's a GitHub or a get webhook
[00:03:24.220 --> 00:03:28.160]   server. And the nice thing is that I haven't really
[00:03:28.160 --> 00:03:33.840]   done much stuff directly using Python's built-in HTTP handler classes before.
[00:03:34.080 --> 00:03:39.160]   So I started experimenting with them and I did so in a notebook and as I experimented
[00:03:39.160 --> 00:03:42.720]   I took down notes to myself and I started to create examples and little tests.
[00:03:42.720 --> 00:03:45.280]   And this now becomes
[00:03:45.280 --> 00:03:52.480]   part of the documentation and the source code and the tests of the library I ended up building,
[00:03:52.480 --> 00:03:54.000]   which is called fast webhook.
[00:03:54.000 --> 00:04:01.200]   So you can see that you can kind of, you can write any kind of code in notebooks and you can end up exporting it
[00:04:01.640 --> 00:04:05.360]   into a real library and now anybody can download
[00:04:05.360 --> 00:04:11.800]   fast webhook and then they can see not only the final result but the process I took to get there and
[00:04:11.800 --> 00:04:21.080]   understand my thinking, understand the APIs I'm using, understanding the parts of the Python standard library I'm using because it's all documented in this process.
[00:04:21.080 --> 00:04:28.440]   So a lot of other people are now using nbdev and one of the best comments
[00:04:28.440 --> 00:04:31.440]   I've seen is from Hamel Hossain from GitHub who said,
[00:04:31.440 --> 00:04:37.360]   "Tests, docs and code are part of the same context and are co-located."
[00:04:37.360 --> 00:04:39.680]   So this is what happens when you write with nbdev.
[00:04:39.680 --> 00:04:44.080]   And he says, "There is no other programming environment that exists like this that I'm aware of."
[00:04:44.080 --> 00:04:48.120]   You can even make notes to yourself about why something works the way it does
[00:04:48.120 --> 00:04:52.720]   very easily while you're writing the code and it isn't an afterthought.
[00:04:53.680 --> 00:05:01.160]   This is fundamentally why I have a problem working in anything besides nbdev because not only does it make the code more approachable to others
[00:05:01.160 --> 00:05:05.440]   but forcing you to write docs actually forces you to think about the code more.
[00:05:05.440 --> 00:05:11.840]   And my personal projects that use nbdev I often refactor my code to be simpler and better
[00:05:11.840 --> 00:05:16.280]   after forcing myself to explain it and I have the exact same experience.
[00:05:16.280 --> 00:05:21.200]   It really makes a difference to my workflow and a lot of this is really thanks to the underlying
[00:05:21.680 --> 00:05:25.640]   Jupyter Notebook system which nbdev sits on top of.
[00:05:25.640 --> 00:05:30.200]   Silvair Guttner and I, Silvair is my co-author on Fast AI.
[00:05:30.200 --> 00:05:36.120]   He is also my co-author on the Deep Learning for Coders book, which has been incredibly popular
[00:05:36.120 --> 00:05:41.320]   including some big names you probably know about who really like it.
[00:05:41.320 --> 00:05:45.960]   This whole book was written entirely in Jupyter Notebooks
[00:05:45.960 --> 00:05:52.720]   and then we exported it directly with a single little script we wrote into AsciiDoc sent it off to O'Reilly
[00:05:52.720 --> 00:05:59.680]   and they published it into this beautiful book and a lot of people have commented on how nice this book looks,
[00:05:59.680 --> 00:06:07.880]   how good it feels, it's got color and nice little icons and all the stuff you'd expect, a really nice index and so forth.
[00:06:07.880 --> 00:06:12.320]   So we've created a book that we're really proud of and a lot of people really like.
[00:06:13.520 --> 00:06:16.960]   And if you want to write a book yourself as well, you can.
[00:06:16.960 --> 00:06:23.040]   You can pip or condor install FastDoc, which Silvair and I have made available.
[00:06:23.040 --> 00:06:27.280]   This is the exact same thing that we use to make our book and you can run a single command.
[00:06:27.280 --> 00:06:33.840]   FastDoc convert all and it will convert all of your notebooks into a publication quality book,
[00:06:33.840 --> 00:06:37.480]   or at least the AsciiDoc source for it, which you can then send to a publisher.
[00:06:37.480 --> 00:06:40.000]   All you have to do is write the book.
[00:06:40.960 --> 00:06:46.280]   Here's another example of something that we created with Jupyter Notebooks,
[00:06:46.280 --> 00:06:51.320]   which is a very popular course and of course people really, really like.
[00:06:51.320 --> 00:06:56.680]   Nearly everybody seems to like this course, which we're so proud of because we spend a lot of time trying to get it right.
[00:06:56.680 --> 00:07:03.760]   And the whole thing is actually, or nearly the whole thing, is actually taught in Jupyter Notebooks.
[00:07:03.760 --> 00:07:11.240]   And the students then take these notebooks and what we do is we clear out all of the pros and all of the outputs
[00:07:11.240 --> 00:07:18.600]   and we ask the students to try to go through the notebook and figure out what's going to happen next and why are we doing this.
[00:07:18.600 --> 00:07:23.240]   It's a great way to kind of force people to think about like, "Oh, did I really understand this?
[00:07:23.240 --> 00:07:26.600]   Do I really know what's going to happen?" And then they can run it and check.
[00:07:26.600 --> 00:07:29.720]   And if the answer is different to what they expected, then they can experiment.
[00:07:29.720 --> 00:07:39.760]   It's a really terrific way to learn and pretty much all of our students have said that once they get into it, they really adore it, they really find it terrific.
[00:07:39.760 --> 00:07:47.200]   Overall, the key thing, I guess, that I like about Jupyter Notebooks is that they support literate programming.
[00:07:47.200 --> 00:07:52.920]   Literate programming is something that I have been fascinated in ever since I read about it in the early 90s,
[00:07:52.920 --> 00:08:03.080]   developed by Donald Knuth, a famous computer scientist, who describes it as a methodology that combines a programming language with a documentation language,
[00:08:03.080 --> 00:08:11.960]   thereby making programs more robust, more portable, more easily maintained, and arguably, certainly I find more fun to write.
[00:08:11.960 --> 00:08:18.240]   The main idea is to treat a program as a piece of literature addressed to human beings rather than to a computer.
[00:08:18.240 --> 00:08:24.080]   And this is certainly the way that we now write code with notebooks and NVDev.
[00:08:24.080 --> 00:08:29.920]   And I think we actually go beyond literate programming to what I call exploratory programming,
[00:08:29.920 --> 00:08:35.840]   where we're using our notebook as a kind of a journal, like a scientist's journal.
[00:08:35.840 --> 00:08:41.840]   And then when we're done, we'll go back and we'll try to clean it up as best as we can and we'll make that part of what we publish.
[00:08:41.840 --> 00:08:46.480]   So, for example, here's the actual source code from NVDev itself.
[00:08:46.480 --> 00:08:54.800]   And at the very start, Sylvain and I didn't know much about what is the Jupyter notebook really behind the scenes.
[00:08:54.800 --> 00:09:04.400]   And as we started exploring and realizing it's just JSON and printing it out, that became part of our documentation and source code.
[00:09:04.400 --> 00:09:11.120]   And you can see we start to create and export functions as we go along, and that becomes part of the library.
[00:09:11.120 --> 00:09:19.520]   So then when somebody else comes along and wants to contribute to NVDev or to any project written with NVDev,
[00:09:19.520 --> 00:09:28.080]   they don't really need a huge amount of hand-holding and helping them get involved because they can see not just the final result,
[00:09:28.080 --> 00:09:34.960]   but the process to get there and the thinking and the choices that were made along the way, because they're all part of the notebooks.
[00:09:34.960 --> 00:09:42.720]   And they can even see the tests and see how the tests are related, and it's all there in one place.
[00:09:42.720 --> 00:09:47.760]   So overall, notebooks give us a live coding environment.
[00:09:47.760 --> 00:09:53.760]   It's live in the sense that you're working directly programming against those live objects.
[00:09:53.760 --> 00:10:05.280]   The actual system that you're building them in has the state, has the actual current state of all of the variables and all of the systems in memory,
[00:10:05.280 --> 00:10:08.000]   and you can directly interact with it.
[00:10:08.000 --> 00:10:10.400]   This idea goes back a really long way.
[00:10:10.400 --> 00:10:17.120]   One of the most famous examples of a live coding environment is Smalltalk, this one here from Smalltalk80.
[00:10:17.120 --> 00:10:22.480]   And as you can see here, as the code is running, things are actually happening on the screen.
[00:10:22.480 --> 00:10:31.920]   And anybody involved in Smalltalk in those early days will tell you that this was a critical part of why this was such a productive system and why it was such a loved system.
[00:10:31.920 --> 00:10:36.160]   And a lot of people say there's never really been anything like Smalltalk again.
[00:10:36.160 --> 00:10:42.000]   We're kind of almost rediscovering things from decades ago.
[00:10:42.000 --> 00:10:45.840]   There are other interesting examples of live coding.
[00:10:45.840 --> 00:10:51.200]   Here's a great one from somebody called Sam Aaron, who actually does live coding as performance.
[00:10:51.200 --> 00:10:56.320]   Here is him writing music with code in real time.
[00:10:56.320 --> 00:11:14.480]   So I think that's pretty cool.
[00:11:14.480 --> 00:11:16.720]   Here's something which is even cooler.
[00:11:16.720 --> 00:11:30.000]   This is Brett Victor, a brilliant designer and a brilliant thinker, showing a real live coding environment he created, which allows him to create games in a whole new way.
[00:11:30.000 --> 00:11:32.160]   I mean, not just games, you could use this for so many things.
[00:11:32.160 --> 00:11:36.240]   But here's an amazing example, using it to build a computer game.
[00:11:36.240 --> 00:11:44.720]   So I bounce off my turtle, pause the game, and now hit this button here, which shows my guy's trail.
[00:11:44.720 --> 00:11:47.120]   So now I can see where he's been.
[00:11:47.120 --> 00:11:53.520]   And when I rewind, this trail in front of him is where he's going to be.
[00:11:53.520 --> 00:11:55.680]   This is his future.
[00:11:55.680 --> 00:12:01.600]   And when I change the code, I change his future.
[00:12:01.600 --> 00:12:04.000]   So I can find exactly the value I need.
[00:12:04.000 --> 00:12:11.120]   So when I hit play, he slips right in there.
[00:12:11.120 --> 00:12:18.960]   So I've got to say I've never managed to build code in a way where the people watching it went whoa and then started clapping.
[00:12:18.960 --> 00:12:20.880]   It's certainly something to aspire to.
[00:12:20.880 --> 00:12:27.840]   And you can see how much people really love this idea of actually interacting with a live coding environment.
[00:12:27.840 --> 00:12:29.600]   Brett Victor has been very inspirational.
[00:12:29.600 --> 00:12:36.080]   One of the things he inspired was Chris Latner, who is the guy who created LVM.
[00:12:36.080 --> 00:12:47.600]   He created Swift, and he built the amazing playground system, which as you can see here, as the code is running, you can actually see what it's doing and you can even plot it and so forth.
[00:12:47.600 --> 00:12:54.720]   Another great example of a popular and important and powerful live coding system.
[00:12:54.720 --> 00:13:02.880]   So I was so proud when actually Chris himself said he thinks that NBDev is a huge step forward for programming environments.
[00:13:02.880 --> 00:13:14.240]   And so for that to come through Chris was a huge validation for us that somebody we really admire thinks that we're absolutely going in the right direction.
[00:13:14.240 --> 00:13:28.960]   Most people, however, are not using this kind of live coding environment despite the decades of work that's kind of gone into these kinds of systems and the productivity that we found comes from it.
[00:13:28.960 --> 00:13:37.120]   Here's how a lot of people code, and I'm going to give an example here, you'll see why in a moment, of a very successful coder named Joel Groves.
[00:13:37.120 --> 00:13:44.000]   This is Joel here, and he's good enough to actually do coding, which he puts out on the internet for people to watch.
[00:13:44.000 --> 00:13:46.880]   And I watched it to see exactly what this looks like.
[00:13:46.880 --> 00:13:51.840]   And what he does, like a lot of people do, is he has what's called a line-oriented REPL down here.
[00:13:51.840 --> 00:13:54.880]   This is something where you can type in a line and it returns a line.
[00:13:54.880 --> 00:13:58.000]   And then the rest of it is a kind of a standard editor IDE.
[00:13:58.000 --> 00:14:03.680]   This is VS code, which is one of the best or maybe the best editor around.
[00:14:03.680 --> 00:14:05.840]   So watch what happens as he codes.
[00:14:05.840 --> 00:14:11.040]   You can see here that he has to kind of go back up to find something he's done before.
[00:14:11.040 --> 00:14:12.000]   It's the wrong thing.
[00:14:12.000 --> 00:14:13.200]   And then he has to edit it.
[00:14:13.200 --> 00:14:14.800]   And then he's got an assertion error.
[00:14:14.800 --> 00:14:18.080]   Now he has to go somewhere else and then comes down here again.
[00:14:18.080 --> 00:14:26.960]   Now he's getting this kind of weird situation of some state that's come from the code and some state that's come from the things he's typing.
[00:14:26.960 --> 00:14:29.680]   And now he's going back up here and trying to edit this.
[00:14:29.680 --> 00:14:32.880]   And now bringing it back down here again, and he's took it in the error.
[00:14:32.880 --> 00:14:35.840]   You know, as I watch this, I find this painful.
[00:14:35.840 --> 00:14:38.480]   You know, I don't want to write code like this.
[00:14:38.480 --> 00:14:44.720]   I kind of feel like this picture is Joel saying, ah, this is too much.
[00:14:44.720 --> 00:14:50.880]   But I feel like a lot of real programmers tell me, you know, this is how you should code.
[00:14:50.880 --> 00:14:56.560]   And it kind of feels like they're saying, hey, you know, we should go back and use line-oriented REPLs or everything.
[00:14:56.560 --> 00:14:57.600]   Like editing.
[00:14:57.600 --> 00:15:03.360]   We used to edit with add the Unix editor, which was a line-oriented editor.
[00:15:03.360 --> 00:15:13.120]   And as you can see, the basic approach is exactly the same as what Joel was using for manipulating Python.
[00:15:13.120 --> 00:15:19.920]   Now these line-oriented REPLs, you know, it's not a great way to edit text.
[00:15:19.920 --> 00:15:22.480]   Very few of us use it nowadays.
[00:15:22.480 --> 00:15:28.320]   And I would argue that it's not a good way to work with any kind of code objects.
[00:15:28.320 --> 00:15:29.600]   It is linear.
[00:15:29.600 --> 00:15:33.600]   There's a reason that we have line-oriented REPLs.
[00:15:33.600 --> 00:15:36.560]   And that's because we're used to code like this.
[00:15:36.560 --> 00:15:45.360]   If we enter maximum slash y, we get the maximum element in the vector y.
[00:15:45.360 --> 00:15:49.680]   So you can see here, he is typing one line at a time and it's printing one line at a time.
[00:15:49.680 --> 00:15:52.720]   By the way, this is APL, which is decades ahead of his time.
[00:15:52.720 --> 00:15:56.160]   It's still one of the most brilliant programming languages in the world.
[00:15:56.160 --> 00:16:04.080]   But I would argue that we should be moving beyond the type-align and have-align-printed approach
[00:16:04.080 --> 00:16:09.840]   that was developed for this kind of coding.
[00:16:09.840 --> 00:16:17.440]   So these kind of editing environments, like VS Code, VS Code is a brilliant piece of software.
[00:16:17.440 --> 00:16:23.040]   But I refer to it as a dead coding environment because you're not interacting with live code.
[00:16:23.040 --> 00:16:24.400]   And that leads to errors.
[00:16:24.400 --> 00:16:33.280]   You get this kind of gap between the system you're working on and the final result you're creating.
[00:16:33.280 --> 00:16:42.160]   So Joel actually wrote a fantastic book, which, despite being fantastic, it has some errors in it.
[00:16:42.160 --> 00:16:43.760]   And the kind of errors are very interesting.
[00:16:43.760 --> 00:16:46.400]   This is from his errata page.
[00:16:46.400 --> 00:16:50.560]   The errors that say the code, you can't actually run it.
[00:16:50.560 --> 00:16:52.960]   So this line of code doesn't work.
[00:16:52.960 --> 00:16:54.800]   And this line of code doesn't work.
[00:16:54.800 --> 00:16:58.800]   One of the really interesting ones was not only this line of code doesn't work,
[00:16:58.800 --> 00:17:02.160]   but hey, you've got a code repo where it does work.
[00:17:02.160 --> 00:17:07.760]   And so there's this kind of like gap between the actual code you're doing and the book that you're
[00:17:07.760 --> 00:17:12.800]   writing and then they become out of sync and your readers end up confused because the code doesn't run.
[00:17:12.800 --> 00:17:19.120]   All the code in our book runs not because we're particularly brilliant,
[00:17:19.120 --> 00:17:22.720]   but just because we ran it all in a notebook.
[00:17:22.720 --> 00:17:26.880]   And so all the outputs you see are the actual outputs that came out of the notebook.
[00:17:26.880 --> 00:17:31.440]   Now, of course, one of the libraries might change or there might be a breaking change to Python or
[00:17:31.440 --> 00:17:34.960]   something. There could be something which could cause it at some point in the future to break.
[00:17:34.960 --> 00:17:40.880]   But at the point that we wrote it, and as far as I know right now still, the code is correct.
[00:17:40.880 --> 00:17:45.120]   And it works because, as I said, it's the code that we actually ran.
[00:17:45.120 --> 00:17:47.520]   There is no it's not a dead coding environment.
[00:17:47.520 --> 00:17:50.320]   It was a live coding environment we used to create the book.
[00:17:50.320 --> 00:17:54.560]   And the book directly comes from and is that code.
[00:17:54.560 --> 00:17:59.360]   So why am I talking about Joel's book and Joel's coding approach?
[00:17:59.360 --> 00:18:07.280]   That's because actually he a couple of years ago did a brilliant presentation called I don't like notebooks.
[00:18:07.280 --> 00:18:13.600]   And in this presentation, he explained why he thought we shouldn't be using notebooks.
[00:18:13.600 --> 00:18:19.760]   And actually notebooks are not the right approach to building effective software or doing effective teaching.
[00:18:19.760 --> 00:18:27.920]   And the reason I feel like I need to talk about it today is because he is such a brilliant communicator
[00:18:27.920 --> 00:18:34.560]   and such a funny guy that this presentation has been incredibly influential.
[00:18:34.560 --> 00:18:41.680]   And pretty much any time I say I like notebooks, somebody will say that's not a good idea.
[00:18:41.680 --> 00:18:46.000]   Haven't you seen that presentation where that guy explained why they're terrible?
[00:18:46.000 --> 00:18:52.640]   So I really feel like in order to tell you why I like notebooks, I also have to tell you why Joel is wrong.
[00:18:52.640 --> 00:18:57.280]   Which he is. I really feel like he's wrong. I've built a lot of good stuff in notebooks.
[00:18:57.280 --> 00:19:04.480]   And as you'll see, I think the points he made are based on misunderstandings or at least to sometimes that now out of deck.
[00:19:04.480 --> 00:19:10.800]   Because his slides are brilliant, I'm going to use a lot of them and also so you can see exactly what I'm responding to.
[00:19:10.800 --> 00:19:16.720]   Whenever I use his slides, I'm going to show this little icon in the bottom right hand corner.
[00:19:16.720 --> 00:19:22.480]   You'll see it. The next 12 slides are actually all from his presentation.
[00:19:22.480 --> 00:19:27.040]   I haven't edited them because I want to make sure you see exactly what he showed.
[00:19:27.040 --> 00:19:32.480]   And one of the things he did say in his presentation is I am not a notebook expert.
[00:19:32.480 --> 00:19:38.800]   Which is great. It's nice to be self-deprecating and to kind of have that caveat.
[00:19:38.800 --> 00:19:45.440]   But he still expressed very strong opinions and people still, as I said, really think he must be right.
[00:19:45.440 --> 00:19:51.520]   They tell me that I am making a mistake to think that I like notebooks.
[00:19:51.520 --> 00:19:59.280]   So I was actually worried when he first told me that he's planning to write the talk that he did.
[00:19:59.280 --> 00:20:07.040]   Because I know he's a brilliant communicator and I know he's really funny and I thought, uh oh, a lot of people are going to listen to this and say,
[00:20:07.040 --> 00:20:12.080]   oh, I guess we shouldn't use notebooks because Joel has made a compelling case that we shouldn't.
[00:20:12.080 --> 00:20:19.760]   And this slide is actually from his presentation. He actually said in his presentation, hey, look at what Jeremy said.
[00:20:19.760 --> 00:20:25.360]   I guess he thought it was kind of funny that I told him don't write this presentation and he wrote the presentation.
[00:20:25.360 --> 00:20:31.280]   And so now I feel like I have to come back and say, OK, let's set the records track here.
[00:20:31.280 --> 00:20:38.400]   So here's what he said. He said he had a lot of strong opinions. I don't agree with any of them, but here they are.
[00:20:38.400 --> 00:20:47.040]   He said notebooks discourage good habits. He said notebooks encourage bad habits.
[00:20:47.040 --> 00:20:51.760]   He said notebooks encourage bad processes.
[00:20:51.760 --> 00:20:59.840]   He said that notebooks hinder reproducible and extensible science.
[00:20:59.840 --> 00:21:06.240]   He said that notebooks are a recipe for poorly factored code.
[00:21:06.240 --> 00:21:12.480]   He said that notebooks make it easy to teach poorly. I don't think it's a notebooks fault that that guy's going to get over the head.
[00:21:12.480 --> 00:21:15.920]   I don't do that when I teach with notebooks, by the way.
[00:21:15.920 --> 00:21:20.240]   He said notebooks make it hard for me to teach well.
[00:21:20.240 --> 00:21:24.000]   So he didn't just state these. He gave reasons.
[00:21:24.000 --> 00:21:28.240]   And here are some of the key reasons, I think the key reasons that he expressed.
[00:21:28.240 --> 00:21:34.320]   The first one he expressed was that notebooks have tons and tons of head and state.
[00:21:34.320 --> 00:21:39.840]   That's easy to screw up and difficult to reason about.
[00:21:39.840 --> 00:21:47.760]   Which is strange. I don't find this myself. And he made the point that notebooks or he says are dangerous.
[00:21:47.760 --> 00:21:53.920]   I don't know if I agree they are dangerous, but he thinks notebooks are dangerous unless you run each cell exactly once in order.
[00:21:53.920 --> 00:22:02.400]   I was like, oh my goodness, how am I going to do that? Wait, Jupiter has a single button you can press to do that.
[00:22:02.400 --> 00:22:11.280]   It's actually not that hard. If you really think it's so important to run each cell in order, you'd have a way to do so.
[00:22:11.280 --> 00:22:21.120]   Personally, I think it's actually really, really important to have this ability to go back and fiddle with things, to change things, to see what happens.
[00:22:21.120 --> 00:22:27.120]   I like having the ability to go back and run in order, but I also like having the ability to actually, as we discussed,
[00:22:27.120 --> 00:22:34.480]   manipulate the live coding environment in real time to experiment and to say what if.
[00:22:34.480 --> 00:22:40.560]   That's a critical part of this. But you do need a way to ensure that in the end the whole thing works.
[00:22:40.560 --> 00:22:45.840]   And not only does Jupiter have a couple of ways to do that, there's restart and clear output.
[00:22:45.840 --> 00:22:49.680]   So actually restart and clear output, restart and run all, made a mistake there.
[00:22:49.680 --> 00:22:57.200]   And in cell there's also a few options such as run cells to here or run all cells.
[00:22:57.200 --> 00:23:04.800]   And NBDev actually has something which runs all of your notebooks, all of your cells in order for you for a whole directory.
[00:23:04.800 --> 00:23:07.920]   That's the main thing I use.
[00:23:07.920 --> 00:23:20.080]   Another concern he stated was that you can't copy and paste code and outputs from a notebook into Slack or he also gave the example of that pull requests and issues in GitHub.
[00:23:20.080 --> 00:23:29.760]   Now this is an example of trying to do things the same way you've always done them without thinking about what's the actual problem you're trying to solve.
[00:23:29.760 --> 00:23:35.600]   Now the actual problem you try to solve is to say here's what I'm trying to do, please explain why this doesn't work.
[00:23:35.600 --> 00:23:40.080]   Or here have a look at this example I'm showing, or whatever.
[00:23:40.080 --> 00:23:47.440]   And here's how it actually looks, it's actually way better than cutting and pasting into Slack.
[00:23:47.440 --> 00:23:54.880]   When we get a pull request or an issue, here's a bug report, colab notebook reproducing the behavior.
[00:23:54.880 --> 00:24:05.120]   Now I click on that and I get a whole notebook fully self-contained where I'm not just seeing this person's claim or I type this and this happened.
[00:24:05.120 --> 00:24:13.120]   But I can actually try it and that means I can then actually try to fix it right there and then.
[00:24:13.120 --> 00:24:24.320]   And this is particularly helpful because all of the fast AI documentation, all of the fast AI book and all of the fast AI courses are also available as notebooks.
[00:24:24.320 --> 00:24:38.800]   So people can use that as a starting point or I can say like, oh, did you try the code in the book? If you have a non-working example, could you modify the notebook to show us how yours doesn't work?
[00:24:38.800 --> 00:24:40.320]   And so forth.
[00:24:40.320 --> 00:24:54.240]   So rather than saying how do I copy and paste into Slack or GitHub, the question should be how do I understand the problem that a user is having or understand the idea that a user is telling me about?
[00:24:54.240 --> 00:25:04.400]   And the answer to me is by providing an actual live coding environment, I can see that and it's so easy to do with Jupyter.
[00:25:04.400 --> 00:25:15.760]   Something else I really like about Jupyter is you can use something like what I really enjoy at ReviewMD to look at pull requests and pull requests don't just show me the code that's changed, which is fine.
[00:25:15.760 --> 00:25:16.640]   They do. It's very nice.
[00:25:16.640 --> 00:25:22.320]   But they also show me the outputs that have changed and the documentation is right next to it.
[00:25:22.320 --> 00:25:25.840]   So here's somebody changed to test, right?
[00:25:25.840 --> 00:25:38.240]   And rather than thinking, oh, I wonder if those scales are any good and then having to go back and load in their PR and run it and then have a second version of the code and run that and compare the two in ReviewMB.
[00:25:38.240 --> 00:25:45.600]   I can see them right next to each other and I can say, oh, yeah, this actually does look like a more clear example to me.
[00:25:45.600 --> 00:25:52.080]   And I can see the documentation is right next to it and I can see exactly what's going on.
[00:25:52.080 --> 00:25:54.720]   There's lots of ways of sharing notebooks.
[00:25:54.720 --> 00:25:57.360]   Another is to press this button.
[00:25:57.360 --> 00:25:59.120]   This is the just button.
[00:25:59.120 --> 00:26:03.680]   Here's a notebook that I created and you can copy and paste images directly into a notebook.
[00:26:03.680 --> 00:26:06.320]   So here's one I just copied and pasted in.
[00:26:06.320 --> 00:26:13.760]   And if I click that button, then it automatically gives me a shareable just URL so I can paste that into Slack.
[00:26:13.760 --> 00:26:23.520]   That's at least as easy as copying and pasting from IPython. And of course, I get the benefit that I'm copying and pasting not just text but pictures.
[00:26:23.520 --> 00:26:28.400]   And, you know, a lot of us are working with things other than just text nowadays.
[00:26:28.400 --> 00:26:32.160]   We want to be able to show plots, you know, histograms of things and analytics.
[00:26:32.160 --> 00:26:33.440]   We want to be able to show pictures.
[00:26:33.440 --> 00:26:34.920]   We're going to be able to show videos.
[00:26:34.920 --> 00:26:38.680]   We're not just working with text all the time.
[00:26:38.680 --> 00:26:43.800]   And so with something like this, you can really show a much more complete example a lot of the time.
[00:26:43.800 --> 00:26:49.360]   It's really nice and easy to do.
[00:26:49.360 --> 00:26:53.080]   Another concern, as you can see, we've still got our little pictures down here.
[00:26:53.080 --> 00:26:56.760]   There's still Joel's code, sorry, Joel's slides.
[00:26:56.760 --> 00:27:06.080]   Another concern he had was that he thinks that notebooks are harder to reproduce.
[00:27:06.080 --> 00:27:09.800]   And this one, he didn't really explain why he thought that way.
[00:27:09.800 --> 00:27:13.760]   And I don't fully understand the thought process here.
[00:27:13.760 --> 00:27:25.160]   All of the same ways that you can use for dependencies in regular Python libraries like requirements text or environment YAML or whatever set up the pipe.
[00:27:25.160 --> 00:27:29.640]   You can use exactly the same thing for notebooks.
[00:27:29.640 --> 00:27:35.360]   But in practice, though, you know, notebooks, I really love because when you provide a notebook,
[00:27:35.360 --> 00:27:39.880]   you can just provide a cell at the top which creates the environment you need.
[00:27:39.880 --> 00:27:46.160]   So, for example, you can open any chapter of the fast AI deep learning,
[00:27:46.160 --> 00:27:52.120]   practical deep learning for coder's book directly on Colab by clicking on a link without any installation.
[00:27:52.120 --> 00:27:58.400]   And the first line of the first cell installs everything you need and away you go.
[00:27:58.400 --> 00:28:06.280]   So really, to me, I feel like notebooks make it much easier to ensure that you have something that's reproducible.
[00:28:06.280 --> 00:28:15.480]   And you can also see what the programmer did step by step to really make sure that what you're seeing is what they were seeing.
[00:28:15.480 --> 00:28:17.480]   Look, you can certainly make bad notebooks.
[00:28:17.480 --> 00:28:20.440]   You can certainly provide bad reproducibility environments.
[00:28:20.440 --> 00:28:23.160]   But I don't think it's anything to do with notebooks themselves.
[00:28:23.160 --> 00:28:32.360]   You know, it's to me, this is an environment that actually makes that easier to do well.
[00:28:32.360 --> 00:28:39.400]   So the other thing that Joe talked about quite a lot was this idea of good software engineering.
[00:28:39.400 --> 00:28:49.560]   And he made some pretty bold plans that good software engineering can't be done or is extremely hard to do in notebooks.
[00:28:49.560 --> 00:28:54.280]   And he used these characters quite a lot, these Smurfs.
[00:28:54.280 --> 00:29:01.640]   And basically, you know, he's saying, like, you should all follow the rules of good software engineering.
[00:29:01.640 --> 00:29:08.280]   But, you know, it's kind of like this idea that you should copy and paste code and outputs into Slack.
[00:29:08.280 --> 00:29:12.160]   You know, that's how people might have done things before.
[00:29:12.160 --> 00:29:23.360]   But, you know, maybe the rules of software engineering in a dead coding environment or in a line oriented repo or whatever are not the same,
[00:29:23.360 --> 00:29:30.120]   particularly, you know, compared to a dynamic language in a live coding environment.
[00:29:30.120 --> 00:29:38.720]   And also the rules for a data scientist who's doing research and their focus is on speed of iteration
[00:29:38.720 --> 00:29:49.360]   and on rapidly eyeballing visualizations to see whether their, say, their microscopy images are actually getting easier to see or harder to see.
[00:29:49.360 --> 00:29:53.480]   To take an example of a project I've been involved in a lot recently.
[00:29:53.480 --> 00:30:08.600]   These are kind of going to be different to the rules, the so-called rules of somebody who's creating a CRUD app or an e-commerce app to send a payment to a Stripe API.
[00:30:08.600 --> 00:30:19.720]   So I think we've got to be careful about the idea of rules and think about domains and domain expertise and environments.
[00:30:19.720 --> 00:30:21.440]   So here's another slide from Joel.
[00:30:21.440 --> 00:30:26.240]   And his concern was that notebooks are not good for modularity.
[00:30:26.240 --> 00:30:34.000]   And he's giving an example here of some of his code, which he's saying is very nicely modular.
[00:30:34.000 --> 00:30:39.760]   I mean, sure, but why can't you do the exact same thing in notebooks?
[00:30:39.760 --> 00:30:46.080]   And in fact, FastAI, the library I told you about that we wrote entirely in notebooks.
[00:30:46.080 --> 00:30:58.960]   Actually, the modularity is so good that we have a peer reviewed paper about the approach to modularity that we took and about how the kind of decoupled API that we created.
[00:30:58.960 --> 00:31:06.400]   I'm sure it's not perfect, but a lot of people have used it and have liked it and people are studying it as an example of modularity.
[00:31:06.400 --> 00:31:14.520]   It's definitely not the case that notebooks somehow make it impossible or even difficult to create modular code.
[00:31:14.520 --> 00:31:17.320]   I'd say the same thing about testability.
[00:31:17.320 --> 00:31:19.320]   I don't know if this is from Joel's tests.
[00:31:19.320 --> 00:31:20.840]   I guess it probably is.
[00:31:20.840 --> 00:31:22.800]   Again, this is one of his slides.
[00:31:22.800 --> 00:31:24.800]   He's showing here examples of tests.
[00:31:24.800 --> 00:31:37.760]   Tests are great, but in this kind of regular approach to coding and these dead coding environments, the tests live separately to the code that's being tested.
[00:31:37.760 --> 00:31:47.080]   And it's very easy for somebody to look at the code and not even notice the tests or they have to kind of flick back and forth between the two.
[00:31:47.080 --> 00:31:54.760]   And it's not easy to connect which test is really working on which part of the code.
[00:31:54.760 --> 00:32:04.720]   Whereas in notebooks and also with NBDev in particular, the tests live right next to the thing they're testing.
[00:32:04.720 --> 00:32:08.840]   And they'll include pros explaining what it is they're testing.
[00:32:08.840 --> 00:32:14.320]   So here we've created a thing called an unbuffered server.
[00:32:14.320 --> 00:32:17.000]   I think it was in the cell above the one I took a screenshot of here.
[00:32:17.000 --> 00:32:21.840]   And so here I've created a test handler to test it that sends a response and writes OK.
[00:32:21.840 --> 00:32:30.640]   And here's something that checks whether that starts a server and then checks whether it actually receives that OK or not.
[00:32:30.640 --> 00:32:41.800]   So it's really nice having the test in the notebook and then NBDev provides a way to run all the tests across lots of notebooks and report on the overall result.
[00:32:41.800 --> 00:32:47.200]   And that can be run in continuous integration and NBDev gives you that actually out of the box.
[00:32:47.200 --> 00:32:54.400]   If you use the NBDev template, you get this kind of continuous integration testing for free.
[00:32:54.400 --> 00:33:00.360]   You don't have anything to do. It just works, which I think is super cool.
[00:33:00.360 --> 00:33:13.840]   Another of Joel's concerns from his slides is that notebooks somehow encourage a less sophisticated approach to learning.
[00:33:13.840 --> 00:33:20.600]   So hit shift enter to execute a cell and go to the next one. Maybe people just do that without thinking.
[00:33:20.600 --> 00:33:24.160]   I mean, it's possible people could could do that.
[00:33:24.160 --> 00:33:30.520]   I would say even that is better than people just reading the text and having nothing to do.
[00:33:30.520 --> 00:33:40.400]   But as I described, actually, what we do is we have a little script that just removes all of the pros except for headings and all of the outputs.
[00:33:40.400 --> 00:33:44.240]   And then we give this to the student and then they can run through each one.
[00:33:44.240 --> 00:33:50.520]   And before they run it, we say, have a think about what this is going to output and think about why and think about why we're doing it.
[00:33:50.520 --> 00:33:58.320]   And then if you guessed wrong or figured wrong, you can actually experiment because you're in a live coding environment here.
[00:33:58.320 --> 00:34:02.280]   So you can actually see, well, where did that go wrong and what actually happens?
[00:34:02.280 --> 00:34:05.200]   So I actually think this is a great way of learning.
[00:34:05.200 --> 00:34:08.280]   And a lot of our students have told us they think it's a great way of learning.
[00:34:08.280 --> 00:34:20.600]   I don't think I've ever heard anybody say that this ability to work interactively in this environment is decreasing their ability to learn.
[00:34:20.600 --> 00:34:31.600]   So another thing that Joel said and gave a few examples is that notebooks are way less helpful than my text editor, which in his case, we saw as VS code.
[00:34:31.600 --> 00:34:33.480]   So he said some things are easier demonstrated.
[00:34:33.480 --> 00:34:42.000]   I'm going to show the opposite of his demonstrations, which is actually that Jupiter is more correct and more helpful than his idea.
[00:34:42.000 --> 00:34:44.360]   So here's an example.
[00:34:44.360 --> 00:34:57.600]   Let's get a URL contents of a URL and if it returns something valid, it's like something truthy, then we'll return a otherwise we'll return one.
[00:34:57.600 --> 00:35:00.520]   So this is obviously going to return something truthy.
[00:35:00.520 --> 00:35:07.960]   So this should be a string. And as you can see, it's giving me I.D. completion for a string.
[00:35:07.960 --> 00:35:17.000]   This code same code GISB completion for a number, not for a string, a bit length case fold conjugate.
[00:35:17.000 --> 00:35:23.240]   OK, so this code doesn't know because this code is it's doing the best it can.
[00:35:23.240 --> 00:35:27.680]   And it's kind of pretty brilliant, you know, given that limitation.
[00:35:27.680 --> 00:35:30.840]   But it doesn't know Jupiter knows because you ran the code.
[00:35:30.840 --> 00:35:41.320]   So it actually knows what you're working with and it can actually because Python's a dynamic language, it supports this kind of dynamic introspection of what is actually inside B and what can be do.
[00:35:41.320 --> 00:35:43.720]   And so that's what Jupiter can use.
[00:35:43.720 --> 00:35:49.200]   So Jupiter is just really, really, really helpful because it can be really helpful.
[00:35:49.200 --> 00:36:05.880]   This code does the best it can, but it can never be totally correct. It would literally be impossible without it actually trying to match the same stateful approach as Jupiter because Python is dynamic, because it's not fully typed.
[00:36:05.880 --> 00:36:11.480]   And even if you do use types for something like B above, you'd have to use a union type.
[00:36:11.480 --> 00:36:15.600]   You still wouldn't actually know what the type is.
[00:36:15.600 --> 00:36:21.440]   So then Joel said, OK, here's what you could do to win me over and convert me to a notebook user.
[00:36:21.440 --> 00:36:24.720]   He said, give me ID style autocomplete.
[00:36:24.720 --> 00:36:29.360]   But as we discussed, ID style autocomplete is not the be all and end all.
[00:36:29.360 --> 00:36:31.560]   It's actually not fully correct.
[00:36:31.560 --> 00:36:35.320]   Having said that, Jupiter also provides ID style autocomplete.
[00:36:35.320 --> 00:36:41.920]   If you give it types, then it will figure out what you mean.
[00:36:41.920 --> 00:36:46.920]   And if you give it functions like open that return a file, again, it will figure out what you need.
[00:36:46.920 --> 00:36:50.400]   So we have ID style autocomplete.
[00:36:50.400 --> 00:36:55.280]   He said, give me real time type checking and linting linting.
[00:36:55.280 --> 00:36:58.920]   OK, here is part of a fast core library.
[00:36:58.920 --> 00:37:07.280]   As you can see, it's like a dozen lines of code and it actually gives you real time, actually correct type checking.
[00:37:07.280 --> 00:37:13.560]   So here you can see I'm calling foo, which is taking an int and a string.
[00:37:13.560 --> 00:37:16.320]   And if you pass it into an int, it's checking.
[00:37:16.320 --> 00:37:18.280]   It does in fact fail.
[00:37:18.280 --> 00:37:28.400]   And again, it can do this correctly only because it's in Jupiter, only because it's actually running the code.
[00:37:28.400 --> 00:37:34.520]   The approaches that most people are taking to this kind of type checking is mypy.
[00:37:34.520 --> 00:37:40.200]   And mypy is not about 12 lines of code.
[00:37:40.200 --> 00:37:44.240]   Mypy is about 100,000 lines of code.
[00:37:44.240 --> 00:37:47.440]   And it's complex code involving multiple different languages.
[00:37:47.440 --> 00:37:49.960]   And it's never going to be correct.
[00:37:49.960 --> 00:38:00.920]   It can't be fully correct because it's impossible for it to know exactly the types of all of your pieces of data because it's not actually running the code.
[00:38:00.920 --> 00:38:07.760]   And Python is dynamic with Python. The only way to know what something actually contains is to run the code.
[00:38:07.760 --> 00:38:12.560]   Also, mypy means that you have to tell Python what every type is.
[00:38:12.560 --> 00:38:22.840]   And honestly, every other language is moving towards auto detection of types of figuring out what types are automatically.
[00:38:22.840 --> 00:38:25.840]   Particularly early movers like F sharp.
[00:38:25.840 --> 00:38:34.480]   But nowadays, even stuff like Java, C sharp, C++, you can have like an auto type and it fixes out for you.
[00:38:34.480 --> 00:38:36.440]   Python is kind of moving in the opposite direction.
[00:38:36.440 --> 00:38:45.920]   And if you want to go the mypy static analysis, IDE approach, you're going to have to spend a lot of time doing manual typing.
[00:38:45.920 --> 00:38:54.200]   Another thing Joel said he wanted to see to win him over is a better story around dependency management.
[00:38:54.200 --> 00:39:05.640]   Sure. Why not? As I said, notebooks can already support all the same approaches that that normal Python projects can handle.
[00:39:05.640 --> 00:39:11.440]   And the dev makes it even easier. You can just add a line to your settings on any with a list of requirements.
[00:39:11.440 --> 00:39:16.600]   If there is some special one for Pip and Conda, you can add those special ones for development time only.
[00:39:16.600 --> 00:39:19.040]   You can add those and away you go.
[00:39:19.040 --> 00:39:24.040]   That will automatically make all of those things being stored for you when you run the notebooks.
[00:39:24.040 --> 00:39:27.000]   So we certainly have that.
[00:39:27.000 --> 00:39:31.240]   He also said he's looking for first class. What is going on there?
[00:39:31.240 --> 00:39:36.320]   First class support for refactoring code out of notebooks into modules.
[00:39:36.320 --> 00:39:39.320]   And I agree. This is absolutely critical.
[00:39:39.320 --> 00:39:45.680]   And this is really the key number one first thing that NBDev does.
[00:39:45.680 --> 00:39:47.760]   You start with some code like this.
[00:39:47.760 --> 00:39:52.720]   And again, this is some source code of NBDev. NBDev, of course, is written in NBDev.
[00:39:52.720 --> 00:40:02.920]   It's a notebook. And then it automatically creates an actual Python project.
[00:40:02.920 --> 00:40:04.960]   So those all exist.
[00:40:04.960 --> 00:40:06.800]   Joel did not expect that to happen.
[00:40:06.800 --> 00:40:09.880]   He said, the reality is you're not going to provide me with all these things.
[00:40:09.880 --> 00:40:14.920]   And I'm not going to switch to notebooks. So so be it.
[00:40:14.920 --> 00:40:22.680]   So hopefully I've convinced you that there's no reason for you not to like notebooks and that it's not the case.
[00:40:22.680 --> 00:40:26.800]   They're real software developers have to use other tools.
[00:40:26.800 --> 00:40:31.560]   But actually, notebooks really can be really great.
[00:40:31.560 --> 00:40:34.800]   Let me explain more about how and why this happens.
[00:40:34.800 --> 00:40:39.280]   And to do that, I'm going to focus on in particular NBDev.
[00:40:39.280 --> 00:40:43.680]   And I've already mentioned the basic things that NBDev does for you.
[00:40:43.680 --> 00:40:49.240]   Let's look more at how that works and exactly what you need to do.
[00:40:49.240 --> 00:40:55.840]   So here is an example of code in a notebook.
[00:40:55.840 --> 00:41:00.680]   And you can see here that I've got an export comment.
[00:41:00.680 --> 00:41:05.920]   So NBDev uses a small number like two or three different special comments to tell it what to do.
[00:41:05.920 --> 00:41:10.120]   And this export says, make this part of my Python project.
[00:41:10.120 --> 00:41:14.320]   This doesn't have an export. So it's not part of the Python project.
[00:41:14.320 --> 00:41:19.200]   Now, one of the things I like to do, this is another thing that Joel talked about as being a problem for him.
[00:41:19.200 --> 00:41:27.120]   With notebooks, he said it's hard to do is splitting a class into separate cells.
[00:41:27.120 --> 00:41:34.080]   And actually, with the FAST AI libraries using NBDev and FAST 4, it's not at all difficult to do.
[00:41:34.080 --> 00:41:38.600]   Here's a class and I've just got the init in it here and I can create it.
[00:41:38.600 --> 00:41:45.040]   And then later on, I just use this patch decorator to add this method to this class.
[00:41:45.040 --> 00:41:47.640]   And so this is actually going to impact the documentation as well.
[00:41:47.640 --> 00:41:50.560]   The documentation of process comment will end up down here.
[00:41:50.560 --> 00:41:55.240]   And the documentation of class init, notebook processor init, it's going to end up up here.
[00:41:55.240 --> 00:41:59.800]   And so it really helps the code reader understand things step by step.
[00:41:59.800 --> 00:42:05.040]   Each one has test examples kind of as it happens.
[00:42:05.040 --> 00:42:09.120]   And as you read through the documentation, you can see each piece one at a time.
[00:42:09.120 --> 00:42:15.000]   This is a really nice to me way to build up more complex classes.
[00:42:15.000 --> 00:42:24.520]   All of the pieces of NBDev all get built out of a single simple little settings file, settings.me.
[00:42:24.520 --> 00:42:28.960]   And it's really nice because you can provide all of the information just in one place.
[00:42:28.960 --> 00:42:35.400]   So rather than having a version number over here and init.py and over there and setup.py and over here in your documentation,
[00:42:35.400 --> 00:42:37.800]   you have it once and it's used everywhere.
[00:42:37.800 --> 00:42:44.720]   Ditto for your description, ditto for your source of your documentation and ditto for your repo information.
[00:42:44.720 --> 00:42:48.440]   It's just there in one place and then everything will use that for you.
[00:42:48.440 --> 00:42:53.080]   You don't have to put it in multiple places and think about how to maintain it and synchronize it.
[00:42:53.080 --> 00:43:00.720]   Talking of synchronization, not only can you start with a notebook and turn it into this code,
[00:43:00.720 --> 00:43:05.640]   which you can then open in this case, there are human VIM or you can open it in VS code or whatever.
[00:43:05.640 --> 00:43:13.600]   You can edit it in your editor like VIM or VS code and it will sync it in the opposite direction to and update your notebook.
[00:43:13.600 --> 00:43:22.840]   And so some things are easy to do in editors, particularly kind of search and replace across multiple files and stuff like that.
[00:43:22.840 --> 00:43:28.320]   Or if it's an unfamiliar code base, it's nice to use the tags to kind of jump across between files.
[00:43:28.320 --> 00:43:33.880]   You can edit as you go and then synchronize back to the notebook.
[00:43:33.880 --> 00:43:36.840]   So then how does the synchronization work?
[00:43:36.840 --> 00:43:38.600]   Well, there's two ways you can do it.
[00:43:38.600 --> 00:43:44.360]   You can either put this as the last cell in each notebook, notebook to script,
[00:43:44.360 --> 00:43:52.920]   and that will take the notebook you're working in and all the other notebooks and convert them into modules or at the command line.
[00:43:52.920 --> 00:43:55.760]   You can run nvdef building.
[00:43:55.760 --> 00:44:02.840]   And so I have this in every notebook that I use because it's kind of nice to stay in the notebook environment.
[00:44:02.840 --> 00:44:08.320]   This is more something I tend to do as part of my release process.
[00:44:08.320 --> 00:44:21.760]   There's a lot of little niceties that nvdef tries hard to make nice for you to kind of make your code as correct and as close to best practices as possible,
[00:44:21.760 --> 00:44:23.920]   at least kind of our view of best practices.
[00:44:23.920 --> 00:44:27.600]   One of the best practices that we think are important is dunderall.
[00:44:27.600 --> 00:44:36.080]   Dunderall is the thing that Python provides for you where you get to list what are the exported symbols in your module.
[00:44:36.080 --> 00:44:42.000]   If you don't provide dunderall and nearly nobody that's not an nvdef user provides it,
[00:44:42.000 --> 00:44:47.640]   then it exports all the symbols, not just the symbols which or anything without a leading underscore,
[00:44:47.640 --> 00:44:52.280]   not just the ones that you've actually directly typed in as your code,
[00:44:52.280 --> 00:45:00.320]   but everything you import also gets exported and that very quickly can lead to namespace pollution.
[00:45:00.320 --> 00:45:09.600]   But with an nvdef module, because we automatically create a dunderall for you, which includes only the things that you requested be exported,
[00:45:09.600 --> 00:45:15.000]   that means that you can see the imports, for example, from fastcore.transform, which is part of an nvdef library.
[00:45:15.000 --> 00:45:18.720]   There's just stuff from fastcore.transform.
[00:45:18.720 --> 00:45:33.240]   Or else if you look at something from alannlp.nn.util, you get copy, JSON, logging, default, etc. This is not stuff created by alannlp.nn.util.
[00:45:33.240 --> 00:45:45.000]   And so because this is built using the traditional VS code approach, it really is too much work to manually create dunderall.
[00:45:45.000 --> 00:45:52.040]   So the alannlp folks don't do it, just like pretty much every other Python library, not all of them.
[00:45:52.040 --> 00:46:04.040]   TK, for example, which comes with Python, does define dunderall, which is nice, but I don't know very many non-nvdev projects.
[00:46:04.040 --> 00:46:06.480]   So here's another nice thing with a documentation.
[00:46:06.480 --> 00:46:20.920]   In the docs, you can just put your symbols in bactics, and then when you create the docs, which again, it's automatic, and it can be part of your CI system, in fact, that is by default, you can see it actually creates hyperlinks.
[00:46:20.920 --> 00:46:32.200]   So nvdev knows how to actually look up each of these symbols and hyperlink to them, even things like this, which are part of different libraries.
[00:46:32.200 --> 00:46:43.920]   So this is a really nice feature which allows you to help out your users so that they can see exactly what you're talking about by jumping to other parts of the docs.
[00:46:43.920 --> 00:46:52.720]   And of course, some things shouldn't be hyperlinked, like these, this is a parameter name, and so those will not end up hyperlinked.
[00:46:52.720 --> 00:47:09.040]   So the documentation which gets built for you supports all the kinds of features you might imagine, a hierarchical menu to take you to any part of the documentation pages, a table of contents for each page, you can have badges, opening collab, headings, links, all that kind of stuff.
[00:47:09.040 --> 00:47:14.040]   So the documentation comes out pretty nice, I think.
[00:47:14.040 --> 00:47:33.040]   So here's what happens, you just run nvdev build docs, and it takes a second or so, it's all done in parallel, or you can have something like a GitHub action or whatever continuous integration system you use and call the fast AI workflows build docs GitHub action.
[00:47:33.040 --> 00:47:51.040]   So then, you can open those docs directly as a notebook. And one of them is special, which is the one called index.ipynb, index.ipynb will automatically be turned into a readme.md for you as well.
[00:47:51.040 --> 00:48:00.040]   So no more worrying about trying to keep your files synchronized to make sure that your homepage and your readme is saying the same thing.
[00:48:00.040 --> 00:48:03.040]   We actually do that for you automatically.
[00:48:03.040 --> 00:48:17.040]   We also, of course, make sure that it's not only the notebook, but the homepage on your documentation website, and even your PyPy and Conda descriptions will all end up showing you the same information from your index notebook.
[00:48:17.040 --> 00:48:24.040]   So in this way, because we're just saying build stuff in one place, do it once, and then we'll make sure that everything syncs up for you.
[00:48:24.040 --> 00:48:32.040]   That makes it trivially easy to create really nice user experiences for your users.
[00:48:32.040 --> 00:48:49.040]   So for me, even when I create tiny, simple little projects, I always do them in nbdev, because that way I know that I can, you know, in a minute or two, provide installable libraries and documentation just in case anybody else is interested in using my work.
[00:48:49.040 --> 00:48:56.040]   And often I find, you know, even for stuff that I think is pretty niche, there's always a few people who are interested in using it too.
[00:48:56.040 --> 00:48:58.040]   Here's an example, actually.
[00:48:58.040 --> 00:49:02.040]   Fast Webhook, which I mentioned before, it's really just written for myself.
[00:49:02.040 --> 00:49:10.040]   Fast AI, I wanted a webhook that would send out a tweet any time there was a release, but I did it.
[00:49:10.040 --> 00:49:28.040]   I wrote it in like two hours, I guess, and then I just hit make release. And because I made it from nbdev template, it automatically created the Conda package and the PyPy package for me and everything was all set up, which is really nice.
[00:49:28.040 --> 00:49:37.040]   One of the challenges with working with notebooks on version control is you can get some really ugly diffs that won't even load in notebooks.
[00:49:37.040 --> 00:49:47.040]   nbdev will actually ensure that those diffs are turned into what I would call a notebook level diff, which is to say it always ensures that your notebooks can be opened.
[00:49:47.040 --> 00:49:54.040]   If there's a difference only in cell outputs, it just ignores them and just picks one because, you know, you can just rerun it.
[00:49:54.040 --> 00:50:07.040]   If there's actually a difference between, you know, in a cell, two people have changed the same cell, then it will actually show you the diff tags in a notebook, you can open it up in Jupyter and fix it up.
[00:50:07.040 --> 00:50:17.040]   All of your tests run in parallel with nbdev test nb's using as many cores as you have.
[00:50:17.040 --> 00:50:27.040]   So this is a great way to ensure that every notebook runs from the top to the bottom and has the actual outputs that you're expecting.
[00:50:27.040 --> 00:50:34.040]   Lots of nice little pieces like math equation support, all the low tech equations work nicely.
[00:50:34.040 --> 00:50:41.040]   You use it in your markdown and it pops up in your both in your notebooks and in your documentation.
[00:50:41.040 --> 00:50:47.040]   You're using KATEC, which is a really nice fast library for that.
[00:50:47.040 --> 00:51:03.040]   And there are other things that we power as well, not just publishing libraries, but nbdev also powers fast pages, which is a increasingly popular blogging system where you can write Jupyter notebooks and it turns it into a blog.
[00:51:03.040 --> 00:51:24.040]   And this is really nice for anybody who is often trying to communicate technical content involving equations and/or code, visualizations, no more copying and pasting, just sent to medium or copying and pasting, you know, outputs, you know, plot outputs into files.
[00:51:24.040 --> 00:51:28.040]   When you can do the whole thing in a notebook, there's nothing to think about it.
[00:51:28.040 --> 00:51:31.040]   It just works, which makes life very easy.
[00:51:31.040 --> 00:51:39.040]   And as we discussed earlier, fast doc takes notebooks and turns them into publication quality books.
[00:51:39.040 --> 00:51:46.040]   So I hope that you might give it a go and see why I like Jupyter notebooks.
[00:51:46.040 --> 00:52:00.040]   You can just go to nbdev.fast.ai, which is, of course, a nbdev-powered documentation site, and you can just click a button and it will create your nbdev repo for you and you can get started.
[00:52:00.040 --> 00:52:08.040]   Thanks so much for watching, and I hope that you try this out and find that you like Jupyter notebooks too. Thanks.

