<html><head><title>Travis Oliphant: NumPy, SciPy, Anaconda, Python & Scientific Programming | Lex Fridman Podcast #224</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 80%;
        margin: auto;
        overflow: hidden;
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Travis Oliphant: NumPy, SciPy, Anaconda, Python & Scientific Programming | Lex Fridman Podcast #224</h2><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww" target="_blank"><img src="https://i.ytimg.com/vi_webp/gFEE3w7F0ww/maxresdefault.webp" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=0 target="_blank"">0:0</a> Introduction<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=71 target="_blank"">1:11</a> Early programming<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=1372 target="_blank"">22:52</a> SciPy<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=2386 target="_blank"">39:46</a> Open source<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=3089 target="_blank"">51:29</a> NumPy<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=5324 target="_blank"">88:44</a> Guido van Rossum<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=6062 target="_blank"">101:2</a> Efficiency<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=6594 target="_blank"">109:54</a> Objects<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=7012 target="_blank"">116:52</a> Numba<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=7558 target="_blank"">125:58</a> Anaconda<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=7825 target="_blank"">130:25</a> Conda<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=8761 target="_blank"">146:1</a> Quansight Labs<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=8977 target="_blank"">149:37</a> OpenTeams<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=9430 target="_blank"">157:10</a> GitHub<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=9760 target="_blank"">162:40</a> Marketing<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=10038 target="_blank"">167:18</a> Great programming<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=10688 target="_blank"">178:8</a> Hiring<br><a href="https://www.youtube.com/watch?v=gFEE3w7F0ww&t=10926 target="_blank"">182:6</a> Advice for young people<br><h3>Transcript</h3><div class='max-width'><p>The following is a conversation with Travis Olyphant, one of the most impactful programmers and data scientists ever. He created NumPy, SciPy, and Anaconda. NumPy formed the foundation of tensor-based machine learning in Python. SciPy formed the foundation of scientific programming in Python. And Anaconda, specifically with Conda, made Python more accessible to a much larger audience. Travis's life work across a large number of programming and entrepreneurial efforts has and will continue to have immeasurable impact on millions of lives by empowering scientists and engineers in big companies, small companies, and open-source communities to take on difficult problems and solve them with the power of programming. Plus, he's a truly kind human being, which is something that when combined with vision and ambition makes for a great leader and a great person to chat with. To support this podcast, please check out our sponsors in the description. This is the Alex Friedman Podcast, and here is my conversation with Travis Olyphant. What was the first computer program you've ever written? Do you remember? - Whoa, that's a good question. I think it was in fourth grade. Just a simple loop in Basic. - Basic. - Basic, yeah, on an Atari 800, Atari 400, I think, or maybe it was an Atari 800. It was a part of a class, and we just were just basic loops to print things out. - Did you use goto statements? - Yes, yes, we used goto statements. - I remember in the early days, that's when I first realized there's principles to programming, when I was told that don't use goto statements. Those are bad software engineering principles. It goes against what great, beautiful code is. I was like, oh, okay, there's rules to this game. - I didn't see that until high school when I took an AP Computer Science course. I did a lot of other kinds of just programming in TI, but finally when I took an AP Computer Science course in Pascal. - Wow. - Yeah, it was Pascal. That's when I, oh, there are these principles. - Not C or C++? - No, I didn't take C until the next year in college. I had a course in C, but I haven't done much in Pascal, just that AP Computer Science course. - Now, sorry for the romanticized question, but when did you first fall in love with programming? - Oh, man, good question. I think actually when I was 10. My dad got us a Timex Sinclair, and he was excited about the spreadsheet capability, and then, but I made him get the basic, the add-ons so we could actually program in basic, and just being able to write instructions and have the computer do something. Then we got a TI99, TI99-4A when I was about 12, and I would just, it had sprites and graphics and music. You could actually program it to do music. That's when I really sort of fell in love with programming. - So this is a full, like a real computer with memory and storage and processors, so we're not, 'cause you say TI, it's not-- - Yeah, the Timex Sinclair was one of the very first. It was a cheap, cheap, I think it was, well, it was still expensive, but it was 2K of memory. We got the 16K add-on pack. But yeah, it had memory, and you could program it. You had the, in order to store your programs, you had to attach a tape drive. Remember that old, the sound that would play when you converted the modem, it would convert digital bits to audio files and set on a tape drive. Still remember that sound, but that was the storage. - And what was the programming language, do you remember? - It was basic. - It was basic. - And then they had a VisiCalc, and so a little bit of spreadsheet programming in VisiCalc, but mostly just some basic. - Do you remember what kind of things drew you to programming? Was it working with data? Was it video games? - Math. - Games? - Math. - Math. - Math-y stuff? - Yeah, I've always loved math, and a lot of people think they don't like math because I think when they're exposed to it early, it's about memory. You know, when you're exposed to math early, you have a good short-term memory, it remembers timetables. And I do have a reasonably, I mean, not perfect, but a reasonably long little short-term memory buffer. And so I did great at timetables. I said, "Oh, I'm good at math." But I started to really like math, just the problem-solving aspect. And so computing was problem-solving applied. And so that's always kind of been the draw, kind of coupled with the mathematics. - Did you ever see the computer as like an extension of your mind, like something able to achieve-- - Not till later. - Okay. - Yeah, not then. - It's just like a little set of puzzles that you can play with, and you can play with math puzzles. - Yeah, it was too rudimentary early on. Like it was sort of, yeah, it was a lot of work to actually take a thought you'd have and actually get it implemented. And that's still work, but it's getting easier. And so, yeah, I would say that's definitely what's attracting me to Python, is that that was more real, right? I could think in Python. Speaking of foreign language, I only speak another language fluently, besides English, which is Spanish. And I remember the day when I would dream in Spanish. And you start to think in that language. And then you actually, I do definitely believe that language limits or expands your thinking. There's some languages that actually lead you to certain thought processes. - Yeah, like, so I speak Russian fluently. And that's certainly a language that leads you down certain thought processes. Well, yeah, I mean, there's a history of the two world wars, of millions of people starving to death or near to death throughout its history, of suffering, of injustice, like this promise sold to the people and then the carpet or whatever is swept from under them. It's like broken promises. And all of that pain and melancholy is in the language, the sad songs, the sad, hopeful songs, the over-romanticized, like, I love you, I hate you, the sort of the swings between all the various spectrums of emotion. So that's all within the language. The way it's twisted, there's a strong culture of rhyming poetry. So like the bards, like the sync, there's a musicality to the language too. - Did Dostoevsky write in Russian? - Yeah, so like, (speaking in foreign language) All the-- - The ones that I know about, which are translated. And I'm curious how the translations. - So Dostoevsky did not use the musicality of the language too much. So it actually translates pretty well because it's so philosophically dense that the story does a lot of the work. But there's a bunch of things that are untranslatable. Certainly the poetry is not translatable. I actually have a few conversations coming up offline and also in this podcast with people who've translated Dostoevsky. And that's for people who worked in this field, know how difficult that is. Sometimes you can spend months thinking about a single sentence in context, 'cause there's just a magic captured by that sentence. And how do you translate just in the right way? Because those words can be really powerful. There's a famous line, "Beauty will save the world" from Dostoevsky. There's so many ways to translate that. And you're right, the language gives you the tools with which to tell the story, but it also leads your mind down certain trajectories and paths to where over time, as you think in that language, you become a different human being. - Yes. Yeah, that's a fascinating reality, I think. I know people have explored that, but it's, I guess, rediscovered. - Well, we don't, we live in our own little pockets. This is the sad thing, is I feel like, unfortunately, given time and getting older, I'll never know China, the Chinese world, 'cause I don't truly know the language. Same with Japanese. I don't truly know Japanese and Portuguese and Brazil, that whole South American continent. Like, yeah, I'll go to Brazil and Argentina, but will I truly understand the people if I don't understand the language? It's sad because I wonder how much, how many geniuses we're missing because so much of the scientific world, so much of the technical world is in English, and so much of it might be lost because we don't have the common language. - I completely agree. I'm very much in that vein of, there's a lot of genius out there that we miss, and we're sort of fortunate when it bubbles up into something that we can understand or process. There's a lot we miss. So that's why I tend to lean towards really loving democratization or things that empower people or very resistant, sort of authoritarian structures. Fundamentally for that reason, well, several reasons, but it just hurts us. We're worse off. - So speaking of languages that empower you, so Python was the first language for me that I really enjoyed thinking in, as you said. - Sounds like you shared my experience too. - So when did you first, do you remember when you first kind of connected with Python, maybe even fell in love with Python? - It's a good question. It was a process that took about a year. I first encountered Python in 1997. I was a graduate student studying biomedical engineering at the Mayo Clinic, and I had previously, I'd been involved in taking information from satellites. I was an electrical engineering student, used to taking information and trying to get something out of it, doing some data processing information out of it. And I'd done that in MATLAB. I'd done that in Perl. I'd done that in scripting on a VMS. There's actually a VAX VMS system, and they had their own little scripting tools around Fortran. Done a lot of that. And then as a graduate student, I was looking for something and encountered Python, and because Python had an array, had two things that made me not filter it away. Because I was filtering a bunch of stuff. It was Yorick, I looked at Yorick, I looked at a few other languages that are out there at the time in 1997, but it had arrays. There's a library called Numeric that had just been written in '95, like not very, not too much earlier, by an MIT alum, Jim Huganin. You know, and I went back and read the mailing list to see the history of how it grew, and there was a very interesting, it's fascinating to do that, actually, to see how this emergent cooperation, unstructured cooperation happens in the open source world that led to a lot of this collective programming, which is something maybe we might get into a little later, about what that looks like. - What gap did Numeric fill? - Numeric filled the gap of having an array object. So instead-- - There was no array object. - There was no array, there was a one-dimensional byte concept, but there was no N-dimensional, two, three, four-dimensional tensor, they call it now. I'm still in the category that a tensor is another thing, and it's just an N-V-A-R-A, we should call it, but kind of lost that battle. - There's many battles in this world, some of which we win, some we lose. - That's exactly right. But it had no math to it. So Numeric had math and a basic way to think in arrays. So I was looking for that, and it had complex numbers. A lot of programming languages, and you can see it because, you know, if you're just a computer scientist, you think, "Ah, complex numbers are just two floats." So people can build that on. But in practice, a complex number as one of the significant algebras that helps connect a lot of physical and mathematical ideas, particularly to FFT for an actual engineer. And it's a really important concept, and not having it means you have to develop it several times, and those times may not share an approach. One of the common things in programming, one of the things programming enables is abstractions. But when you have shared abstractions, it's even better. It sort of gets to the level of language of actually we all think of this the same way, which is both powerful and dangerous, right? Because powerful in that we now can quickly make bigger and higher level things on top of those abstractions dangerous, because it also limits us as to the things we maybe left behind in producing that abstraction, which is at the heart of programming today, and actually building around the programming world. So I think it's a fascinating philosophical topic. - Yeah, that will continue for many years, I think. - For many years. - As we build more and more and more abstractions. - Yes, I often think about, you know, we have a world that's built on these abstractions that, were they the only ones possible? Certainly not, but they led to, now it's very hard to do it differently. Like there's an inertia that's very hard to, you know, push out, push away from. There's, it has implications for things like, you know, the Julia language, which you have heard of, I'm sure. And I've met the creators, and I like Julia. It's a really cool language, but they've struggled to kind of, against just the tide of like this inertia of people using Python. And, you know, there's strategies to approach that, but nonetheless, it's a phenomenon. And sometimes, so I love complex numbers, and I love to erase, so I looked at Python. And then I had the experience, I did some stuff in Python, and I was just doing my PhD, so I was out, my focus was on, I was actually doing a combination of MRI and ultrasound, and looking at a phenomenon called elastography, which is you push waves into the body, and observe those waves, like you can actually measure them, and then you do mathematical inversion to see what the elasticity is. And so that's the problem I was solving, is how to do that with both ultrasound and MRI. I needed some tool to do that with. So I was starting to use Python in '97. In '98, I went back, looked at what I'd written, and realized I could still understand it, which is not the experience I'd had when doing Perl in '95, right? I'd done the same thing, and then I looked back, and I'd forgotten what I was even saying. Now, you know, I'm not saying, so that made me, hey, this may work, I like this. This is something I can retain without becoming an expert, per se. And so that led me to go, hmm, I'm gonna push more to this. And then '98 was kind of when I started to fall in love with Python, I would say. - A few peculiar things about Python, so maybe compare it to Perl, compare it to some of the other languages. So there's no braces. - Yeah, yeah. - So space is used, indentation, I should say, is used as part of the language. - Yeah, right. - So did you, I mean, that's quite a leap. Were you comfortable with that leap, or were you just very open-minded? - It's a good question. I was open-minded, so I was cognizant of the concern. And it definitely has, it has specific challenges. You know, cut and pasting, for example, when you're cut and pasting code, and if your editors aren't supportive of that, if you're putting it into a terminal, and particularly in the past, when terminals didn't necessarily have the intelligence to manage it now. Now, iPython and Jupyter Notebooks handle it just fine, so there's really no problem, but in the past, it created some challenges, formatting challenges, also mixed tabs and spaces. If editors weren't, you weren't clear on what was happening, you would have these issues. So there were really concrete reasons about it that I heard and understood. I never really encountered a problem with it, personally, like it was occasional annoyances, but I really liked the fact that it didn't have all this extra characters, right? That these extra characters didn't show up in my visual field when I was just trying to process understanding a snippet of code. - Yeah, there's a cleanness to it. But I mean, the idea is supposed to be that Perl also has a cleanness to it because of the minimalism of like how many characters it takes to express a certain thing. So it's very compact. But what you realize with that compactness comes, there's a culture that prizes compactness. And so the code gets more and more compact and less and less readable to a point where it's like, like to be a good programmer in Perl, you write code that's basically unreadable. - Right. - There's a culture. - Correct, and you're proud of it. - Yeah, you're proud of it. - Right, exactly, and it's like feels good. And it's really selective. Like it means you have to be an expert in Perl to understand it. Whereas Python allowed you not to have to be an expert. You don't have to take all this brain energy. You could leverage, what I say, you could leverage your English language center, which you're using all the time. I've wondered about other languages, particularly non-Latin-based languages. Latin-based languages with the characters are at least similar. I think people have an easier time, but I don't know what it's like to be a Japanese or a Chinese person trying to learn a different syntax. Like what would computer programming look like in that? I haven't looked at that at all, but it certainly doesn't, leveraging your Chinese language center, I'm not sure Python or any programming language does that. But that was a big deal. The fact that it was accessible, I could be a scientist. What I really liked is many programming languages really demand a lot of you, and you can get a lot, you do a lot if you learn it. But Python enables you to do a lot without demanding a lot of you. There's nuance to that statement, but it certainly is more accessible. So more people could actually, as a scientist, as somebody who, or an engineer, who was trying to solve another problem besides programming, I could still use this language and get things done and be happy about it. Now I was also comfortable in C at that time. - And MATLAB you did a little bit of that. - And MATLAB I did a lot before that, exactly. So I was comfortable in, those three languages were really the tools I used during my studies and schooling. But to your point about language helping you think, one of the big things about MATLAB was it was, and APL before it, I don't know if you remember APL. - Nope. - APL is actually the predecessor of array-based programming, which I think is really an underappreciated, if I talk to people who are just steeped in computer programming, computer science, most of the people that Microsoft has hired in the past, for example, Microsoft as a company generally did not understand array-based programming, culturally they didn't understand it so they kept missing the boat, kept missing the understanding of what this was. They've gotten better, but there's still a whole culture of folks that doesn't, programming, that's systems programming or web programming or lists and maps and what about an n-dimensional array? Oh yeah, that's just an implementation detail. Well, you can think that, but then actually if you have that as a construct, you actually think differently. APL was the first language to understand that and it was in the 60s. The challenge of APL is APL had very dense, not only glyphs, like new characters, new glyphs, they even had a new keyboard because to produce those glyphs, this was back in the early days of computing when the QWERTY keyboard maybe wasn't as established. Like, well, we can have a new keyboard, no big deal. But it was a big deal and it didn't catch on and the language APL, very much like Perl, as people would pride themselves on how much, could they write the game of life in 30 characters of APL? APL has characters that mean summation and they have adverbs, they would have adjectives and these things called adverbs, which are like methods, like reduction, it would be an adverb on an ad operator. But using these tools, you could construct and then you start to think at that level, you think in n dimensions, it's something I like to say, and you start to think differently about data at that point. It really helps. - Yeah, I mean, outside of programming, if you really internalize linear algebra as a course, I mean, it philosophically allows you to think of the world differently. It's almost like liberating. You don't have to think about the individual numbers in the n dimensional array. You could think of it as an object in itself and all of a sudden this world can open up. You're saying MATLAB and APL were like the early, I don't know if many languages got that right ever. - No, no, no, they didn't. Even still, I would say, I mean, NumPy is an inheritor of the traditions. I would say APLJ was another version that was, what it did is not have the glyphs, just have short characters, but still a Latin keyboard could type them. And then Numeric inherited from that in terms of let's add arrays plus broadcasting, plus methods, reduction, even some of the language like rank is a concept that was in Python, it's still in Python, for the number of dimensions. That's different than say the rank of a matrix, which people think of as well. So it came from that tradition, but NumPy is a very pragmatic, practical tool. NumPy inherited from Numeric and we can get to where NumPy came from, which is the current array, at least current as of 2015, 2017, now there's a ton of them over the past two or three years. We can get into that too. - So if we just sort of linger on the early days of what was your favorite feature of Python? Do you remember like what-- - Yeah. - It's so interesting to linger on like the, what really makes you connect with a language? I'm not sure it's obvious to introspect that. - No, it isn't, and I've thought about that at some length. I think definitely the fact that I could read it later, that I could use it productively without becoming an expert. Like other languages I had to put more effort into. - Right, that's like an empirical observation, like you're not analyzing any one aspect of the language, it just seems time after time, you look back, it's somehow readable. - It's somehow readable, and then it was sort of, I could take executable English and translate it to Python more easily. Like I didn't have to go, there was no translation layer. As an engineer or as a scientist, I could think about what I wanted to do, and then the syntax wasn't that far behind it. - Yeah. - Right, now there are some warts there still, it wasn't perfect. There's some areas where I'm like, "Ah, it'd be better if this were different, "or if this were different." Some of those things got added to the language too. I was really grateful for some of the early pioneers in the Python ecosystem back, 'cause Python got written in '91, is when the first version came out. But Guido was very open to users, and one of the sets of users were people like Jim Hugonin, and David Asher, and Paul Dubois, and Conrad Hinson. These were people that were on the main list, and they were just asking for things like, "Hey, we really should have complex numbers "in this language." So let's, you know, there's a J, there's a one J, right? And the fact that they went the engineering route of J is interesting. I don't think that's entirely favoring engineers, I think it's because I is so often used as the index of a for loop. (Lex laughs) I think that's actually why. - Probably. - Right. - That's the pragmatic aspect. - But the fact that complex numbers were there, I love that. The fact that I could write NDA array constructs, and that reduction was there. Very simple to write summations, and broadcasting was there. I could do addition of whole arrays. So that was cool. Those are some things I loved about it. - I don't know what to start talking to you about, 'cause you've created so many incredible projects that basically changed the whole landscape of programming. But okay, let's start with, let's go chronologically with SciPy. You created SciPy over two decades ago now? - Yes. - Right? - Yes, I love to talk about SciPy. SciPy was really my baby. - What is it? What was its goal? What is its goal? How does it work? - Yeah, fantastic. So SciPy was effectively, here I am using Python to do stuff that I previously used MATLAB to use. And I was using Numeric, which is an array library that made a lot of it possible. But there's things that were missing. Like I didn't have an ordinary differential equation solver, I could just call, right? I didn't have integration. Hey, I wanted to integrate this function. Okay, well, I don't have just a function I can call to do that. These are things I remember being critical things that I was missing. Optimization, I just wanna pass a function to an optimizer and have it tell me what the optimum value is. Those are things like, well, why don't we just write a library that adds these tools? And I started to post to the main list, and there'd previously been, people have discussed, I remember Conrad Hinson saying, wouldn't it be great if we had this optimizer library? Or David Ash would say this stuff. And I'm ambitious, ambitious is the wrong word, and eager, and probably more time than sense. I was a poor graduate student. My wife thinks I'm working on my PhD, and I am. But part of the PhD that I loved was the fact that it's exploratory. You're not just taking orders, fulfilling a list of things to do, you're trying to figure out what to do. And so I thought, well, I'm writing tools for my own use in a PhD, so I'll just start this project. And so in '99, '98 was when I first started to write libraries for Python. But really when I fell in love with Python in '98, I thought, oh, well, there's just a few things missing. Like, oh, I need a reader to read DICOM files. I was in medical imaging, and DICOM was a format that, I want to be able to load that into Python. Okay, how do I write a reader for that? So I wrote something called, it was an IO package, right? And that was my very first extension module, which is C. So I wrote C code to extend Python so that in Python I could write things more easily. That combination kind of hooked me. It was the idea that I could, here's this powerful tool I can use as a scripting language and a high-level language to think about, but that I can extend easily. - In C. - Easily in C. Easily for me because I knew enough C. And then Guido had written a, I mean, the only, the hard part of extending Python was something called the way memory management works, and you have to reference counting. And so there's a tracking of reference counting you have to do manually. And if you don't, you have memory leaks. And so that's hard. Plus in C, it's much more, you have to put more effort into it. It's not just, I have to now think about pointers and I have to think about stuff that is different. I have to kind of, you're like putting a new cartridge in your brain. Like you're, okay, I'm thinking about MRI, now I'm thinking about programming. And there are distinct modules you end up having to think about. So it's harder. When I was just in Python, I could just think about MRI and high-level writing. But I could do that, and that kind of, I liked it. I found that to be enjoyable and fun. And so I ended up, oh, well, let me just add a bunch of stuff to Python to do integration. Well, and the cool thing is, is that the power of the internet, I just looking around and I found, oh, there's this NetLib, which has hundreds of Fortran routines that people had written in the '60s and the '70s and the '80s and Fortran 77, fortunately, it wasn't Fortran 60s, it had been ported to Fortran 77. And Fortran 77 is actually a really great language. Fortran 90 probably is my favorite Fortran because it's got complex numbers, got arrays, and it's pretty high level. Now, the problem with it is you'd never wanna write a program in Fortran 90 or Fortran 77, but it's totally fine to write a subroutine in. Right, and so, and then Fortran kind of got a little off course when they tried to compete with C++. But at the time, I just want libraries that do something, like, oh, here's an order-inference equation. Here's integration. Here's run-cut-integration. Already done. I don't have to think about that algorithm. I mean, you could, but it's nice to have somebody who's already done one and tested it. And so I sort of started this journey in '98, really, if you look back at the main list, there's sort of this productive era of me writing an extension module to connect run-cut-integration to Python and making an ordinary additional equation solver, and then releasing that as a package. So we could call it ODE-PAC, I think I called it then, QuadPAC, and then I just made these packages. Eventually, that became Multipac 'cause they were originally modular. You can install them separately. But a massive problem in Python was actually just getting your stuff installed. At the time, releasing software for me, like, today, people think, what does that mean? Well, then it meant some poorly-written webpage, I had some bad webpage up, and I put a tarball, just a gzip tarball of source code. That was the release. - But, okay, can we just end that? - Sure. - Because the community aspect of creating the package and sharing that, that's rare. - To both have-- - What do you mean? - At that time, so like the raw-- - Yeah, it was pretty early, yeah. - Well, not rare. Maybe you can correct me on this, but it seems like in the scientific community, so many people, you were basically solving the problems you needed to solve to process the particular application, the data that you need. And to also have the mind that I'm going to make this usable for others, that's-- - I would say I was inspired. I'd been inspired by Linux, been inspired by Linus and him making his code available, and I was starting to use Linux at the time. I went, "This is cool." So I'd kind of been previously primed that way. And generally, I was into science because I liked the sharing notion. I liked the idea of, hey, let's, if collectively we build knowledge and share it, we can all be better off. - Okay, so you were energized by that idea. - So I was energized by that already, right? And I can't deny that, I was. I'm sort of, I had this very, I liked that part of science, that part of sharing. And then all of a sudden, oh, wait, here's something, and here's something I could do. And then I slowly over years learned how to share better so that you could actually engage more people faster. One of the key things was actually giving people a binary they could install, right? So that it wasn't just, here's source code, good luck. - Compile this, and then-- - It's compiled, ready to install, just, you know, so. In fact, a lot of the journey from '98, even through 2012, when I started Anaconda, was about that. Like, it's why, you know, it's really the key as to why a scientist with dreams of doing MRI research ended up starting a software company that installs software. - I work with a few folks now that don't program, like, on the creative side, the video side, the audio side. And because my whole life is run on scripts, I have to try to get them, I'm having now the task of teaching them how to do Python enough to run the scripts. And so I've been actually facing this, whether it's on Anaconda or some, with the task of how do I minimally explain, basically to my mom, how to write a Python script. And it's an interesting challenge. I have to, it's a to-do item for me to figure out, like, what is the minimal amount of information I have to teach, what are the tools you use, that when you enjoy it, to your effect of it-- - And they're related, those are two related questions. - And then the debugging, like the iterative process of running the script to figure out what the error is, maybe even for some people to do the fix yourself. So do you compile it, do you, like, how do you distribute that code to them? And it's interesting because I think it's exactly what you're talking about. If you increase the circle of empathy, the circle of people that are able to use your programs, you increase it, it's like, effectiveness and it's power. And so you have to think, you know, can I write scripts, can I write programs that can be used by medical engineers, by all kinds of people that don't know programming? And actually, maybe plant a seed, have them catch the bug of programming so that they start on their journey. That's a huge responsibility and ultimately it has to do with the Amazon one-click buy, like, how frictionless can you make the early steps? - Frictionless is actually really key. To go in any community is, any friction point, you're just gonna lose some people. - Yeah. - Right? Sometimes you may wanna intentionally do that if you're early enough on, you need a lot of help, you need people who have the skills, you might actually, it's helpful, you don't necessarily have too many users as opposed to contributors if you're early on. Anyway, SciFi started in '98, but it really emerged as this collection of modules that I was just putting on the net, people were downloading. And you know, I think I got 100 users, right, by the end of that year. But the fact that I got 100 users and more than that, people started to email me with fixes. And that was actually intoxicating, right? That was the, you know, here I'm writing papers, I'm giving conferences, and I get people to say hello, but yeah, good job, but mostly it was, you're viewed with, it's competitive, right? You publish a paper and people are like, oh, it wasn't my paper, you know? I was starting to see that sense of academic life where it was so much, I thought there was this cooperative effort, but it sounds like we're here just to one-up each other. - Right. - And you know, that's not true across the board, but a lot of that's there. But here in this world, I was getting responses from people all over the world. You know, I remember Piero Peterson in Estonia, right, was one of the first people. And he sent me back this makefile, 'cause you know, the first thing he did is, "Yeah, your build thing stinks, "and here's a better makefile." Now it was a complex makefile, I don't think I ever understood that makefile actually, but it worked, and it did a lot more, and so I was like, thanks, this is cool. And that was my first kind of engagement with community development. But you know, the process was, he sent me a patch file, I had to upload a new tarball. And I just found I really loved that. And the style back then was, here's a mailing list, it's very, it wasn't as, it certainly weren't the tools that are available today, it was very early on. But I really started to, that's the whole year, I think I did about seven packages that year, right? And then by the end of the year, I collected them into a thing called Multipack. So '99, there was this thing called Multipack, and that's when a high school student, I know he was a high school student at the time, a guy named Robert Kern, took that package and made a Windows installer, right? And then of course a massive increase of usage. - So by the way, most of this development was under Linux. - Yes, yes, it was on Linux, I was a Linux developer, doing it on a Unix box. I mean, at the time, I was actually getting into, I had a new hard drive, did some kernel programming to make the hard drive work. I mean, not programming, but modification to the kernel so I could actually get a hard drive working. I love that aspect of it. I was also, at school, I was building a cluster, I took Mac computers, and you put Yellow Dog Linux on 'em. At the Mayo Clinic, they were just, all these Macs that were older, they were just getting rid of, and so I kind of got permission to go grab 'em together, I put about 24 of 'em together in a cluster in a cabinet, and put Yellow Dog Linux on 'em all, and I wrote a C++ program to do MRI simulation. That was what I was doing at the same time for my day job, so to speak. So I was loving the whole process. At the same time, I was, oh, I need a ordinary differential equation. That's why ordinary differential equations were key, was because that's the heart of a block equation for simulating MRI, is an ODE solver. And so that's, but I actually did that, it doesn't happen at the same time. That's why, kind of, what you're working on and what you're interested in, they're coinciding. I was definitely scratching my own itch in terms of building stuff, which helped in the sense that I was using it for me, so at least I had one user. I had one person who was like, well, no, this is better, I like this interface better, and I had the experience of MATLAB to guide some of what those APIs might look like. But you're just doing yourself, you're building all this stuff. But with the Windows installer, it was the first time I realized, oh, yeah, the binary installer really helps people. And so that led to spending more time on that side of things. So around 2000, so I graduated my PhD in 2000, end of year, end of 2000. So '99, doing a lot of work there, '98, doing a lot of work there, '99, kind of spending more time on my PhD, helping people use the tools, thinking about what do I wanna go from here. There was a company, there was a guy, actually, Eric Jones and Travis Vought, they were two friends who founded a company called Enthought. It's here in Austin, still here. And they, Eric contacted me at the time when I was a graduate student still, and he said, hey, why don't you come down, we wanna build a company, we're thinking of a scientific company and we wanna take what you're doing and kind of add it to some stuff that he'd done, he'd written some tools. And then Piero Peterson had done F2Pi, let's come together and build, pull this all together and call it SciPy. So that's the origin of the SciPy brand. It came from Multipack and a whole bunch of modules I'd written, plus a few things from some other folks, and then pulled together in a single installer. SciPy was really a distribution of Python, masquerading as a library. - How did you think about SciPy in context of Python, in context of numeric? Like what-- - So we saw SciPy as a way to make an R&D environment for Python, like use Python, depended on numeric. So numeric was the array library we depended on. And then from there, extend it with a bunch of modules that allowed for, and at the time, the original vision of SciPy was to have plotting, was to have, you know, REPL environment and kind of a whole, really a whole data environment that you could then install and get going with. And that was kind of the thinking. It didn't really evolve that way, right? It sort of had a, but one, it's really hard to do massive scale projects with open source collectives. Actually, there's sort of an intrinsic cooperation limit as to which, you know, too many cooks in the kitchen, you know, you can do amazing infrastructure work. When it comes down to bringing it all together into a single deliverable, that actually requires a little more product management that is not, that doesn't really emerge from the same dynamic. So it struggled, you know, it struggled to get, almost too many voices, it's hard to have everybody agree, you know, consensus doesn't really work at that scale. You end up with politics, you end up with the same kind of things that's happened in large organizations trying to decide on what to do together. So consensus building was still, was challenging at scale as more people came in, right? Early on, it's fine 'cause there's nobody there. And so it works, but then as you get more successful and more people use it, all of a sudden, oh, there's this scale at which this doesn't work anymore and we have to come up with different approaches. So Sci-Fi came out officially in 2001, was the first release, most of the time, I remember the days of getting that release ready, it was a Windows installer and there were bugs on how, you know, the Windows compiler handled complex numbers and you were chasing segmentation faults. It was, it's a lot of work. There was a lot of, effort had nothing to do with my area of study. And at the same time, I had just gotten an offer. So he wondered if I wanted to come down and help him start that company with his friend. And I, at the time, I was like, I was so intrigued, but I was squaring a path, an academic path. And I had just got an offer to go and teach at my alma mater. So I took that tenure track position. And Sci-Fi and kind of, then I started working on Sci-Fi as a professor too. - Okay. - So that's, I left, I've got the Mayo Clinic, graduated, wrote my thesis using Sci-Fi, wrote, you know, there's images that were created. Now the plotting tool I used was something from Yorick actually. It was a plotting, a PLT, kind of a plotting language that I used. - Yorick is a programming language? - It was a programming language. It had a plotting tool, Dyslin. It had integration to Dyslin. I ended up using Dyslin plus some of the plotting from Yorick, linked to from Python. Anyway, it was, people don't plot that way now, but this is before, and Sci-Fi was trying to add plotting. - Yeah. - Right? It didn't have much success. Really the success of plotting came from John Hunter, who had a similar experience to my experience, my kind of maverick experience as a person just trying to get stuff done and kind of having more time than money maybe, right? - And John Hunter created what? - Matplotlib. - He's the creator of Matplotlib? - Yeah, so John Hunter was, you know, he wasn't a student at the time, but he was an, he was working in quant field, and he said, "We need better plotting." So he just went out and said, "Cool, I'll make a new project, "and we'll call it Matplotlib," and he released it in 2001, about the same time that Sci-Fi came out. And it was separate library, separate install, used numeric, Sci-Fi used numeric. And so Sci-Fi, you know, in 2001 we released Sci-Fi, and then Enthoq created a conference called Sci-Fi, which brought people together to talk about the space. And that conference is still ongoing. It's one of the favorite conferences of a lot of people, because it's, you know, it's changed over the years, but early on it was, you know, a collection of 50 people who care about, scientists mostly, you know, practicing scientists who want to care about coding and doing it well and not using MATLAB. And I remember being driven by, you know, I like MATLAB, but I didn't like the fact that, so I'm not opposed to proprietary software. I'm actually not an open source zealot. I love open source for what it brings, but I also see the role for proprietary software. But what I didn't like was the fact that I would develop code and publish it, and then effectively telling somebody, "Here, to run my code, "you have to have this proprietary software." - Right, and there's also culture around MATLAB, as much, 'cause I've talked to a few folks, Mathworks creates MATLAB. - Yeah. - I mean, there's just a culture, they try really hard, but it just is this corporate IBM style culture that's like, or whatever. I don't want to say negative things about IBM or whatever, but there's a-- - No, it's really that connection. It's something I'm in the middle of right now is the business of open source and how do you connect the ethos of cooperative development with the necessity of creating profits, right? And like right now today, you know, I'm still in the middle of that. That's actually the early days of me exploring this question. 'Cause I was writing sci-fi, I mean, as an aside, I also had, so I had three kids at the time. I have six kids now. I got married early, wanted a family. I had three kids, and I remember reading, I read Richard Stallman's post, and I was a fan of Stallman. I would read his work. I liked his collective ideas he would have. Certainly the ideas on IP law, I read a lot of his stuff. But then he said, you know, "Okay, well, how do I make money with this? "How do I make a living? "How do I pay for my kids?" All this stuff was in my mind, young graduate student making no money, thinking I gotta get a job. And he said, "Well, you know, "I think just be like me and don't have kids, right? "That's just don't, don't." - That's his take on it, that's his-- - That was the, what he said in that moment, right? That's the thing I read, and I went, "Okay, this is a train I can't get on." - Yeah. There has to be a way to preserve the culture of open source and still be able to make sufficient money to feed your-- - Yes, exactly, there's gotta be. Well, so that actually led me to a study of economics. 'Cause at the time, I was ignorant, and I really was. And I'm actually, I'm embarrassed for educational system that they could let me, and I was valedictorian in my high school class, and I did super well in college. And academically, I did great, right? But the fact that I could do that and then be clueless about this key part of life, it led me to go, "There's a problem." Like, I should've learned this in fifth grade. I should've learned this in eighth grade. Like, everybody should come out with a basic knowledge of economics. - You're an interesting example because you've created tools that changed the lives of probably millions of people, and the fact that you don't understand, at the time of the creation of those tools, the basics economics of how to build up a giant system is a problem. - Yeah, it's a problem. And so, during my PhD at the same time, this is back in '98, '99, at the same time, I was in a library, I was reading books on capitalism, I was reading books on Marxism, I was reading books on, you know, what is this thing? What does it mean? And I encountered, basically, I encountered a set of writings from people that said they were the inheritors of Adam Smith. Read Adam Smith for the first time, right? Which is the wealth of nations and kind of this notion of emergent societies, and realized, oh, there's this whole world out here of people, and the challenge of economics is also political. Like, 'cause economics, you know, people, different parties running for office, they want their economic friends. They want their economists to back them up, right? Or to be their magicians, like the magicians in Pharaoh's court, right? The people that are gonna say, hey, this is, you should listen to me because I've got the expert who says this. And so, it gets really muddled, right? But I was looking at it as a scientist, going, what is this space? What does this mean? How does Paris get fed? How does, what is money? How does it work? And I found a lot of writings that I really loved. I found some things that I really loved, and I learned from that. It was writings from people like Von Mises. He wrote a paper in 1920 that still should be read more than it is. It was the economic calculation problem of the socialist commonwealth. It was basically in response to the Bolshevik Revolution in 1917. And his basic argument was, it's not gonna work to not have private property. You're not gonna be able to come up with prices. The bureaucrats aren't gonna be able to determine how to allocate resources without a price system. And a price system emerges from people making trades. And they can only make trades if they have authority over the thing they're trading. And that creates information flow that you just don't have if you try to top down it. - Right. - Right. It's like, huh, that's a really good point. - Yeah, the prices have a signal that's used. And it's important to have that signal when you're trying to build a community of productive people-- - Yeah. - Like you would in the software engineering space. - Yeah, the prices are actually an important signaling mechanism. - Yeah. - Right? And that money is just a bartering tool. - Yeah. - Right? So this is the first time I've encountered any of this concept, right? And the fact that, oh, this is actually really critical. Like, it's so critical to our prosperity and that we're dangerously not learning about this, not teaching our children about this. - So you had the three kids, and you had to make some hard decisions. - Had to make some money, right? Had to figure it out. But I didn't really care. I mean, I've never been driven by money, just need it, in fact. - Yeah, right. To eat. So how did that resolve itself in terms of Sly Fi? - So I would say it didn't really resolve itself. It sort of started a journey that I'm continuing on. I'm still on, I would say. I don't think it resolved itself. But I will say I went in eyes wide open. Like, I knew that there were problems with giving stuff away and creating the market externalities that the fact that, yeah, people might use it, and I might not get paid for it, and I'll have to figure something else out to get paid. Like, at least I can say I'm not bitter that a lot of people have used stuff that I've written, and I haven't necessarily benefited economically from it. I've heard other people be bitter about that when they write or they talk, like, oh, I should've gotten more value out of this. And I'm also, I want to create systems that let people like me, who might have these desires to do things, let them benefit, so it actually creates more of the same. - Not to turn on your bitterness mojo, but there's some aspect, I wish there was mechanisms for me to reward whoever created Sly Fi and NumPy, 'cause it brought so much joy to my life. - I appreciate that. - You know what I mean? - The tip jar notion was there. I appreciate that, and I think-- - But there should be a very frictionless mechanism. - There should be a frictionless mechanism, I totally agree. I would love to talk about some of the ideas I have, 'cause I actually came across, I think I've come up with some interesting notions that could work, but they'll require, anything that will work takes time to emerge, right? Things don't just turn overnight. That's definitely one thing I've also understood and learned is any fixes, that's why it's kind of funny, we often give credit to, oh, this president gets elected, and oh, look how great things have done. And I saw that when I had a transition in a condo when a new CEO came in, right? And it's like the success that's happening, there's an inertia there, right? - And sometimes the decision you made 10 years before is the reason why the success is-- - Right, exactly, so we're sort of just running around taking credit for stuff. - The credit assignment has a delay to it that makes the credit assignment basically wrong more than right. - Wrong more than right, exactly, and so I'm like, oh, this is, that's the stuff I would read a ton about early on. So I don't, I feel like I'm with you. I want the same thing, I want to be able to, and honestly, not for personally, I've been happy, I've been happy, I feel like I don't have any, I mean, we've been done reasonably okay, but I've had to pursue it. Like, that's really what started my trajectory from academia, is reading that stuff led me to say, oh, entrepreneurship matters. I love software, but we need more entrepreneurs, and I want to understand that better. So once I kind of had that virus infect my brain, even though I was on a trajectory to go to a tenure track position at a university, and I was there for six years, I was kind of already out the door when I started, and we can get into that, but-- - Well, can I just ask a quick question on, is there some design principles that were in your mind around sci-pi? Like, was there some key ideas that were just sticking to you, that this is the fundamental ideas? - Yeah, I would say so. I would think it's basically accessibility to scientists. Like, give them, give scientists and engineers tools that they don't have to think a lot about programming, so give them really good building blocks. Give them functions that they want to call, and sort of just the right length of spelling. There's one tradition in programming where it's like, make very, very long names, right? And you can see it in some programming languages where the names get, take half the screen. And in the 4chan world, characters would have to be six letters early on, right? And that's way too much, too little, but I was like, I liked to have names that were informative, but short. - So even though Python, well, this is a different conversation, but documentation is doing some work there. So when you look at great scientific libraries and functions, there's a richness of documentation that helps you get into the details. The first glance at a function gives you the intuition of all it needs to do by looking at the headers and so on, but to get the depths of all the complexities involved, all the options involved, documentation does some of the work. - Documentation is essential. - Yeah. - So we thought about several things. One is we wanted plotting. We wanted interactive environment. We wanted good documentation. These are things we knew we wanted. The reality is those took about 10 years to evolve, right? Given the fact that we didn't have a big budget, it was all volunteer labor. It was sort of, when Enthought got created and they started to try to find projects, people would pay for pieces and they were able to fund some of it, not nearly enough to keep up with what was necessary. And no criticism, just simply the reality. I mean, it's hard to start a business and then do consulting and then also promote an open source project that's still fairly new. Saipa was fairly niche. We stayed connected all while I was a student, sorry, a professor. I went to BYU and started to teach electrical engineering, all the applied math courses. I loved teaching signal processing, probability theory, electromagnetism. I was, if you look at my professor, which my kids love to do, I wasn't, I got some bad reviews because people-- - What was the criticism? - I would speak too high of a level. I definitely had a calibration problem coming out of graduate work where I hate to be condescending to people. Like I really have a ton of respect for people fundamentally. Like my fundamental thing is I respect people. Sometimes that can lead to a, I was thinking they had more knowledge than they did. And so I would just speak at a very high level, assume they got it. - But they need to rise to the standard that you set. I mean, that's one of the, some of the greatest teachers do that. - And I agree, and that was kind of what was inspiring me. But you also have to, I cannot say I was an articulate of some of the greatest teachers. I was, like one classic example, when I first taught at BYU, my very first class, it was overheads, transparencies, overheads. Before projectors were really that common. Transparencies, I'm writing my notes out. I go in, room's half dark. I just blaring through these transparencies. Here it is, here it is, here it is. And I gave a quiz after two weeks. Nowhere knew anything. Nothing I had taught had gotten anywhere. (laughing) And I realized, okay, I'm not, this is not working. So I put away the transparencies, and I turned around and just started using the chalkboard. And what it did is it slowed me down. Right, the chalkboard just slowed me down and gave people time to process and to think. And then that made me focus. My writing wasn't great on the chalkboard, but I really love that part of like the teaching. So that entered Sai Pai's world in terms of we always understood that there's a didactic aspect of Sai Pai. Kind of how do you take the knowledge and then produce it? The challenge we had was the scope. Like ultimately Sai Pai was everything, right? And so 2001 when it first came out, people were starting to use it. No, this is cool. This is a tool we actually use. At the same time, 2001 timeframe, there was a little bit of like the Hubble Space Telescope. The folks at Hubble had started to say, hey, Python, we're gonna use Python for processing images from Hubble. And so Perry Greenfield was a good friend and running that program. And he had called me before I left BYU and said, you know, we wanna do this, but numeric actually has some challenges in terms of, you know, it's not a, the array doesn't have enough types. We need more operations. You know, broadcast needs to be a little more settled. They wanted record arrays. They wanted, you know, record arrays are like a data frame, but a little bit different. But they wanted more structured data. So he had called me even early on then. And he said, you know, would you wanna work on something to make this work? And I said, yeah, I'm interested, but I'm going here. And I, you know, we'll see if I have time. So in the meantime, while I was teaching and SciPy was emerging, and I had a student, I was constantly, while I was teaching, trying to figure a way to fund this stuff. So I had a graduate student, my only graduate student, a Chinese fellow, Liu Hongze is his name, great guy. He wrote a bunch of stuff for iterative linear algebra, like got into writing some of the iterative linear algebra tools that are currently there in SciPy. And they've gotten better since, but this is in 2005. Kept working on SciPy, but Perry has started working on a replacement to NumEric called NumEri. And in 2004, a package called NDImage, it was an image processing library that was written for NumEri. And it had in it a morphology tool. I don't know if you know what morphology is. It's open dilations, you know, there was sort of this, as a medical imaging student, I knew what it was because it was used in segmentation a lot. And in fact, I'd wanted to do something like that in Python, in SciPy, but just had never gotten around to it. So when it came out, but it worked only on NumEri, and SciPy needed NumEric, and so we effectively had the beginning of this split. And NumEric and NumEri didn't share data. They were just two, so you could have a gigabyte of NumEri data and a gigabyte of NumEric data, and they wouldn't share it. And so you had these, then you had these scientific libraries written on top. I got really bugged by that. I got really like, oh man, this is not good. We're not cooperating now. We're not, we're sort of redoing each other's work, and we're just this young community. So that's what led me, even though I knew it was risky, because my, you know, I was on a tenure track position. 2004, I got reviewed. They said, hey, things are going okay. You're doing well. Paper's coming out. But you're kind of spending a lot of time on this open source stuff. Maybe do a little less of that, and a little more of the paper writing and grant writing, which was naive, but it was definitely the time, you know, the thinking. - It still goes on. - Still goes on. - You're basically creating a thing which enables science in the 21st century. - Right. - Maybe don't emphasize that so much in your four-year tenure. - Right. (laughing) It illustrates some of the challenges. - Yes. - It does, and it's, people mean well, but we've gotten broken in a bunch of ways. - Certain things, programming, understanding the role of software engineering and programming in society is a little bit lacking. - Exactly. Now, I was in an electrical engineering position. - Right. That's even worse. There. - Yeah, it was very, they were very focused. And so, you know, good people, and I had a great time. I loved my time, I loved my teaching, I loved all the things I did there. The problem was, this split was happening in this community that I loved. - Yeah. - I saw people, and I went, oh my gosh, this is gonna be, this is not great. And so, I happened, you know, fate, I had a class I had signed up for. I was trying to build an MRI system, so I had a kind of a radio, instead of a radio, a digital radio class, it was a digital MRI class. - Mm-hmm. - And I had people sign up, two people signed up, then they dropped, and so I had nobody in this class. So, and I didn't have any other courses to teach, and I thought, oh, I've got some time, and I'll just write a merger of numeric and numeric. Like, I'll basically take the numeric code base, add the features numeric was adding, and then kind of come up with a single array library that everybody can use. So that's where NumPy came from, was my thinking, hey, I can do this, and who else is going to? 'Cause at that point, I'd been around the community long enough, and I'd written enough C code, I knew the structures. In fact, my first contribution to numeric had been writing the C API documentation that went in the first documentation for NumPy, for numeric, sorry, this is Paul Dubois, David Asher, Conrad Hinson, and myself. I got credit 'cause I wrote this chapter, which is all the C API of numeric, all the C stuff. So I said, I'm probably the one to do it, nobody else is gonna do this. So it was sort of, out of a sense of duty and passion, knowing that, I don't think my academic, I don't think the department here is gonna appreciate this, but it's the right thing to do. - Can we just link on that moment? - Yeah. - Because the importance of the way you thought and the action you took, I feel is understated and is rare, and I would love to see so much more of it, because what happens as the tools become more popular, there's a split that happens. And it's a truly heroic and impactful action to in that early split to step up, and it's like great leaders throughout history, like get, what is the brave heart, like get on a horse and rally the troops, because I think that can make a big difference. We have TensorFlow versus PyTorch in the machine learning community. - We have the same problem today. - Yeah, I wonder-- - It's actually bigger. - I wonder if it's possible in the early days to rally the troops. - It is possible, especially in the early days. The longer it goes, the harder, right? And the more energy in the factions, the harder. But in the early days, it is possible, and it's extremely helpful, and there's a willingness there, but the challenge is there's usually not a willingness to fund it. There's not a willingness to, like I was literally walking into a field, saying I'm gonna do this, and here I am, I have five kids at home now. (laughing) - Pressure builds. - Sometimes my wife hears these stories, and she's like, you did what? (laughing) I thought you were actually on a path to make sure we had resources and money. - Oh, wow. - But again, there's an aspect, I'm a very hopeful person. I'm an optimistic person by nature. I love people. I learned that about myself later on. Part of my, my religious beliefs actually lead to that, and it's why I hold them dear, because it's actually how I feel about, it's what leads me to these attitudes, sort of this hopefulness and this sense of, yeah, it may not work out for me financially, or maybe, but that's not the ultimate gain. Like, that's a thing, but it's not, you know, that's not the scorecard for me. And so I just wanted to be helpful, and I knew, and partly because these Sci-Py conferences, 'cause the mailing list conversations, I knew there was a lot of need for this, right? And so I had this, it wasn't like I was alone in terms of no feedback. I had these people who knew, but it was crazy. Like, people who, at the time, said, yeah, we didn't think you'd be able to do it. We thought it was crazy. - And also, instructive, like practically speaking, that you had a cool feature that you were chasing, the morphology, like the-- - Yes. - Like, it's not just like-- - There's an end result. - It's not some visionary thing, I'm going to unite the community. You were like-- - Correct. - You were actually practically, this is what one person actually could do, and actually build. - 'Cause that is important, 'cause you can get over your skis. - Yeah. - You can definitely get over your skis. And I had, in fact, this almost got me over my skis, right? I would say, well, in retrospect, I hate looking back. I can tell you all the flaws with NumPy, right? When I go into it, there's lots of stuff that I'm like, oh man, that's embarrassing. That was wrong. I wish I had somebody to slap me the wet fish there. Like, I needed, like, what I'd wished I'd had was somebody with more experience, and certainly library writing and array library. Like, I wish I had me. I could go back in time and go, do this, do that. Here's a Morton Bean. 'Cause there's things we did that are still there that are problematic, that created challenges for later. And I didn't know it at the time. Didn't understand how important that was. And in many cases, didn't know what to do. Like, there was pieces of the design of NumPy, I didn't know what to do until five years ago. Now I know what they should have been, but I didn't know at the time, and I couldn't get the help. Anyway, so I wrote it. It took about, it took four months to write the first version and about 14 months to make it usable. But it was that first four months of intense writing, coding, getting something out the door that worked. That was, it was definitely challenging. And then the big thing I did was create a new type object called Dtype. That was probably the contribution. And then the fact that I added broad, not just broadcasting, but advanced indexing. So that you could do masked indexing and indirect indexing instead of just slicing. - So for people who don't know, and maybe you can elaborate. So NumPy, I guess the vision in the narrowest sense is to have this object that represents n-dimensional arrays. And like at any level of abstraction you want, but basically it could be a black box that you can investigate in ways that you would naturally want to investigate such objects. - Yes, exactly. So you could do math on it easily. - Math on it easily, yeah. - So it had an associated library of math operations. And effectively SciPy became an even larger set of math operations. So the key for me was, I was gonna write NumPy and then move SciPy to depend on NumPy. In fact, early on, one of the initial proposals was that we would just write SciPy and it would have the numeric object inside of it. And it'd be SciPy.array or something. That turned out to be problematic because numeric already had a little mini library of linear algebra and some functions. And it had enough momentum, enough users that nobody wanted to, they wanted backward compatibility. One of the big challenges of NumPy was that it had to be backward compatible with both numeric and numerary in order to allow both of those communities to come together. There was a ton of work in creating that backward compatibility. That also created echoes in today's object. Like some of the complexity in today's object is actually from that goal of backward compatibility to these other communities. Which, if you didn't have that, you'd do something different. Which is instructive because a lot of things are there. You're thinking, what is that there for? It's like, well, it's a remnant. It's an artifact of its historical existence. - By the way, I love the empathy and the lack of ego behind that. 'Cause I feel, you see that in the split in the JavaScript frameworks, for example, the arbitrary branching. - Right. - Is, I think in order to unite people, you have to kind of put your ego aside and truly listen to others. Like, what do you love about numerate? What do you love about numeric? Like actually get a sense, we're talking about languages earlier, sort of empathize to the culture of the people that love something about this particular API. Some, the naming style or the, the actual usage patterns and truly understand them. And so that you can create that same draw in the united thing. - I completely agree. And you have to also have enough passion that you'll do it. It can't be just like a perfunctory, oh yeah, so I'll listen to you. I'll listen to you and then, I'm not really that excited about it. So it really is an aspect, it's a philosophical, like there's a philia, there's a love, a esteeming of others. It's actually at the heart of what, it's sort of a life philosophy for me, right? That I'm constantly pursuing and that helped, absolutely helped. - Makes me wonder in a philosophical, like looking at human civilization as one object, it makes me wonder how we can copy and paste Travis's in this book. - Well, in some aspects, maybe. - Some aspects, right, right, exactly. Well, I, it's like-- - It's a good question. How do we teach this? How do we encourage it? How do we lift it? - Because so much of the software world, it's giant communities, right? But it seems like so much is moved by like little individuals. You talk about like Linus Torvald. It's like, can you, could you have not, could you have had Linux without him? Could you, it's like-- - Yeah, Guido and Python. - Guido and Python. - Guido and Python. I mean, the Sci-Fi community particularly, it's like I said, we wanted to build this big thing, but ultimately we didn't. What happened is we had Mavericks and champions like John Hunter, who created Matplotlib. We had Fernando Perez, who created IPython. And so we sort of inspired each other, but in the credit, there's sort of a culture of this selfless, give the stewardship mentality as opposed to ownership mentality, but stewardship and community-focused, but intentional work. Like not waiting for everybody else to do the work, but you're doing it for the benefit of others and not worried about what you're gonna get. You're not worried about the credit, you're not worried about what you're gonna get, you're worried about, I later realized that I have to worry a little about credit, not because I want the credit, because I want people to understand what led to the results. It's not about me, it's I wanna understand this is what led to the result. And this is what had no impact on the result. Let's promote, just like you said, I wanna promote the attributes that help make us better off. How do we make more of Wes McKinney? Like Wes McKinney was critical to the success of Python because of his creation of pandas, which is the roots of that were all the way back in numeric and num array and numpy, where numpy created an array of records. Wes started to use that almost like a data frame, except it's an array of records. And data frame, the challenge is, okay, if you wanna augment it at another column, you have to insert, you have to do all this memory movement to insert a column. Whereas data frames became, oh, I'm gonna have a loose collection of arrays. So it's a record of arrays that is a part of a data frame. And we thought about that back in the memory days, but Wes ended up doing the work to build it. And then also the operations that were relevant for data processing. What I noticed is just that each of these little things creates just another tick, another up. So numpy ultimately took a little while, about six months in, people started joining me. Francesc Alted, Robert Kern, Charles Harris. And these people are many of the unsung heroes, I would say. People who are, they sometimes don't get the credit they deserve because they were critical both to support, like, it's hard and you need some support, people need support. And I needed just encouragement. And they were helping, encouraged by contributing. And once, the big thing for me was when John Hunter, he had previously done kind of a simple thing called numerics to kind of, between numeric and number A, he had a little high level tool that would just select each one for Matplotlib. In 2006, he finally said, we're gonna just make numpy the dependency of Matplotlib. As soon as he did that, and I remember specifically when he did that, I said, okay, we've done it. That was when I knew we had succeeded, success. Before then, it was still, I didn't know, sure. But that kind of started a roller coaster. And then 2006 to 2009, and then I've been floored by what it's done. I knew it would help. I had no idea how much it would help. - And it has to do with, again, the language thing. It just, people started to think in terms of numpy. - Yes. - And that opened up a whole new way of thinking. And part of the story that you kind of mentioned, but maybe you can elaborate, is it seems like at some point in this story, Python took over science and data science. - Yes. - And bigger than that, the scientific community started to think like programmers or started to utilize the tools of computers to do, like at a scale that wasn't done with Fortran. Like at this gigantic scale, they started to opening their heart. And then Python was the thing. I mean, there's a few other competitors, I guess, but Python, I think, really, really took over. - I agree. There's a lot of stories here that are kind of during this journey, because this is sort of the start of this journey in 2005, '06. So my tenure committee, I applied for tenure in 2006, 2007. It came back, I split the department. I was very polarizing. I had some huge fans, and then some people said, "No way." Right, so I was a polarizing figure in the department. It went all the way up to the university president. Ultimately, my department chair had the sway. And they didn't say no, they said, "Come back in two years and do it again." And I went, "Eh." At that point, I was like, I mean, I had this interest in entrepreneurship, this interest in not the academic circles, not the, like, how do we make industry work? So I do have to give credit to that exploration of economics because that led me, oh, I had a lot of opinions. I was actually very libertarian at the time. And I still have some libertarian trends, but I'm more of a, I'm more of a collectivist libertarian. - So you value broadly, philosophically, freedom. - I value broadly, philosophically, freedom, but I also understand the power of communities, like the power of collective behavior. And so what's that balance, right, that makes sense? So by the time I was just, I gotta go out and explore this entrepreneur world. So I left academia, I said, "No, thanks." Called my friend, Eric, here, who had, his company was going, I said, "Hey, could I join you and start this trend?" And he, at that time, they were using Sci-Fi a lot, they were trying to get clients, and so I came down to Texas. And in Texas is where I sort of, it's my entrepreneur world, right? I left academia and went to entrepreneur world in 2007. So I moved here in 2007, kind of took a leap, knew nothing really about business, knew nothing about a lot of stuff there. There's, for a long time, I've kept some connections to a lot of academics, because I still value it, I still love the scientific tradition, I still value the essence and the soul and the heart of what is possible. Don't like a lot of the administration and the kind of, we can go into detail about why and where and how this happens, what are some of the challenges. - I mean, I don't know, but I'm with you. So I'm still affiliated with MIT, I still love MIT because there's magic there. There's people I talk to, like researchers, faculty, in those conversations and the whiteboard and just the conversation, that's magic there. All the other stuff, the administration, all that kind of stuff seems to, you don't wanna say too harshly criticize sort of bureaucracies, but there's a lag that seems to get in the way of the magic. And I'm still have a lot of hope that that can change because I don't often see that particular type of magic elsewhere in the industry. So we need that and we need that flame going. - I agree. - And it's the same thing as exactly as you said, it has the same kind of elements like the open source community does. But then if you, like the reason I stepped away, the reason I'm here just like you did in Austin is like if I wanna build one robot, I'll stay at MIT. But if I wanna build millions and make money enough to where I can explore the magic of that, then you can't. And I think that dance is-- - That translational dance has been lost a bit. - Yeah. - Right, and there's a lot of reasons for that. I'm certainly not an expert on this stuff. I can opine like anybody else, but I realized that I wanted to explore entrepreneurship which I, and really figure out, and it's been a driving passion for 20 years, 25 years. How do we connect capital markets and company, 'cause again, I fell in love with the notion, oh, profit seeking on its own is not a bad thing. It's actually a coordination mechanism for allocating resources that, in an emergent way, right, that respects everybody's opinions, right? So this is actually powerful. So I say all the time when I make a company and we do something that makes a profit, what we're saying is, hey, we're collecting of the world's resources and voluntarily people are asking us to do something they like. And that's a huge deal. And so I really like that energy. So that's what I came to do and to learn and to try to figure out, and that's what I've been kind of stumbling through for the past 14 years. - And that's 2007. - 2007, yeah. - And so you were still-- - So NumPy was just emerging, right? One of the things I had done, it's worth mentioning because it emphasizes the exploratory nature of my thinking at the time. I said, well, I don't know how to fund this thing. I've got a graduate student I'm paying for and I've got no funding for him. And I had done some fundraising from the public to try to get public fundraisers from my lab. I didn't really want to go out and just do the fundraising circuit the way it's traditionally done. So I wrote a book and I said, I'm gonna write a book and I'm gonna charge for it. It was called Guide to NumPy. And so ultimately NumPy became documentation-driven development because I basically wrote the book and made sure the stuff worked so the book would work. So it really helped actually make NumPy become a thing. So writing that book, and it was not a, I mean, it's not a page turner. Guide to NumPy is not a book you pick up and go, oh, this is great, over the fire. But it's where you could find the details. Like how'd all this work? - And a lot of people loved that book. - And so a lot of people ended up, so I said, look, I need to, so I'm gonna charge for it. And I got some flack for that. Not that much, just probably five angry messages, people yelling at me saying I was a bad guy for charging for this book. - Was one of them Richard Stallman? - No. - Just kidding. - No, I haven't really had any interaction with him personally, like I said. But there were a few, but actually surprisingly not. There was actually a lot of people like, no, it's fine, you can charge for a book. That's no big deal. We know that's a way you can try to make money around open source. So what I did, I did it in an interesting way. I said, well, kind of my ideas around IP law and stuff. I love the idea you can share something, you can spread it. Like once it's, the fact that you have a thing and copying is free, but the creation is not free. So how do you fund the creation and allow the copying? Right, and in software it's a little more complicated than that because creation is actually a continuous thing. You know, it's not like you build a widget and it's done. It's sort of a process of emerging and continuing to create. But I wrote the book and had this market-determined price thing. I said, look, I need, I think I said 250,000. If I make 250,000 from this book, I'll make it free. So as soon as I get that much money, or I said five years, right? So there's a time limit. - That's really cool. - Like forever. - I didn't know this story. - Yeah, so I released it on this. And it's actually interesting 'cause one of the people who also thought that was interesting ended up being Chris White, who was the director of DARPA project that we got funding through at Anaconda. And the reason he even called us back is 'cause he remembered my name from this book and he thought that was interesting. And so even though we hadn't gone to the demo days, we applied and the people said, yeah, nobody ever gets this without coming to the demo day first. This is the first time I've seen it. But it's because I knew Chris had done this, had this interaction. So it did have impact. I was actually really, really pleased by the result. I mean, I ended up in three years, I made 90,000. So sold 30,000 copies by myself. I just put it up on, used PayPal and sold it. And those are my first taste of kind of, okay, this can work to some degree. And all over the world, right? From Germany to Japan, it was actually, it did work. And so I appreciated the fact that PayPal existed and I had a way to make, to get the money. The distribution was simple. This is pre-Amazon book stuff. So it was just publishing a website. It was the popularity of Sci-Fi emerging and getting company usage. I ended up not letting it go to five years and not trying to make the full amount because, you know, a year and a half later, I was at Enthought. I had left academia as an Enthought and I kind of had a full-time job. And then actually what happened is the documentation people, there's a group that said, hey, we want to do documentation for Sci-Fi as a collective. And they were essentially needing the stuff in the book. And so they kind of asked, hey, can we just use the stuff from your book? And at that point I said, yeah, I'll just open it up. So that's, but it has served its purpose. And the money that I made actually funded my grad student. Like it was actually, you know, I paid him 25,000 a year out of that money. - The funny thing is if you do a very similar kind of experiment now with NumPy or something like it, you could probably make a lot more. - It's probably true. - Because of the tooling and the community building. - Yeah, I agree. - Like the, and social media, there's just a virality to that kind of idea. - I agree, there'd be things to do. I've thought about that. And really I've thought about a couple of books or a couple of things that could be done there. And I just haven't, right? Even, I tried to hire a ghostwriter this year too, to see if that would help, but it didn't. But part of my problem is this, I've been so excited by a number of things that stemmed from that. So I came here, worked at Enthought for four years. Graciously, you know, Eric made me president and we started to work closely together. We actually helped him buy out his partner. It didn't end great. Like unfortunately Eric and I aren't real, aren't friends now. I still respect him. I have a lot, I wish we were, but he didn't like the fact that I, that Peter and I started Anaconda, right? That was not, I mean, so there's two sides to that story. So I'm not gonna go into it, right? - Sure, but you, as human beings and you wish you still could be friends. - I do, I do. It saddens me. - I mean, that's a story of great minds building great companies. Somehow it's sad that when there's that kind of. - And I hold him in esteem. I'm grateful for him. I think he's, they're doing, you know, Enthought still exists. They're doing great work helping scientists. They still run the SciPy conference. They're in the, they have an R&D platform they're selling now that's a tool that you can go get today, right? So they've been, Enthought has played a role in the SciPy, in supporting the community around SciPy. I would say. They ended up not being able to, they ended up building a tool suite to write GUI applications. Like that's where they could actually make that the business could work. And so the supporting SciPy and NumPy itself wasn't as possible. Like they didn't, they tried. I mean, it was not just because, it was just 'cause the business aspect. So, and then I wanted to build a company that could do, that could get venture funding, right? Better for worse. I mean, that's a longer story. We could talk a lot about that, but. - And that's where Anaconda came to be. - That's where Anaconda came to be. - So let me ask you, it's a little bit for fun because you built this amazing thing. And so let's talk about like an old warrior looking over old battles. (Neil laughs) You know, there's a sad letter in 2012 that you wrote to the NumPy mailing list announcing that you're leaving NumPy. And some of the things you've listed is some of the things you regret or not regret necessarily, but some things to think about. If you could go back and you could fix stuff about NumPy or both sort of in a personal level, but also like looking forward, what kind of things would you like to see changed? - Good question. So I think there's technical questions and social questions right there. First of all, you know, I wrote NumPy as a service and I spent a lot of time doing it and then other people came help make it happen. NumPy succeeded because the work of a lot of people, right? So it's important to understand that. I'm grateful for the opportunity, the role I could play and grateful that things I did had an impact, but they only had the impact they had because the other people that came to the story. And so they were essential. But the way data types were handled, the way data types, we had array scalers, for example, that are really just a substitute for a type concept. Right, so we had array scalers or actual Python objects so that there's for every, for a 32 bit float or a 16 bit float or a 16 bit integer, Python doesn't have a natural, it's just one integer, it's one float. Well, what about these lower precision types, these larger precision types? So we had them in NumPy so that you could have a collection of them, but then have an object in Python that was one of them. And there's questions about, like in retrospect, I wouldn't have created those if I'd improved the type system. And like made the type system actually a Python type system as opposed to currently, it's a Python one level type system. I don't know if you know the difference between Python one, Python two, it's kind of technical, kind of depth, but Python two, one of its big things that Guido did, it was really brilliant, it was the actually, Python one, all classes, new objects were one. So he was a user, wrote a class, it was an instance of a single Python type called the class type. In Python two, he used a meta typing hook to actually go, oh, we can extend this and have users write classes that are new types. So he was able to have your user classes be actual types and the Python type system got a lot more rich. I barely understood that at the time that NumPy was written and so I essentially, in NumPy, created a type system that was Python one era. It was every D type is an instance of the same type as opposed to having new D types be really just Python types with additional metadata. - What's the cost of that? Is it efficiency, is it usability? - It's usability primarily. The cost isn't really efficiency, it's the fact that it's clumsy to create new types. It's hard, and then one of the challenges, you wanna create new types, you wanna quaternion type or you wanna add a new posit type or you wanna, so it's hard. Now, if we had done that well, when Numba came on the scene, we could actually compile Python code, it would integrate with that type system much cleaner and now all of a sudden you could do gradual typing more easily. You could actually have Python when you add Numba plus better typing, could actually be a, you'd smooth out a lot of rough edges. - But there's already, there's like, but are you talking about from the perspective of developers within NumPy or users of NumPy? - Developers of new, not really users of NumPy so much, it's the development of NumPy. - So you're thinking about like how to design NumPy so that its contributors-- - Yeah, the contributors, it's easier. - It's easier. - It's less work to make it better and to keep it maintained and where that's impacted things, for example, is the GPU. Like all of a sudden GPUs start getting added and we don't have them in NumPy. Like NumPy should just work on GPUs. The fact that we have to download a whole other object called Coupie to have arrays on GPUs is just an artifact of history. Like there's no fundamental reason for it. - Well, that's really interesting if we could sort of go on that tangent briefly is you have PyTorch and other library like TensorFlow that basically tried to mimic NumPy. Like you've created a sort of platonic form of what a multi-dimensional-- - Yeah, exactly. Well, and the problem was they didn't realize that. - Yeah. - The platonic form has a lot of edges. They're like, "Well, we should cut those out before we present it." - So I wonder if you can comment, is there like a difference between their implementations? Do you wish that they were all using NumPy or like in this abstraction of GPU? And sorry to interrupt that there's GPUs, ASICs, there might be other neuromorphic computing, there might be other kind of, or the aliens will come with a new kind of computer, like an abstraction that NumPy should just operate nicely over the things that are more and more and smarter and smarter with this multi-dimensional arrays. - Yeah, yeah. There's several comments there. We are working on something now called data-apis.org, data-api.org, you can go there today. And it's our answer, it's my answer. It's not just me, it's me and Rolf and Athen and Aaron and a lot of companies are helping us at Quantsight Labs. It's not unifying all the arrays, it's creating an API that is unified. So we do care about this and we're trying to work through it. I actually had the chance to go and meet with the TensorFlow team and the PyTorch team and talk to them after exiting Anaconda. Just talking to them, 'cause the first year after leaving Anaconda in 2018, I became deeply aware of this and realized that, oh, this split in the array community that exists today makes what I was concerned about in 2005 pretty parochial. It's a lot worse, right? Now there's a lot more people, so perhaps the industry can sustain more stacks, right? There's a lot of money, but it makes it a lot less efficient. But I've also learned to appreciate, it's okay to have some competition, it's okay to have different implementations, but it's better if you can at least refactor some parts. I mean, you're gonna be more efficient if you can refactor parts. - It's nice to have competition over things, over what is nice to have competition. - They're innovative. - Yeah, innovative and then maybe on the infrastructure, whatever, however you define infrastructure, that maybe it's nice to have come together. - Exactly, I agree. And I think, but it was interesting to hear the stories. I mean, TensorFlow came out of a C++ library, Jeff Dean wrote, I think, that was basically how they were doing inference, right? And then they realized, oh, we could do this TensorFlow thing. That C++ library, then what was interesting to me was the fact that both Google and Facebook did not, it's not like they supported Python or NumPy initially, they just realized they had to. They came to this world and then all these were like, hey, where's the NumPy interface? Oh, and then they kind of came late to it and then they had these bolt-ons. TensorFlow's bolt-on, I don't mean to offend, but it was so bad. It's the first time that I, I'm usually, I mean, one of the challenges I have is I don't criticize enough, 'cause in the sense that I don't give people input enough. - I think it's universally agreed upon that the bolt-ons on TensorFlow. - When I went to, it was a talk given at Mallorca in Spain and a great guy came and gave a talk. I said, you should never show that API again at a PyData conference. Like that was, that's terrible. Like you're taking this beautiful system we've created and like you're corrupting all these poor Python people, forcing them to write code like that or thinking they should. Fortunately, they adopted Keras as their, and Keras is better. And so Keras TensorFlow is fine, is reasonable. But they bolted it on. Facebook did too. Like Facebook had their own C++ library for doing inference and they also had the same reaction, they had to do this. One big difference is Facebook, maybe because the way it's situated in part of FAIR, part of their research library, TensorFlow is definitely used and they have to make, they couldn't just open it up and let the community change what that is 'cause I guess they were worried about disrupting their operations. Facebook's been much more open to having community input on the structure itself. Whereas Google and TensorFlow, they're really eager to have community users. People use it and build the infrastructure, but it's much more walled. Like it's harder to become a contributor to TensorFlow. - And it's also, this is a very difficult question to answer and I don't mean to be throwing shade at anybody, but you have to wonder, it's the Microsoft question, of when you have a tool like PyTorch or TensorFlow, how much are you tending to the hackers and how much are you tending to the big corporate clients? - Correct. - And so like the ones that, do you tend to the millions of people that are giving you almost no money or do you tend to the few that are giving you a ton of money? I tend to stand with the people. - Right. - 'Cause I feel like if you nurture the hackers, you will make the right decisions in the longterm that will make the companies happy. - I lean that way too. I totally agree. - But then you have to find the right dance. - But it's a balance. 'Cause you can lean to the hackers and run out of money. - Yeah, exactly. Exactly. Which has been some of the challenge I've faced. - Yes. - In the sense that, I would look at some of the experiments like NumPy, the fact that we have the split is a factor of I wasn't able to collect more money towards NumPy development. - Yeah. - Right, I mean, I didn't succeed in the early days of getting enough financial contribution to NumPy so they make me work on it. I couldn't work on it full time. I had to just catch an hour here, an hour there. And I basically not like that. Like I've wanted to be able to do something about that for a long time and trying to figure out well there's lots of ways. I mean, possibly one could say, we had an offer from Microsoft early days of Anaconda. 2014 they offered to come buy us, right? The problem was the right people at Microsoft didn't offer to buy us. And they were still, it was really, we were like a second, they had really bought, they just bought R, the R company called, it was not RStudio but it was another R company that was emergent. And it was kind of a, well, we should also get a Python play. But they were really doubling down on R, right? And so it was like-- - It was where you would go to die. So it's not, it wasn't, it was before Satya was there. - Satya had just started. - Just started. - Right, and the offer was coming from someone two levels down from him. - Gotcha. - Right, and if it had come from Scott Guthrie, so I got a chance to meet Scott Guthrie, great guy, I like him. If it had offered to come from him, probably would be at Microsoft right now. - That'd be fascinating. That would be really nice actually, especially given what Microsoft has since done for the open source community and all those things. - Yes, I think they're doing well. I really like some of the stuff they've been doing. They're still working, and they've hired Guido now, and they've hired a lot of Python developers. - Wait, Guido's not at Microsoft? - Yeah, he works at Microsoft. Which means he retired, then he came out of retirement, and he's working on-- - I was just talking to him and he didn't mention this part. - Well. - I should investigate this further. 'Cause I know he loved Dropbox, but I wasn't sure what he was doing, who he was up to. - Well, he was kind of saying he would retire, and it's literally been five years since I last sat down and really talked to Guido. Guido's a technology expert. He's a, so I came, I was excited because I'd finally figured out the type system for NumPy. I wanted to kind of talk about that with him, and I kind of overwhelmed him. - Could you stay in that, just for a brief moment, 'cause you're a fascinating person in the history of programming. He is a fascinating person. What have you learned from Guido about programming, about life? - Yeah, yeah, a lot, actually. I've been a fan of Guido's. We have a chance to talk. Some, I wouldn't say, we talk all the time, not really at all. He may, but we talk enough to, I respect his, like when I first started NumPy, one of the first things I did was I had, I asked Guido for a meeting with him and Paul Dubois in San Mateo. And I went and met him for lunch. And basically to say, maybe we can actually, part of the strategy for NumPy was to get it into Python 3, and maybe be part of Python. And so we talked about that. - That's a cool conversation. - And about that approach, right? - I would have loved to be a fan in the wild. - That was good. And over the years for Guido, I learned, so he was open. Like he was willing to listen to people's ideas, right? And over the years. Now generally, I'm not saying universally that's been true, but generally that's been true. So he's willing to listen. He's willing to defer. Like on the scientific side, he would just kind of defer. He didn't really always understand what we were doing. And he'd defer. One place where he didn't enough was we missed a matrix multiply operator. Like that finally got added to Python, but about 10 years later than it should have. But the reason was because nobody, it takes a lot of effort. And I learned this while I was writing NumPy. I also wrote tools to, I became a Python dev, and I added some pieces of Python. Like the memory view object. I wanted the structure of NumPy into Python. So we didn't get NumPy into Python, but we got the basic structure of it into Python. So you could build on it. Nobody did for a while, but eventually database authors started to. And it's a lot better, they did. And also Antoine Petreau and Stephan Krah actually fixed the memory view object. 'Cause I wrote the underlying infrastructure in C, but the Python exposure was terrible until they came in and fixed it. Partly because I was writing NumPy, and NumPy was the Python exposure. I didn't really care about if you didn't have NumPy installed. Anyway, Guido opened up ideas, technologically brilliant. Like really, I really got a lot of respect for him when I saw what he did with this type class merger thing. It was actually tricky. And then willing to share. Willing to share his ideas. So the other thing, early on in 1998, I said I wrote my first extension module. The reason I could is 'cause he'd written this blog post on how to do reference counting. And without it, I would have been lost. But he was willing to at least try to write this post. And so he's been motivated early on with Python. It was like computer science for everybody. He kind of had this early on desire to, oh, maybe we should be pushing programming to more people. So he had this populist notion, I guess, or populist sense. To learn that there's a certain skill, and I've seen it in other people too, of engaging with contributors sufficiently to, 'cause when somebody engages with you and wants to contribute to you, if you ignore them, they go away. So building that early contributor base requires real engagement with other people. And he would do that. - Can you also comment on this tragic stepping down from his position as the benevolent dictator for life over the wars? - The Walrus operator? - The Walrus operator was the last battle. I don't know if that's the cause of it, but there's this, for people who don't know, you can look up, there's the Walrus operator, which looks like a colon and equal sign. - Yeah, colon, equal sign. And it actually does maybe the thing that an equal sign should be doing. - Yeah, maybe, right, exactly. - But it's just historically, equal sign means something else. It just means assignment. So he stepped down over this. What do you think about the pressure of leadership? - It's something that, you mentioned the letter I wrote in NumPy at the time. That was a hard time, actually. I mean, there's been really hard times. It was hard. You get criticized, right, and you get pushed, and you get, not everybody loves what you do. Like, any time you do anything that has impact at all, you're not universally loved, right? You get some real critics. And that's an important energy because it's impossible if you did everything right. You need people to be pushing. But sometimes people can get mean, right? People can, I prefer to get people to benefit the doubt. I don't immediately assume they have bad intentions. And maybe for other, you know, maybe that doesn't happen for everybody, for whatever reason, their past, their experience with people, they sometimes have bad, so they immediately attribute to you bad intentions. You're like, where did this come from? I mean, I'm definitely open to criticism, but I think you're misinterpreting the whole point. 'Cause I would get that. You know, certainly when I started Anaconda, you know, I've been, sometimes I say to people, I know I'm, I care enough about entrepreneurship to make some open source people uncomfortable. And I care enough about open source to make investors uncomfortable. So I sort of, you know, create, you create kind of doubters on both sides. - So when you have, and this is just a plea to the listener and the public. I've noticed this too, that there's a tendency, and social media makes this worse, when you don't have perfect information about the situation, you tend to fill the gaps with the worst possible, or at least the bad story that fills those gaps. And I think it's good to live life, maybe not fully naively, but filling in the gaps with the good, with the best, with the positive, with the hopeful explanation of why you see this. So if you see somebody like you trying to make money on a book about NumPy, there's a million stories around that that are positive, and those are good to think about, to project positive intent on other people. Because for many reasons, usually because people are good and they do have good intent. And also when you project that positive intent, people will step up to that too. - Yes, it's a great point. - It has this kind of viral nature to it. And of course, what Twitter early on figured on, Facebook, is that they can make a lot of money in engagement from the negative. - Yes. - And so like, there's this, we're fighting this mechanism. - I agree. - Which is challenging. - It's like easier. - It's just easier to be. - To be negative. - And then for some reason, something in our minds really enjoys sharing that and getting all excited about the negativity. - We do, yeah. - But-- - Some protective mechanism perhaps that we're gonna get eaten if we don't. - Exactly, for us to be effective as a group of people in a software engineering project, you have to project positive intent, I think. - I totally agree, totally agree. And I think that's very, and so that happens in this space. But Python has done a reasonable job in the past, but here is a situation where I think it started to get this pressure where it didn't. I really didn't know enough about what happened. I've talked to several people about it, and I know most of the steering committee members today, one person nominated me for that role, but it's the wrong role for me right now, right? I have a lot of respect for the Python developer space and the Python developers. I also understand the gap between computer science Python developers and array programming developers or science developers. And in fact, Python succeeds in the array space the more it has people in that boundary. And there's often very few. Like I was playing a role in that boundary, and working like everything to try to keep up with even what Gita was saying. Like I'm a C programmer, but not a computer scientist. Like I was an engineer and physicist and mathematician, and I didn't always understand what they were talking about and why they would have opinions the way they did. So you have to listen and try to understand. Then you also have to explain your point of view in a way they can understand. And that takes a lot of work. And that communication is always the challenge. And it's just what we're describing here about the negativity is just another form of that. Like how do we come together? And it does appear we're wired anyway to at least have a, there's a part of us that will enemy, friend, enemy. And we see, yeah, it's like, why are we wiring on the enemy front? - Yeah. - So why are we pushing that? Why are we promoting that so deeply? - Assume friend until proven otherwise. - Yes, yes. - So 'cause you have such a fascinating mind and all of this, let me just ask you these questions. So one interesting side on the Python history is the move from Python two to Python three. You mentioned move from Python one to Python two, but the move from Python two to Python three is a little bit interesting because it took a very long time. It broke in quite a small way backward compatibility, but even that small way seemed to have been very painful for people. Is there lessons you draw-- - Oh, man, tons of lessons. - From how long it took and how painful it seemed to be? - Yeah, tons of lessons. Well, I mentioned here earlier that NumPy was written in 2005. It was in 2005 that I actually went to Guido to talk about getting NumPy into Python three. Like my strategy was to, oh, we were moving to Python three, let's have that be, and it seems funny in retrospect because like, wait, Python three, that was in 2020, right? When we finally ended support for Python two, or at least 2017. The reason it took a long time, a lot of time, I think it was because, well, one of the things is there wasn't much to like about Python three. 3.0, 3.1, it really wasn't until 3.3. Like I consider Python 3.3 to be Python 3.0. But it wasn't until Python 3.3 that I felt there was enough stuff in it to make it worth anybody using it, right? And then 3.4 started to be, oh, yeah, I want that. And then 3.5 as the matrix multiply operator, and now it's like, okay, we gotta use that. - Plus the libraries that started leveraging some of the features of Python three. - Exactly. So it really, the challenge was, it was, but it also illustrated a truism that when you have inertia, when you have a group of people using something, it's really hard to move them away from it. You can't just change the world on them. And Python three, it made some, I think it fixed some things Guido had always hated. I think he didn't like the fact that print was a statement. He wanted to make it a function. But in some sense, that's a bit of gratuitous change to the language. And you could argue, and people have. But one of the challenges was there wasn't enough features and too many just changes without features. And so that empathy for the end user as to why they would switch wasn't there. I think also it illustrated just the funding realities. Like Python wasn't funded. Like it was also a project with a bunch of volunteer labor, right? It had more people, so more volunteer labor, but it was still, it was funded in the sense that at least Guido had a job. And I've learned some of the behind the scenes on that now since, since talking to people who have lived through it. And maybe not on air, we can talk about some of that. But it's interesting to see, but Guido had a job, but his full-time job wasn't just work on Python. Like he had other things to do. - Just wild. - It is wild, isn't it? - It's wild how few people are funded. - Yes. - And how much impact they have. - Yes. - Maybe that's a feature and not a bug, I don't know. - Maybe, yes, exactly. At least early on, it's sort of, I know, yeah. - It's like Olympic athletes are often severely underfunded, but maybe that's what brings out the greatness. - Yes, correct, no, exactly. Maybe this is the essential part of it. 'Cause I do think about that in terms of, I currently have an incubator for open source startups. Like what I'm trying to do right now is create the environment I wished had existed when I was leaving academia with NumPy and trying to figure out what to do. I'm trying to create those opportunities and environments. So, and that's what drives me still, is how do I make the world easier for the open source entrepreneur? - So let me stay, I mean, I could probably stay at NumPy for a long time, but this is fun question. So Andrej Kapothy leads the Tesla Autopilot team, and he's also one of the most like legit programmers I know. It's like he builds stuff from scratch a lot, and that's how he builds intuition about how a problem works. He just builds it from scratch, and I always love that. And the primary language he uses is Python for the intuition building. But he posted something on Twitter saying that they got a significant improvement on some aspect of their like data loading, I think, by switching away from np.squareroot. So the NumPy's implementation of square root to math.squareroot. And then somebody else commented that you can get even a much greater improvement by using the vanilla Python square root, which is like-- - Power 0.5. - Power 0.5. - Yeah, yeah. - And it's fascinating to me. I just wanted to-- So that was-- - Absolutely. - That was some shade throwing at some-- - No, no, and yes, we're talking about. - It's a good way to ask the trade-off between usability and efficiency broadly in NumPy, but also on these like specific weird quirks of like a single function. - Yep, so on that point, if you use a NumPy math function on a scalar, it's gonna be slower than using a Python function on that scalar. - Yeah. - But because the math object in NumPy is more complicated, right? 'Cause you can also call that math object on an array. And so effectively, it goes through a similar machine. There aren't enough of the, which you would do, and you could do like checks and fast paths. So yeah, if you're basically doing a list, if you run over a list, in fact, for problems that are less than 1,000, even maybe 10,000 is probably the, if you're going more than 10,000, that's where you definitely need to be using arrays. But if you're less than that, and for reading, if you're doing a reading process, and essentially it's not compute bound, it's IO bound, and so you're really taking lists of 1,000 at a time and doing work on it, yeah, you could be faster just using Python, straight up Python. - See, but also-- - And then-- - This is the, sorry to interrupt, but there's the fundamental questions when you look at the long arc of history, it's very possible that np.squareroot is much faster. - It could be. - So in terms of don't worry about it, it's the evils of over-optimization, or whatever, all the different quotes around that, is sometimes obsessing about this particular little quark is not sufficient. - For somebody like, if you're trying to optimize your path, I mean, I agree, premature optimization creates all kinds of challenges, right, because now, but you may have to do it. - I believe the quote is, it's the root of all evil. - It's the root of all evil, right. Let's give Donald Knuth, I think, or we should go to somebody else. - Well, Doc Knuth is kind of like Mark Twain, people just attribute stuff to him, I don't-- - And it's fine, because he's brilliant, so. No, I was a LaTeX user myself, and so I have a lot of respect, and you did more than that, of course, but yeah, someone I really appreciate in the computer science space. Yeah, I don't, I think that's appropriate, there's a lot of little things like that, where people actually, if you understood it, you go, yeah, of course that's the case. And the other part, the other part I didn't mention, and Numba was a thing we wrote early on, and I was really excited by Numba, because it's something we wanted, it was a compiler for Python syntax, and I wanted it from the beginning of writing NumPy, because of this function question, like, taking, the power of arrays is really that you can write functions using all of it. It has implicit looping, right, so you don't worry about, I write this N-dimensional for loop with four loops, for four statements, you just say, oh, big four-dimensional array, I'm gonna do this operation, this plus, this minus, this reduction, and you get this, it's called vectorization in other areas, but you can basically think at a high level and get massive amounts of computation done, with the added benefit of, oh, it can be parallelized, easily, it can be put in parallel, you don't have to think about that. In fact, it's worse to go decompose your, you write the for loops, and then try to infer parallelism from for loops. So that's actually a harder problem, than to take the array problem, and just automatically parallelize that problem. That's what, and so functions in NumPy are called universal functions, Ufuncs, so square root is an example of a Ufunc, there are others, sine, cosine, add, subtract, in fact, one of the first libraries to SciPy was something called special, where I added Bessel functions, and all these special functions that come up in physics, and I added them as Ufuncs, so they could work on arrays. So I understood Ufuncs very, very well from day one inside of Numeric, that was one of the things we tried to make better in NumPy was how do they work, can they do broadcasting, what does broadcasting mean? But one of the problems is, okay, what do I do with a Python scaler? So what happens, the Python scaler gets broadcast to a zero dimensional array, and then it goes through the whole same machinery as if it were a 10,000 dimensional array, and then it kind of unpacks the element, and then does the addition. That's not to mention the function it calls, in the case of square root, is just the CLIB square root. In some cases, like Python's Power, there's some optimizations they're doing that can be faster than just calling the CLIB square root. - In the interpreter, or in the-- - No, in the C code, in the Python runtime. - In the Python runtime, so they really optimize it, and they have the freedom to do that, 'cause they don't have to worry about-- - 'Cause it's just a scaler. - It's just a scaler. - They don't have to worry about the fact that, oh, this could be an object with many pieces. The Ufunc machiner is also generic, in the sense that typecasting and broadcasting, broadcasting's idea of, I'm gonna go, I have a zero dimensional array, I have a scaler with a four dimensional array, and I add them. Oh, I have to kind of coerce the shape of this guy to make it work against the whole four dimensional array. So it's the idea of, I can do a one dimensional array against a two dimensional array, and have it make sense. - Well, that's what NumPy does, is it challenges you to reformulate, rethink your problem, as a multi-dimensional array problem, versus move away from scalers completely. - Right, exactly. - Yeah. - Exactly, in fact, that's where some of the edge cases, boundaries are, is that, well, they're still there, and this is where array scalers are particular. So array scalers are particularly bad, in the sense that they were written so that you could optimize the math on them, but that hasn't happened. And so their default is to coerce the array scaler to a zero dimensional array, and then use the NumPy machinery. That's what, and you could specialize, but it doesn't happen all the time. So in fact, when we first wrote Numba, we do comparisons and say, look, it's a thousand X speed up. We're lying a little bit in the sense that, well, first do the 40 X slowdown of using array scalers inside of a loop. 'Cause if you used to use Python scalers, you'd already be 10 times faster. But then we would get a hundred times faster over that using just compilation. But what we do is compile the loop from out of the interpreter to machine code. And then that's always been the power of Python, is this extensibility so that you can, 'cause people say, oh, Python's so slow. Well, sure, if you do all your logic in the runtime of the Python interpreter, yeah. But the power is that you don't have to. You write all the logic, which you do in the high level is just high level logic. And the actual calls you're making could be on gigabyte arrays of data, and that's all done at compiled speeds. And the fact that integration is, one, can happen, but two, is separable. That's one of the, the language like Julia says, we're gonna be all in one. You can do all of it together. And then there's, the jury's out, is that possible? I tend to think that you're gonna, there's separate concerns there. You wanna precompile, and generally you will wanna precompile some of your loops. Like SciPy is a compilation step. To install SciPy, it takes about two hours. If you have many, many machines, maybe you can get it down to one hour. But to compile those libraries takes a while. You don't wanna do that at runtime. You don't wanna do that all the time. You wanna have this precompiled binary available that you're then just linking into. So there's real questions about the whole, source code, code is, running binary code is more than source code. It's creating object code, it's the linker, it's the loader, it's the how does that interpret it inside of a virtual memory space. There's a lot of details there that actually, I didn't understand for a long time until I read books on the topic. And it led to, the more you know, the better off you are, and you can do more details. But sometimes it helps with abstractions too. - Well, the problem, as we mentioned earlier with abstractions is you kind of sometimes assume that whoever implemented this thing had your case in mind and found the optimal solution. - Yes. - Or like you assume certain things. I mean, there's a lot of, - Correct. - One of the really powerful things to me early on, I mean, it sounds silly to say, but with Python, probably one of the reasons I fell in love with it is dictionaries. - Yes. - So obviously probably most languages have some, - Mapping concept. - Some mapping concept, but it felt like it was a first-class citizen. And it was just my brain was able to think in dictionaries. But then there is the thing that I guess I still use to this day is order dictionaries, because that seems like a more natural way to construct dictionaries. - Yeah. - And from a computer science perspective, the running time cost is not that significant. There's a lot of things to understand about dictionaries that the abstraction kind of doesn't necessarily incentivize you to understand. - Right, do you really understand the notion of a hash map and how that dictionary is implemented? But you're right, dictionaries are a good example of an abstraction that's powerful. And I agree with you, I love dictionaries too. Took me a while to understand that once you do, you realize, oh, they're everywhere. And Python uses them everywhere too. Like it's actually constructed, that one of the foundational things is dictionaries, and it does everything with dictionaries. - Yeah. - So it is, it's powerful. Order dictionaries came later, but it is very, very powerful. It took me a little while coming from just the array programming entirely to understand these other objects, like dictionaries and lists and tuples and binary trees. Like I said, I wasn't a computer scientist, but I studied arrays first. And so I was very array-centric. And you realize, oh, these others don't have purposes and value actually. I agree. - There's a friendliness about, like one way to think about arrays is, arrays are just like full of numbers, but to make them accessible to humans and make them less error-prone to human users, sometimes you want to attach names, human interpretable names that are sticky to those arrays. So that's how you start to think about dictionaries. - Yeah, that's a good point. - You start to convert numbers into something that's human interpretable. And that's actually the tension I've had with NumPy because I've built so much tooling around human interpretability and also protecting me from a year later not making the mistakes by being, I wanted to force myself to use English versus numbers. - Yes, so there's a project called Labeled Arrays. Like very early it was recognized that, oh, we need, we're indexing NumPy with just numbers, all the columns and particularly the dimensions. I mean, if you have an image, you don't necessarily need to label each column or row, but if you have a lot of images or you have another dimension, you'd at least like to label the dimension as this is X, this is Y, this is Z, or this is, give us some human meaning or some domain-specific meaning. That was one of the impetuses for pandas actually, was just, oh, we do need to label these things. And Labeled Array was an attempt to add that, like a lighter weight version of that. And there's been, like that's an example of something I think NumPy could add, could be added to NumPy. But one of the challenges again, how do you fund this? Like I said, one of the tragedies I think is that, so I never had the chance to, I was never paid to work on NumPy, right? So I've always just done it in my spare time, always taken from one thing, taken from another thing to do it. And at the time, I mean, today, it would be the wrong time today, like paying me to work on NumPy now would not be a good use of effort. But we are finally at QuantSight Labs, I'm actually paying people to work on NumPy and SciPy, which is I'm thrilled with, I'm excited by. I've wanted to do that. That's what I always wanted to do from day one, it just took me a while to figure out a mechanism to do that. - Even like in the university setting, respecting that, like pushing students, young minds, the young graduate students to contribute and then figuring out financial mechanisms that enable them to contribute and then sort of reward them for their innovative scientific journey, that would be nice. But then also there's just a better allocation of resources. It's 20 year anniversary since 9/11, and I was just looking, we spent over $6 trillion in the Middle East after 9/11 in the various efforts there. And sort of to put politics and all that aside, it's just, you think about the education system, all the other ways we could have possibly allocated that money. To me, to take it back, the amount of impact you would have by allocating a little bit of money to the programmers that build the tools that run the world, it's fascinating. I mean-- - It is. - I don't know, I think, again, there is some aspect to being broke as somewhat of a feature, not a bug, that you make sure that your-- - You still manage that. - Right, no, I know. But I don't think that's a big part. So it's like, I think you can have enough money and actually be wealthy while maintaining your values. - Agreed, agreed. There's an old adage that nations that trade together don't go to war together. I've often thought about nations that code together. - Yeah, code together. (laughing) - Because one of the things I love about open source is it's global, it's multinational. There aren't national boundaries. One of the challenges with business and open source is the fact that, well, business is national. Businesses are entities that are recognized in legal jurisdictions, right, and have laws that are respected in those jurisdictions, and hiring, and yet the open source ecosystem is not, it's not there. Like, currently, one of the problems we're solving is hiring people all over the world, right, 'cause we, it's a global effort. And I've had the chance to work, and I've loved the chance. I've never been to, like, Iran, but I once had a conference where I was able to talk to people there, right, and talk to folks in Pakistan. Never been there, but we had a call, and there were people there, like, just scientists and normal people, and, you know, and it's, there's a certain amount of humanizing, right, that gets away from the, like, we often get the memes of society that bubble up and get discussed, but the memes are not even an accurate reflection of the reality of what people are. - Well, if you look at the major power centers that are leading to something like cyber war in the next few decades, it's the United States, it's Russia, and China. And those three countries in particular have incredible developers. So if they work together, I think that's one way, the politicians can do their stupid bickering, but, like, there's a layer of infrastructure, of humanity, if they collaborate together, that I think can prevent major military conflict, which would, I think, most likely happen at the cyber level versus the actual hot war level. - You're right. No, I think that's good prediction. Nations that code together don't go to war together. - Don't go to war together. That's a hope, right? That's one of the philosophical hopes, but yeah. - So you mentioned the project of Numba, which is fascinating. So from the early days, there was kind of a pushback on Python that it's not fast. You know, you see C, if you wanna write something that's fast, you use C, C++. If you wanna write something that's usable and friendly, but slow, you use Python. And so what is Numba? What is its goal? How does it work? - Great, yeah. Yes, that's what the argument. And the reality was people would write high-level code and use compiled code, but there's still user story, use cases, where you want to write Python, but then have it still be fast. You still need to write a for loop. Like before Numba, it was always don't write a for loop. You know, write it in a vectorized way, you know, put it in an array. And often that can make a memory trade-off. Like quite often you can do it, but then you make maybe use more memory because you have to build this array of data that you don't necessarily need all the time. So Numba was, it started from a desire to have kind of a vectorized that worked. A vectorized was a tool in NumPy, it was released. You give it a Python function and it gave you a universal function, a Ufunc that would work on arrays. So you get a function that just worked on a scalar. Like you could make a, like the classic case was a simple function that had an if then statement in it. So a sine X over X function, sinc function. If X equals zero, return one, otherwise do sine X over X. The challenge is you don't want that loop to have one in Python. So you want a compiled version of that. But the Ufunc, the vectorized in NumPy would just give you a Python function. So it'd take the array of numbers and at every call do a loop back into Python. So it was very slow. It gave you the appearance of a Ufunc, but it was very slow. So I always wanted a vectorized that would take that Python scalar function and produce a Ufunc working on binary native code. So in fact, I had somebody work on that with PyPy and see if PyPy could be used to produce a Ufunc like that early on in 2009 or something like that, 2010. It didn't work that well. It was kind of pretty bulky. But in 2012, Peter and I had just started Anaconda. We had, I had just, I'd learned to raise money. That's a different topic, but I'd learned to, you know, raise money from friends, family, and fools, as they say. (laughing) - That's a good line. - So we were trying to do something. We were trying to change the world. Peter and I are super ambitious. We wanted to make array computing, and we had ideas for really what's still, what's still the energy right now. How do you do at scale data science? And we had a bunch of ideas there, but one of them, I had just talked to people about LLVM, and I was like, there's a way to do this. I just, I went, I heard about my friend Dave Beasley at a compiler course. So I was looking at compilers, like, and I realized, oh, this is what you do. And so I wrote a book about it. And I was like, oh, this is what you do. And so I wrote a version of Numba that just basically mapped Python bytecode to LLVM. - Nice. - Right, so, and the first version is like, this works, and it produces code that's fast. This is cool for, you know, obviously a reduced subset of Python. I didn't support all the Python language. There had been efforts to speed up Python in the past, but those efforts were, I would say, not from the array computing perspective, not from the perspective of wanting to produce a vectorized improvement. They were from a perspective of speeding up the runtime of Python, which is fundamentally hard, because Python allows for some constructs that aren't, you can't speed up. Like, it's generic, you know, when it does this variable. So I, from the start, did not try to replicate Python's semantics entirely. I said, I'm gonna take a subset of the Python syntax and let people write syntax in Python, but it's kind of a new language, really. - So it's almost like for loops, like focusing on for loops. - For loops, scalar arithmetic, you know, typed, you know, really typed language, a typed subset. That was the key. So, but we wanted to add inference of types. So you didn't have to spell all the types out, because when you call a function, so Python is typed. It's just dynamically typed. So you don't tell it what the types are, but when it runs, every time an object runs, there's a type for the variables. You know what it is. And so that was, the design goals of Numba were to make it possible to write functions that could be compiled and have them used for NumPy arrays. Like they needed to support NumPy arrays. - And so how does it work? Do you add a comment within Python that tells it to do, like how do you help out a compiler? - Yeah, so there isn't much actually. You don't, it's kind of magical in the sense that it just looks at the type of the objects and then does type inference to determine any of the other variables it needs. And then it was also, because we had a use case that could work early, like one of the challenges of any kind of new development is if you have something that to make it work, it was gonna take you a long time, it's really hard to get it off the ground. If you have a project where there's some incremental story, it can start working today and solve a problem, then you can start getting it out there, getting feedback. Because Numba today, now Numba is nine years old today, right, the first two, three versions were not great, right? But they solved a problem and so people could try it and we could get some feedback on it. - Not great in that it was very focused. - Very fragile, very, the subset, the subset it would actually compile was small. And so if you wrote Python code and said, so the way it worked is you write a function and you say @JIT, use decorators. So decorators are just these little constructs that let you decorate code with an @ and then a name. The @JIT would take your Python function and actually just compile it and replace the Python function with another function that interacts with this compiled function. And it would just do that and we went from Python bytecode, then we went to AST, I mean, writing compilers actually, I learned a lot about why computer science is taught the way it is because compilers can be hard to write. They use tree structures, they use all the concepts of computer science that are needed. And it's actually hard to, it's easy to write a compiler and then have it be spaghetti code. Like the passes become challenging and we ended up with three versions of Numba, right? Numba got written three times. - What's, what programming language is Numba written in? - Python. - Wait, okay. - Yeah, Python. So. (laughs) - Really? - Yeah. - That's fascinating. - Yeah, so Python, but then the whole goal of Numba is to translate Python bytecode to LLVM. And so LLVM actually does the code generation. In fact, a lot of times I'd say, yeah, it's super easy to write a compiler if you're not writing the parser nor the code generator. Right? - So for people who don't know, LLVM is a compiler itself. So you're compiling to-- - Yeah, it's really badly named low-level virtual machine, which that part of it is not used. It's really low-level. - Chris, he doesn't mean that. (laughs) - Yeah, love Chris. But the name makes you imply that the virtual machine is what it's all about. It's actually the IR and the library, the code generation. That's the real beauty of it. The fact that, what I love about LLVM was the fact that it was a plateau you could collaborate on. Right? Instead of the internals of GCC or the internals of the Intel compiler, like how do I extend that? And it was a place where you could collaborate. And we were early, I mean, people had started before. It's a slow compiler. Like it's not a fast compiler. So for some kind of JITs, like JITs are common in a language because one, every browser has a JavaScript JIT. It does real-time compilation of the JavaScript to machine code. - For people who don't know, JIT is just-in-time compilation. - Thank you, yeah, just-in-time compilation. They're actually really sophisticated. In fact, I got jealous of how much effort was put into the JavaScript JITs. - Yes, well, it's kind of incredible what they've done. - Yes. - JavaScript JITs, yeah. - I completely agree. I'm very impressed. But Numba was an effort to make that happen with Python. And so we used some of the money we raised from Anaconda to do it. And then we also applied for this DARPA grant and used some of that money to continue the development. And then we used proceeds from service projects we would do. We get consulting projects on that we would then use some of the profits to invest in Numba. So we ended up with a team of two or three people working on Numba. It was a fits and starts, right? And ultimately, the fact that we had a commercial version of it also we were writing. So part of the way I was trying to fund Numba is say, well, let's do the free Numba and then we'll have a commercial version of Numba called Numba Pro. And what Numba Pro did is it targeted GPUs. So we had the very first CUDA JIT and the very first AppJIT compiler that in 2012, 2013, you could run not just a VueFunk on CPU, but a VueFunk on GPUs. And it would automatically parallelize it and get 1000x speedup. - And that's an interesting funding mechanism because large companies or larger companies care about speed in just this way. So it's exactly a really good way. - Yeah, there's been a couple of things you know people will pay for. One, they'll pay for really good user interfaces, right? And so I'm always looking for what are the things people will pay for that you could actually adapt to the open source infrastructure? One is definitely user interfaces. The second is speed, like a better runtime, faster runtime. - And then when you say people, you mean like a small number of people pay a lot of money, but then there's also this other mechanism that a ton of people pay a little bit. First, I gotta, we mentioned Anaconda, we mentioned Friends, Family and Fools. So Anaconda is yet another. So there's a company, but there's also a project that is exceptionally impactful in terms of, for many reasons, but one of which is bringing a lot more people into the community of folks who use Python. So what is Anaconda? What is its goals? Maybe what is Conda versus Anaconda? - Yeah, I'll tell you a little bit of the history of that. 'Cause Anaconda, we wanted to do, we wanted to scale Python 'cause we, you know, that was the goal. Peter and I had the goal of when we started Anaconda, we actually started as Continuum Analytics was the name of the company that started. It got renamed Anaconda in 2015. But we said, we want to scale analytics. NumPy's great, Pandas is emerging, but these need to run at scale with lots of machines. The other thing we wanted to do was make user interfaces that were web. We wanted to make sure the web did not pass by the Python community, that we had a ways to translate your data science to the web. So those are the two kind of technical areas. We thought, oh, we'll build products in this space. And that was the idea. Very quickly in, but of course, the thing I knew how to do was to do consulting to make money and to make sure my family and friends and fools that had invested didn't lose their money. So it's a little different than if you take money from a venture fund. If you take money from a venture fund, the venture fund, they want you to go big or go home. They're kind of like expecting nine out of 10 to fail or 99 out of 100 to fail. It's different, I was in a barbell strategy. I was like, I can't fail. I mean, I may not do super well, but I cannot lose their money. So I'm gonna do something I know can return a profit, but I want to have exposure to an upside. So that's what happened at Anaconda. There was lots of things we did not well in terms of that structure. And I've learned from since and have it better. But we did a really good job of kind of attracting the interest around the area to get good people working and then funnel some money on some interesting projects. Super excited about what came out of our energy there. Like a lot did. - So what are some of the interesting projects? - So Dask, Numba, Bokeh, Conda. There was a data shader, Panel, HoloViz. These are all tools that are extremely relevant in terms of helping you build applications, build tools, build faster code. - So Bokeh is the plotting-- - Oh, JupyterLab, JupyterLab came out of this too. - That's fascinating. Okay, so Bokeh does plotting? - Bokeh does plotting. So Bokeh was one of the foundational things to say, I want to do plot in Python, but have the thing show up in a web. - Right, that's right, that's right, that's right. And plotting to me still, with all due respect to Matplotlib and Bokeh, it feels like still an unsolved problem, not a solved problem. - Oh, it is. It is, it's a big problem. - Right, 'cause you're, I mean, I don't know. It's visualization broadly, right? - I think we've got a pretty good API story around certain use cases of plotting. But there's a difference between static plots versus interactive plots versus, I'm an end user, I just want to write a simple, for Panda started the idea of here's a data frame, I'm gonna dot plot. I'm just gonna attach plot as a method to my object, which was a little bit controversial, right? But works pretty well, actually, 'cause there's a lot less you have to pass in, right? You can just say, here's my object, you know what you are. You tell the visualization what to do. So that, and there's things like that that have not been super well-developed entirely. But Bokeh was focused on interactive plotting. So you could, it's a short path between interactive plotting and application, dashboard application. And there's some incredible work that got done there, right? And it was a hard project because then you're basically doing JavaScript and Python. So we wanted to tackle some of these hard problems and try to just go after them. We got some DARPA funding to help, and it was super helpful. It's a funny story there, we actually did two DARPA proposals, but one we were five minutes late for. And DARPA has a very strict cutoff window. And so we had two proposals, one for the Bokeh and one for actually Numba and the other work. - Which one were you late for? - The foundational numerical work. So Bokeh got funded. - Oh no. - Fortunately, Chris let us use some of the money to fund still some of the other foundational work. But it wasn't as, yeah, his hands were tied, he couldn't do anything about it. That was a whole interesting story. - So one of the incredible projects that you worked on is Conda. - Yes. - So what is Conda? - So how did that come about? Yeah, Conda, it was early on, like I said, with SciPy. SciPy was a distribution, mass generation library. And you heard me talking about compiler issues and trying to get the stuff shipped and the fact that people can use your libraries if they have it. So for a long time, we'd understood the packaging problem in Python. And one of the first things we did at Continuum Analytics became Anaconda, was organize the PyData ecosystem in conjunction with NumFocus. We actually started NumFocus with some other folks in the community the same year we started Anaconda. I said, we're gonna build a corporation, but we're also gonna reify the community aspect and build a nonprofit. So we did both of those. - Can we pause real quick and can you say what is PyPy, the Python package index, like this whole story of packaging in Python? - Yeah, that's what I'm gonna get to, actually. This is exactly the journey I'm on. It's to sort of explain packaging in Python. I think it's best expressed through the conversation I had with Guido at a conference, where I said, so, you know, packaging's kind of a problem. And Guido said, I don't ever care about packaging. I don't use it. I don't install new libraries. I'm like, I guess if you're the language creator and if you need something, you just put it in the distribution, maybe you don't worry about packaging. But Guido has never really cared about packaging, right? And never really cared about the problem of distribution. It's somebody else's problem. And that's a fair position to take, I think, as a language creator. In fact, there's a philosophical question about should you have different development packaging managers? Should you have a package manager per language? Is that really the right approach? I think there are some answers of it is appropriate to have development tools. And there's an aspect of the development tool that is related to packaging. And every language should have some story there to help their developers create. - So you should have language-specific development tools. - Development tools that relate to package managers. But then there's a very specific user story around package management that those language-specific package managers have to interact with and currently aren't doing a good job of that. That was one of the challenges of not seeing that difference and it still exists in the difference today. Conda always was a user, I'm gonna use Python to do data science. I'm gonna use Python to do something. How do I get this installed? It was always focused on that. So it didn't have a develop. Classic example is Pip has a pip develop. It's like, I wanna install this into my current development environment today. Now, Conda doesn't have that concept because it's not part of the story. - For people who don't know, Pip is a Python-specific package manager that's exceptionally popular. That's probably the default thing you learn. - It's the default user. Yeah, and so the story there emerged because what happened is in 2012, we had this meeting at the Googleplex and Guido was there to come talk about what are we gonna do? How are we gonna make things work better? And Wes McKinney, me, Peter. Peter has a great photo of me talking to Guido and he pretends we're talking about this story. Maybe we were, maybe we weren't. But we did at that meeting talk about it and ask Guido, "Guido, we need to fix packaging in Python. "People can't get the stuff." And he said, "Go fix it yourself. "I don't think we're gonna do it." (laughing) All right. - That's the origin story right there. - All right, you said, okay, you said to do this ourselves. So at the same time, people did start to work on the packaging story in Python. It just took a little longer. So in 2012, kind of motivated by our training courses we were teaching, like how do we, very similar to what you just mentioned about your mother. Like it was motivated by the same purpose. Like how do we get this into people's hands? And it's this big, long process. It takes too expensive. It was actually hurting NumPy development because I would hear people were saying, "Don't make that change to NumPy "because I just spent a week getting my Python environment "and if you change NumPy, I have to reinstall everything. "And reinstalling is such a pain, don't do it." I'm like, wait, okay, so now we're not making changes to a library because of the installation problem that it'll cause for end users. Okay, there's a problem with installation. We gotta fix this. So we said, we're gonna make a distribution of Python. And we'd previously done that at mDot. I wanted to make one that we gave away for free that everyone could just get. Like that was critical that we just get it. It wasn't tied to a product. It was just you could get it. And then we had constantly thought about, well, do we just leverage RPM? But the challenge had always been, we want a package manager that works on Windows, Mac OS X and Linux the same. And it wasn't there. Like you don't have anything like that. - And for people who don't know, RPM is operating system specific package manager. - Correct, it's an operating specific, yes. - So do you create the design questions? Do you create an umbrella package manager that works across operating systems? - Yes, that was the decision. - And a neighboring design question is, do you also create a package manager that spans multiple programming languages? - Correct, exactly. That was the world we faced. And we decided to go multiple operating systems, multiple and programming language independent. Because even Python, and particularly what was important was SciPy has a bunch of Fortran in it, right? And scikit-learn has links to a bunch of C++. There's a lot of compiled code. And the Python package managers, especially early on, didn't even support that. So in 2000, so we released Anaconda, which was just a distribution of libraries, but we started to work on Conda in 2012. First version of Conda came out early 2013, summer of 2013. And it was a package manager. So you could say Conda install scikit-learn. In fact, scikit-learn was a fantastic project that emerged. It was the classic example of the scikits. I talked to you earlier about SciPy being too big to be a single library. Well, what the community had done is said, let's make scikits. And there's scikit-image, there's scikit-learn, there's a lot of scikits. And it was a fantastic move that the community did. I didn't do it. I was like, okay, that's a good idea. I didn't like the name. I didn't like the fact you typed scikit-image. I was like, it has got to be simpler, sklearn. We've got to make that smaller. I don't like typing all this stuff, it's important. So I was kind of a pressure that way. But I love the energy. I love the fact that they went out and they did it. And lots of people, Jared Millman, and then of course, Gael, and there's people I'm not even naming. Scikit-learn really emerged as a fantastic project. - And the documentation around that is also incredible. - And the documentation was incredible, exactly. - I don't know who did that, but they did a great job. - A lot of people in INRIA, a lot of people, a lot of European contributors. Andreas, there's some Andreas in the US. There's a lot of people I just adore, I think are amazing people. Awesome use of SciPy, right? I love the fact that they were using SciPy effectively to do something I love, which is machine learning, but couldn't install it. - 'Cause there's so many pieces involved. - So many dependencies, right? So our use case of Conda was Conda install Scikit-learn. Right, and it was the best way to install Scikit-learn in 2013 to really 2018, '17, '18. Pip finally caught up. I still think you should Conda install Scikit-learn instead of Pip install Scikit-learn, but you can Pip install Scikit-learn. The issue is the package they created was wheels, and Pip does not handle the multi-vendor approach. They don't handle the fact you have C++ libraries you're depending on. They just stop at the Python boundary. And so what you have to do in the wheel world is you have to vendor. You have to take all the binary and vendor it. Now if a change happens in underlying dependency, you have to redo the whole wheel. So TensorFlow is a good example, but you should not Pip install TensorFlow. It's a terrible idea. People do it because the popularity of Pip, many people think, "Oh, of course that's how "I install everything in Python." - Yeah, this is one of the big challenges. You know, you take a GitHub repository or just a basic blog post, the number of time Pip is mentioned over Conda is like 100x to one. - Correct, correct. - So it just has to do with-- - And that was increasing. It wasn't true early because Pip didn't exist. Like, Conda came first. - So but that's like the long tail of the internet documentation user-generated. So that, like you think, how do I install, you Google, "How do I install TensorFlow?" You're just not gonna see Conda in that first page. - It's not correct, exactly. - And that-- - Not today, you would have in 2016, 2017. - And it's sad because you saw the, Conda solves a lot of usability issues. - Correct. - Like for especially super challenging thing, I don't know, one of the big pain points for me was just on the computer vision side, OpenCV installation that-- - Perfect example, yes. - I think Conda, I don't know if Conda has solved that one. - Conda has an OpenCV package. - I don't know, I certainly know Pip has not solved, I mean, there's complexities there because-- - Right. - I actually don't know, I should probably know a good answer for this, but if you compile OpenCV with certain dependencies, you'll be able to do certain things. So there's this kind of flexibility of what you, like what options you compile with. - Yes. - And I don't think it's trivial to do that in a with Conda or with-- - So Conda has a notion of variance of a package. You can actually have different compilation versions of a package, so not just the version's different, but oh, this is compiled with these optimizations on it. So Conda does have an answer. - Has those flavors, yeah. - Has flavors, basically. - Well, Pip, as far as I know, does not have flavors. - No, Pip generally hasn't thought deeply about the binary dependency problem, right? That's why fundamentally it doesn't work for the Sci-Fi ecosystem. It barely, you can sort of paper over it and duct tape it and it kind of works, until it doesn't and it falls apart entirely. So it's been a mixed bag. And I've been having lots of conversations with people over the years because, again, it's an area where if you understand some things, but not all the things, but they've done a great job of community appeal. This is an area where I think Anaconda, as a company, needed to do some things in order to make Conda more community-centric, right? And this is, I talk about this all the time, there's a balance between you have, every project starts with what I call company-backed open source. Even if the company is yourself, it's just one person. Just doing business as. But ultimately for products to succeed virally and become massive influencers, they have to get community people on board. They have to get other people on board. So it has to become community-driven. And a big part of that is engagement with those people, empowering people, governance around it. And what happened with Conda in the early days, Pip emerged and we did do some good things, Conda Forge, Conda Forge community is sort of the community recipe creation community. But Conda itself, I still believe, and Peter is CEO of Anaconda, he's my co-founder. I ran Anaconda until 2017, 2018. - Is Peter still in it? - Peter's still in Anaconda, right? We're still great friends, we talk all the time. I love him to death. There's a long story there about why and how, and we can cover it in some other podcast perhaps. - Yeah. (laughs) - It's sort of a more, maybe a more business-focused one. But this is one area where I think Conda should be more community-driven. Like he should be pushing more to get more community contributors to Conda. And let the, Anaconda shouldn't be fighting this battle. - Yeah. - Right? It's actually, it's really a developer's. Like you said, help the developers, and then they'll actually move us the right direction. - That was the problem I have, is many of the cool kids I know don't use Conda. And that, to me, is confusing. - It is confusing. It's really a matter of, Conda has some challenges, first of all. Conda still needs to be improved, there's lots of improvements to be made. And it's that aspect of, wait, who's doing this? And the fact that then the PyPA really stepped up. Like they were not solving the problem at all. And now they kinda got to where they're solving it for the most part. And then effectively, you could get, like Conda solved a problem that was there, and it still does, and it's still, there's still great things it can do. But, and we still use it all the time at Quantsite with other clients, but with, but you can kinda do similar things with Pip and Docker. Right? So, especially with the web development community, that part of it again is the, there's a lot of different kind of developers in the Python ecosystem. And there's still a lack of some clear understanding. I go to the Python conference all the time, and there's only a few people in the PyPA who get it. And then others who are just massively trumpeting the power of Pip, but just do not understand the problem. - Yeah, so one of the obvious things to me from a mom, from a non-programmer perspective, is the across operating system usability that's much more natural. So, there's people that use Windows, and just, it seems much easier to recommend Conda there. But then you should also recommend it across the board. So, I'll definitely sort of-- - But what I recommend now is a hybrid. I do, I mean, I have no problem-- - Is it possible to use-- - Oh, it is, it is. What I, like, build the environment with Pip, with Conda, build an environment with Conda, and then Pip install on top of that, that's fine. Be careful about Pip installing OpenCV or TensorFlow, or, because if somebody's allowed that, it's gonna be most surely done in a way that can't be updated that easily. - So, install, like, the big packages, the infrastructure with Conda, and then the weirdos, that, like, the weird, like, implementation for some. I had, there's a cool library I used that, based on your location and time of day and date, tells you the exact position of the sun relative to the-- - Oh, very cool. - To the earth. And it's just, like, a simple library, but it's very precise, and I was like, all right. But that was, and it's Pip, and it's very nice. - Well, the thing they did really well is, Python developers who wanna get their stuff published, you have to have a Pip recipe, right? I mean, even if it's, you know, the challenge is, and there's a key thing that needs to be added to Pip, just simply add to Pip the ability to defer to a system package manager. Like, 'cause it's, you know, recognize you're not gonna solve all the dependency problem. So, let, like, give up, and allow a system packager to work. That way, an Akanda's installed, and it has Pip, it would default to Kanda to install its stuff, but Red Hat RPM would default to RPM to install more things. Like, that's the, that's a key, not difficult, but somewhat work, some work, feature needs to be added. That's an example of something, like, I've known we need to re-do it. I mean, it's where I wish I had more money. I wish I was more successful in the business side, trying to get there, but I wish my, you know, my family, friends, and full community that I know-- - Was larger. - Was larger, and had more money, 'cause I know tons of things to do, effectively, with more resources, but, you know, I have not yet been successful at Channel. Tons of, you know, some, you know, I'm happy with what we've done. We've created again, at QuantSite, what we created to get Anaconda started. We created a community analytics to get Anaconda started. Done it again with QuantSite, super excited by that. - By the way-- - It took three years to do it. - What is QuantSite, what is its mission? We've talked a few times about different, fascinating aspects of it, but let's like, big picture, what is QuantSite? - Big picture, QuantSite. QuantSite is, its mission is to connect data to an open economy, so it's basically consulting of the PID ecosystem, right? It's a consulting company, and what I've said when I started it was we're trying to create products, people, and technology, so it's divided into two groups, and a third one as well. The two groups are a consulting services company that just helps people do data science, and data engineering, and data management better, and more efficiently. - Like full stack, like full thing. - Full stack, data science, full thing, which will help you build a infrastructure if you're using Jupyter, we do staff augmentation, need more programmers, help you use DAS more effectively, help you use GPUs more effectively, just basically a lot of people need help. So we do training as well to help people, both immediate help, and then learn from somebody. We've added a bunch of stuff too, we've kind of separated some of these other things into another company called OpenTeams that we currently started. One of the things I loved about what we did at Anaconda was create a community innovation team. And so I wanted to replicate that. This time we did a lot of innovation at Anaconda. I wanted to do innovation, but also contribute to the projects that existed, like create a place where maintainers, so that SciPy, and NumPy, and all these projects we already started can pay people to work on them and keep them going. So that's Labs, QuantSite Labs is a separate organization, it's a non-profit mission, the profits of QuantSite help fund it, and in fact, every project that we have at QuantSite, a portion of the money goes directly to QuantSite Labs to help keep it funded. So we've gotten several mechanisms we keep QuantSite Labs funded. And currently, so I'm really excited about Labs, 'cause it's been a mission for a long time. - What kind of projects are within Labs? - So Labs is working to make the software better, like make NumPy better, make SciPy better, make it's only works on open source. So if somebody wants to, so companies do, we have a thing called a community work order, we call it. If a company says, I wanna make Spyder better, okay, cool, you can pay for a month of a developer of Spyder, or a developer of NumPy, or a developer of SciPy, you can't tell them what you want them to do, you can give them your priorities and things you wish existed, and they'll work on those priorities with the community to get what the community wants, and what emerges is what the community wants. - Is there some aspect on the consulting side that is helping, as we were talking about morphology and so on, is there specific applications that are particularly like driving, sort of inspiring the need for updates to SciPy? - Correct, absolutely, absolutely, GPUs are absolutely one of them, and new hardware beyond GPUs, I mean, Tesla's Dojo chip, I'm hoping we'll have a chance to work on that perhaps. Things like that are definitely driving it. The other thing that's driving it is scalable, like speed and scale, how do I write NumPy code or NumPy light code if I want it to run across a cluster? You know, that's Dask, or maybe it's Ray, I mean, there's sort of ways to do that now, or there's Modin, and there's, so Pandas code, NumPy code, SciPy code, Scikit-learn code, that I want to scale, so that's one big area. - Have you gotten a chance to chat with Andre and Elon about, 'cause like-- - No, I would love to, by the way. I have not, but I'd love to. I just saw their Tesla AI Days video, super exciting. - So this one of the, you know, I love great engineering, software engineering teams, and engineering teams in general, and they're doing a lot of incredible stuff with Python, they're like-- - They are. - Revolutionary, so many aspects of the machine learning pipeline that's operating in the real world, and so much of that is Python. Like you said, the guy running, you know, Andre Karpathy running Autopilot is tweeting about optimization of NumPy versus-- - I would love to talk to him. In fact, we have at Quantsight, we've been fortunate enough to work with Facebook on PyTorch directly. So we have about 13 developers at Quantsight. Some of them are in labs working directly on PyTorch. - On PyTorch, that's great. - On PyTorch, right? So I basically, when we started Quantsight, I went to both TensorFlow and PyTorch and said, hey, I wanna help connect what you're doing to the broader SciPy ecosystem, because I see what you're doing, we have this bigger mission, we wanna make sure we don't, you know, lose energy here. So, and Facebook responded really positively, and I didn't get the same reaction. - Not yet, not yet. - Not yet. - I love the folks at TensorFlow. - I really love the folks at TensorFlow too, they're fantastic. I think it's the, just how it integrates with their business, I mean, like I said, there's a lot of reasons, just the timing, the integration with their business, what they're looking for. They're probably looking for more users, and I was looking to kind of cut some development effort, and they couldn't receive that as easily, I think. So I'm hoping, I'm really hopeful, and love the people there. - What's the idea behind OpenTeams? - So OpenTeams, I'm super excited about OpenTeams, because it's one of the, I mentioned my idea for investing directly in open source, so that's a concept called FerroSS. But one of the things we, when we started Quantsight, we knew we would do, is we'd develop products and ideas, and new companies might come out. At Anaconda, this was clear, right? Anaconda, we did so much innovation, that like five or six companies could have come out of that. And we just didn't structure it so they could. But in fact, they have, you look at Dask, there's two companies coming out of Dask. You know, Bokeh could be a company. There's like lots of companies that could exist off the work we did there. And so I thought, oh, here's a recipe for an incubation, a concept that we could actually spawn new companies, and new innovations. And then the idea has always been, well, money they earn should come back to fund the open source projects. So labs, I think there should be a lot of things like Quantsight labs. I think this concept is one that scales. You could have a lot of open source research labs. Along the way, so in 2018, when the bigger idea came, how to make open source investable, I said, oh, I need to create a venture fund. So we created a venture fund called Quantsight Initiate at the same time. It's an angel fund, really. We started to learn that process. How do we actually do this? How do we get LPs? How do we actually go in this direction and build a fund? And I'm like, every venture fund should have an associated open source research lab. There's just no reason. Like our venture fund, the carried interest portion of it goes to the lab. It directly will fund the lab. - That's fascinating, by the way. So you use the power of the organic formation of teams in the open source community, and then naturally, that leads to a business that can make money. - There are some, yeah, correct. - And then it always maintains and loops back to the open source. - Loops back to open source. Exactly, and to me, it's a natural fit. There's something, there's absolutely a repeatable pattern there. And it's also beneficial because, oh, I have natural connections to the open source, so I have an open source research lab. Like, they'll all be out there talking to people. And so we've had a chance to talk to a lot of early stage companies. And our fund focused on the early stage. So Quantsight has the services, the lab, the fund, right? In that process, a lot of stuff started to happen. They're like, oh, you know, we started to do recruiting and support and training. And I was starting to build a bigger sales team and marketing team and people besides just developers. And one of the challenges with that is you end up with different cultural aspects. You know, developers, you know, there's a, in any company you go to, you kind of go, look, is this a business led company, a developer led company? Do they kind of coexist? Are they, what's the interface between them? There's always a bit of a tension there, like we were talking about before. You know, what is the tension there? With OpenTeams, I thought, wait a minute, we can actually just create, like this concept of Quantsight plus labs, it's, well, we're, well, it's specific to the PyData ecosystem. The concept is general for all open source. So OpenTeams emerged as a, oh, we can create a business development company for many, many Quantsights, like thousands of Quantsights. And it can be a marketplace to connect, essentially be the enterprise software company of the future. If you look at what enterprise software wants from the customer side, and during this journey, I've had the chance to work and sell to lots of companies, Exxon and Shell and Davey Morgan, Bank of America, like the Fortune 100, and talk to a lot of people in procurement and see what are they buying and why are they buying? So, you know, I don't know everything, but I've learned a lot about, oh, what are they really looking for? And they're looking for solutions. They're constantly given products from the, from enterprise software. Here's open source, lead to enterprise software, now I buy it, and then they have to stitch it together into a solution. Open source is fantastic for gluing those solutions together. So, whereas they keep getting new platforms they're trying to buy, what most open source, what most enterprises want is tools that they can customize that are as inexpensive as they can. - Yeah, and so you always want to maintain the connection to the open source because that's-- - Yes, so open teams is about solving enterprise software problems. - Brilliant, brilliant idea, by the way. - With a connect, but we do it honoring the topology. We don't hire all the people. We are a network connecting the sales energy and the procurement energy, and we were on the business side get the deals closed, and then have a network of partners like QuantSite and others who we hand the deals to, right? To actually do the work, and then we have to maintain, I feel like we have to maintain some level of quality control so that the client can rely on open teams to ensure the delivery. It's not just, here's a lead, go figure that out, but no, we're gonna make sure you get what you need. - Yeah, by the way, it's such a skill, and I don't know if I have the patience, or ever will have the patience to talk to the business people, or more specific, I mean, there's all kinds of flavors of business people, or like marketing people. (laughing) - There's a challenge, I hear what you're saying, because I've had the same challenge, and it's true. There's sometimes you think, okay, this is way overwrought. - Yeah, but you have to become an adult, and you have to, 'cause the companies have needs. They have ways to make money, and they also wanna learn and grow, and it's your job to kind of educate them in the best way, like the value of open source, for example. - Right, and I'm really grateful for all my experiences over the past 14 years, understanding that side of it, and still learning, for sure, but not just understanding from companies, but also dealing with marketing professionals, and sales professionals, and people that make a career out of that, and understanding what they're thinking about, and also understanding, well, let's make this better. Like, we can really make a place, like OpenTeams, I see as the transmission layer between companies and open source communities, producing enterprise software solutions. Like, eventually, we wanna, like today, we're taking on SaaS, and MATLAB, and tools that we know we can replace for folks. Really, any time you have a software tool in an organization, where you have to do a lot of customization to make it work for you. Like, it's not you're just buying this thing off the shelf, and it works. It's like, okay, you buy the system, and then you customize it a lot, usually with expensive consultants, to actually make it work for you. All of those should be replaced by open source foundations, with the same customization. - You're doing such important work, such important work in these giant organizations that do exactly that, taking some proprietary software, and hiring a huge team of consultants that customize it, and then that whole thing gets outdated quickly. - Correct. - And so, I mean, that's brilliant. - Right. - So, the one solution to that is kind of what Tesla's doing a little bit of, which is basically build up a software engineering team. - Yeah. - Like, build a team from scratch. - Build a team from scratch. And companies that are doing it well, that's what they're doing right now. - Yeah, exactly. - Right, and that's okay. - And you're creating a topology for some of that. - You're right, you just don't have to do it. That's not the only answer, right? And so, other companies can access this, be more accessible. We usually, it's really, really safe. Open Team's the future of enterprise software. We're still early. Like, this idea just percolated over the past year as we've kind of grown QuantSite and realized the extensibility of it. We just finished in our seed round to help get more salespeople and then push the messaging correctly. And there's lots of tools we're building to make this easier. Like, we wanna automate the processes. We feel like a lot of the power is the efficiency of the sales process. There's a lot of wasted energy in small teams and the sales energy to get into large companies and make a deal. There's a lot of money spent on that process. - Creating the tools and processes for that sales. - So, make that super seamless. So, a single company can go, "Oh, I've got my contract with Open Team. "We've got a subscription they can get." They can make that procurement seamless. And then, the fact they have access to the entire open source ecosystem. And we have a, you know, so we have a part of our work that's embracing open source ecosystems and making sure we're doing things useful for them, we're serving them. And then, companies making sure they're getting solutions they care about. And then, figuring out which targets we have. You know, we're not taking on all of open source, all of enterprise software yet. But we're, you know, step by step. - Well, this feels like the future. The idea and the vision is brilliant. Can I ask you, why do you think Microsoft bought GitHub and what do you think is the future of GitHub? - Great point, great point. I thought it was a brilliant move. I think they did because Microsoft has always had a developer-centric culture. Like, they always have. Like, one of the things Microsoft's always done well is understand their power as developers, right? It's been, you know, Balmer didn't necessarily make a good meme about how he approached that. But, they're broadening that. I think that's why. Because they recognize GitHub is where developers are at. Right? And so-- - But do they have a vision, like, open teams type of situation? - I don't think so, yet. - Are they just basically throwing money at developers to show their support? - I think so. - Without a topology, like you put it. Like, a way to leverage that, like, to give developers actual money. - Right. I don't think so. I think they're still, it's an enterprise software company. And they make a bunch of money. They make a bunch of games. They have a, you know, they're a big company and they sell products. I think part of it is, they know there's opportunity to make money from GitHub. Right? There's definitely a business there, you know, to sell to developers, or to sell to people using development. I think there's part of that. I think part of it is also, there's, they had definitely wanted to recognize that you need to value open source to get great developers. Which is an important concept that was emerging over the past 10 years. That, you know, PyData, we were able to convince JP Morgan to support PyData because of that fact. Right? That was where the money for them putting a couple hundred thousand into supporting PyData for several conferences was they want developers. And they realized that developers want to participate in open source. So, enterprise software folks don't always understand how their software gets used. Having spent a lot of time on the floors at JP Morgan, at InShell, at ExxonMobil, you see, oh, these companies have large development teams. And then you're, they're kind of dealing with the, what's being delivered to them. So I really feel kind of a privilege that I had a chance to learn some of these people and see what they're doing. And even work alongside them, you know, as a consultant, using my, using open source and trying to think, how do we make this work inside of our large organization? - Some of it is actually, for a large organization, some of it is messaging to the world that you care about developers and you're the cool, you care. Like, for example, like if Ford, 'cause I talked to them, like car companies, right? They want to attract, you know, you want to take on Tesla and autopilot, you want to take that, right? And so what do you do there? You show that you're cool. Like you try to show off that you care about developers and they have a lot of trouble doing that. And like one way, I think like Ford should have bought GitHub but it's just a show off. - Yeah, that's a better, yeah. - Like these old school companies and it's in a lot of different industries. There's probably different ways. It's probably an art to show that you care to developers and the developers, it's exactly what you, like for example, just spitballing here, but like Ford or somebody like that could give a hundred million dollars to the development of NumPy and like literally look at like the top most popular projects in Python and just say, we're just gonna give money. - Right. - Like that's gonna immediately make you cool. - They could actually, yeah. And in fact, they set up NumFocus to make it easy. But the challenge was, is also you have to have some business development. Like it's a bit of a seeding problem, right? And you look at how I've talked to the folks at Linux Foundation, know how they're doing it. I know how, and starting NumFocus 'cause we had two babies in 2012. One was Anaconda, one was NumFocus, right? And they were both important efforts. They had distinct journeys and super grateful that both existed and still grateful both exist. But there's different energies in getting donations as there is getting, this is important to my business. Like I'm selling you something that, this is a, I'm gonna make money this way. Like if you can tie it, if you can tie the message to an ROI for the company, it becomes a brainer. - That's more effective. - It's much more effective, right? So, and there are rational arguments to make. I've tried to have conversations with marketing, especially marketing departments. Like very early on, it was clear to me that, oh, you could just take a fraction of your marketing budget and just spend it on open source development and you get better results from your marketing. Like, because-- - What are those, can I, sorry, I'm gonna try not to go on a rant here. What have you learned from the interaction with the marketing folks on that kind of, 'cause you gave a great example of something that will obviously be a much better investment in terms of marketing is supporting open source projects. - The challenge is not dissimilar from the challenge you have in academia at the different colleges, right? Knowledge gets very specific and very channeled, right? And so people get, they get a lot of learning in the thing they know about. And it's hard then to bridge that and to get them to think differently enough to have a sense that you might have something to offer. 'Cause it's different. It's like, well, how do I implement that? How do I, what do I do with that? Do I, which budget do I take from? Do I slow down my spend on Google ads or my spend on Facebook ads? Or do I not hire a content creator? And so like, there's an operational aspect to that that you have to be the CMO, right? Or the CEO, you have to get the right level. - So you have to hire at a high position level where they care about this and they specialize. - Or they won't know how, right? And because you can also do it very clumsily, right? And I've seen, 'cause you can. You absolutely have to honor and recognize the people you're going to and the fact that if you just throw money at them, it could actually create more problems. - Can I just say, this is not you saying. Can I just, 'cause I just need, I need to say this. I've been very surprised how often marketing people are terrible at marketing. I feel like the best marketing is doing something novel and unique that anticipates the future. It feels like so much of the marketing practice is like what they took in school, or maybe they're studying for what was the best thing that was done in the past decade. And they're just repeating that over and over as opposed to innovating, like taking the risk. To me, marketing is taking the big risk. - That's a great point. - And being the first one to risk. - Yeah, there's an aspect of data observation from that risk, right, that's, I think, 'cause shared what they're doing already. But it absolutely, it's about, I think it's content. Like, there's this whole world on content marketing that you could almost say, well, yeah, it can get over, you can get inundated with stuff that's not relevant to you. Whereas what you're saying would be highly relevant and highly useful and highly beneficial. - Yeah, but it's a risk. I mean, that's why I sort of, there's a lot of innovative ways of doing that. Tesla's an example of people that basically don't do marketing. They do marketing in a very, like, it's like Elon hired a person who's just good at Twitter for running Tesla's Twitter account. (laughing) - No, right, right. - I mean, that's exactly what you wanna be doing. You want to be constantly innovating in-- - Right, there's an aspect of telling, I mean, I've definitely seen people doing great work where you're not talking about it. Like, I would say that's actually a problem I have right now with Quansight Labs. Quansight Labs has been doing amazing work, really excited about it, but we have not been talking about it enough. We haven't been-- - And there's different ways to talk about it. There's different ways to, there's different channels through which to communicate. There's also, like, I'll just throw some shade at companies I love. So for example, iRobot, I just had a conversation with them, they make Roombas. - Sure. - And I think I love, they're incredible robots, but like, every time they do, like, advertisement, not advertisement, but like, marketing type stuff, it just looks so corporate. And to me, the incredible, I may be wrong in the case of iRobot, I don't know, but to me, when you're talking about engineering systems, it's really nice to show off the magic of the engineering and the software and all the geniuses behind this product and the tinkering and like, the raw authenticity of what it takes to build that system versus the marketing people who want to have, like, pretty people, like, standing there all pretty with the robots, like, moving perfectly. So to me, there's some aspect, it's like, speaking to the hackers, you have to throw some bones, some care towards the engineers, the developers, because there's some aspect, one, for the hiring, but two, there's an authenticity to that kind of communication that's really inspiring to the end user as well. Like, if they know that brilliant people, the best in the world are working at your company, they start to believe that that product that you're creating is really good. - It's interesting, 'cause your initial reaction would be, wait, there's different users here, why would you do that? You know, my wife bought a Roomba, and she loves developers, she loves me, but she doesn't care about that hacker culture. So essentially what you said is actually the authenticity, 'cause everyone has a friend, everyone knows people, there's word of mouth, I mean, if you-- - Word of mouth is so, so powerful. - Yeah, exactly, that's interesting. - And then-- - 'Cause I think it's the lack of that realization, there's this halo effect. - Right, and also like-- - That influences your general marketing, interesting. - For some stupid reason, I do have a platform, and it seems that the reason I have a platform, many others like me, millions of others, is like the authenticity, and like we get excited naturally about stuff. And like, I don't wanna get excited about that iRobot video, because it's boring, it's marketing, it's corporate, as opposed to, I wanted to do some fun, this is me, like a shout out to iRobot, is they're not letting me get into the robot. - Yeah, well, there's an aspect of, they could be benefiting from a culture of modularity, like add-ons, and that could actually dramatically help. You've seen that over history, I mean, Apple is an example of a company like that, or the, like, I can see what your point is, is that you have something that needs to be, it needs to be adopted broadly, the concept needs to be adopted broadly. And if you wanna go beyond this one device, you need to engage this community. - Yeah, and connecting to the open source, as you said. I gotta ask you, you're a programmer, one of the most impactful programmers ever. You've led many programmers, you lead many programmers. What are some, from a programmer perspective, what makes a good programmer? What makes a productive programmer? Is there a device you can give to be a great programmer this way? - That's a great, great question. And there are times in my life, I'd probably answer this even better than I hope maybe give an answer today. 'Cause I thought about this numerous times, like right now I've spent on so much time recently hiring salespeople that-- - That your mind is a little bit on something else. - On something else. But I reflected on the past, and also, you know, I have some really, the only way I can do this, I have some really great programmers that I work with who lead the teams that they lead. And my goal is to inspire them and hopefully help them, encourage them, and help them encourage with their teams. I would say there's a number of things, a couple things. One is curiosity. Like I think a programmer without curiosity is mundane. Like you'll lose interest, you won't do your best work. So it's an affect, it's sort of, are you, have some curiosity about things. I think two, don't try to do everything at once. Recognize that you're, we're limited as humans. You're limited as a human. And each one of us are limited in different ways. You know, we all have our different strengths and skills, so it's adapting the art of programming to your skills. One of the things that always works is to limit what you're trying to solve, right? So if you're part of a team, usually maybe somebody else has put the architecture together and they've gotten given a portion for you if you're young. If you're not part of a team, it's sort of breaking down the problem into smaller parts is essential for you to make progress. It's very easy to take on a big project and try to do it all at once and you get lost and then you do it badly. And so thinking about, you know, very concretely what you're doing, defining the inputs and outputs, defining what you want to get done. Even just talking about that and like writing down before you write code, just what are you trying to accomplish? I mean, very specific about it really, really helps. I think using other people's work, right? Don't be afraid that somehow you're, like you should do it all. Like nobody does. - Stand on the shoulders of giants. - Stand on the shoulders of giants. - And copy and paste from Stack Overflow. - Copy and paste from Stack Overflow. It's like, but don't just copy and paste. It's particularly relevant in the era of codex and the auto-generated code, which is essentially I see as an indexing of Stack Overflow. - Right, exactly. - It's like-- - It's a search engine. - It's a search engine over Stack Overflow basically. So it's not, I mean, we've had this for a while. But really you want to cut and paste, but not blindly. Like absolutely have cut and paste to understand, but then you understand, oh, this is what this means. Oh, this is what it's doing. And understand as much as you can. So it's critical, that's where the curiosity comes in. If you're just blindly cutting and pasting, you're not gonna understand. And so understand, and then be sensitive to hype cycles. Right, every few often there's always a, oh, test-driven development's the answer. Oh, object-oriented's the answer. Oh, there's always an answer. You know, agile's the answer. Be cautious of jumping onto a hype cycle. Like likely there's signal, like there's a thing there that's actually valuable you can learn from, but it's almost certainly not the answer to everything you need. - What lessons do you draw from you having created NumPy and SciPy, like in service of sort of answering the question of what it takes to be a great programmer and giving advice to people? How can you be the next person to create a SciPy? - Yeah, so one is listen. - To? - Listen. - To who? - To people that have a problem, right? Which is everybody, right? But listen and listen to many. And then try to, and then do. Like you're gonna have to do an experiment. You know, do, fall down. Don't be afraid to fall down. Don't be afraid, the first thing you do is probably gonna suck, and that's okay, right? It's honestly, I think iteration is the key to innovation. And it's almost that psychological hesitation we have to just iterate. Like yeah, we know it's not great, but next time it'll be better. I mean, just keep learning and keep improving and keep improving. So it's an attitude. And then it doesn't take intense concentration, right? Good things don't happen just, it's not quite like TikTok or like Facebook. You can't scroll your way to good programming, right? There are sincere hours of deep, don't be afraid of the deep problem. Like often people will run away from something because oh, I can't solve this. And you might be right, but give it an hour. Give it a couple of hours and see. And just five minutes, not gonna give you that. - Was it lonely when you were building SciPy and NumPy? - Hugely, yeah, absolutely lonely in the sense of you had to have an inner drive. And that inner drive for me always comes from, I have to see that this is right in some angle. I have to believe it, that this is the right approach, the right thing to do. With SciPy, it was like, oh yeah, the world needs libraries and Python. Clearly Python's popular enough with enough influential people to start. And it needs more libraries. So that is a good in and of itself. So I'm gonna go do that good. So find a good, find a thing that you know is good and just work on it. So that has to happen, and it is. And you kind of have to have enough realization of your mission to be okay with the naysayer or the fact that not everybody joins you up front. In fact, one thing I've talked to people a lot, I've seen a lot of projects come and some fail. Not everything I've done has actually worked perfectly. I've tried a bunch of stuff that, okay, that didn't really work, or this isn't working and why. But you see the patterns. And one of the key things is you can't even know for six months, I say 18 months right now. If you're just starting a new project, you gotta give it a good 18-month run before you even know if the feedback's there. Like, you're not gonna know in six months. You might have the perfect thing, but six months from now, it's still kinda still emerging. So give it time, 'cause you're dealing with humans, and humans have an inertia energy that just doesn't change that quickly. So-- - Let me ask a silly question. But, you know, like you said, you're focused on the sales side of things currently. But back when you were actively programming, maybe in the '90s, you talked about IDs. What's your, a setup that you have that brings you joy? Keyboard, number of screens, Linux? - I do still like to program some, I just not as much as I used to. I have two projects I'm super interested in, trying to find funding for 'em, trying to figure out some good teams for 'em, but I could talk about those. But what I, yeah, what, I'm an Emacs guy. - Great, thank the superior editor, everybody. I've got, I don't often delete tweets, but one of the tweets I deleted when I said Emacs was better than Vim, and then the hate I got from them. - It is. - I was like, I'm walking away from this. I bored. - I do too, I don't push it. I mean, I'm not. - I'm just joking, of course. - Yeah, exactly, it's kinda like, but people do take the editor seriously, right? - I did as a joke. - It's your life. - It is, but there's something beautiful to me about Emacs, but for people that love Vim, there's something beautiful to them about that. - There is, I mean, I do use Vim for quick editing, like command line, if I send quick editing, I will still sometimes use it, but not much. Like, it's simple, corrective, corrective single edit character. - So when you were developing SciPy, you were using Emacs? - Emacs, yep. SciPy and NumPy are all written in Emacs on a Linux box, and CVS, and then SVN, version control. Git came later. I love distributed branch stuff. I think Git is pretty complicated, but I love the concept. And also, of course, GitHub, and then GitLab, make Git definitely consumable, but that came later. - Did you ever touch Lisp at all? What were your emotional feelings about all the parentheses? - Great question. So I find myself appreciating Lisp today much more than I did early, 'cause when I came to programming, I knew programming, but I was a domain expert, right? And to me, the parentheses were in the way. It's like, "Wow, it's just all this." Like, it just gets in the way of my thinking about what I'm doing, so why would I have all these, right? That was my initial reaction to it. You know, and now as I appreciate kind of the structure that kind of naturally maps to a logical thinking about a program, I can appreciate them, right? And why it's actually, you could create editors that make it not so problematic, right, honestly. So I actually have a much more appreciation of Lisp and things like Clojure, and there's Hy-Vee, which is a Python, you know, a Lisp that compiles the Python bytecode. I think it's challenging. Like, typically, these languages are, you know, I even saw a whole data science programming system in Lisp that somebody created, which is, you know, cool. But again, I think it's the lack of recognition of the fact that there exists what I call occasional programmers. People that are never gonna be programmers for a living. They don't want to have all this cuteness in their head. They want just, you know, it's why BASIC, you know, Microsoft had the right idea with BASIC in terms of having that be the language of Visual BASIC, the language of Excel and SQL Server. They should have converted that to Python 10 years ago. Like, the world would be a better place if they had, but. - There's also, there's a beauty and a magic to the history behind a language in Lisp. You know, some of the most interesting people in the history of computer science and artificial intelligence have used Lisp, so. - Yes. - You feel. - Well, it's back to that language. When you have a language, you can think in it. - Yeah. - And it helps you think better. - And it attracts certain kinds of people that think in a certain kind of way, and then that's there. Okay, so what about, like, small laptop with a tiny keyboard, or is there like three screens? - You know, good question. I've never gotten into the many screens, to be honest. I mean, and maybe it's because in my head, I kind of just, I just swap between windows. Like, partly because I guess I really can't process three screens at once anyway. Like, I just am looking at one, and I just flip. You know, I flip an application open. - So what about-- - Where it's really helpful is actually when I'm trying to, you know, here's data, and I want to input it from here. Like, this is the only time I really need another screen. - So now, because you're both a developer, lead developers, but then there's also these businesses, and there's salespeople, and you're working with large companies. - Operations people, hiring people, yeah. - The whole thing. Which operating system is your favorite still, at this point? - So Linux was the early days. - So yeah, I love Linux as a server side, and it was early days I had my own Linux desktop. I've been on Mac laptops for 10 years now. - Yeah, this is what leadership looks like. (laughing) You switch to Mac. Okay, great. - Pretty much, I mean, just the fact that I had to do PowerPoints, I had to do presentations, and you know, plug in, I just couldn't mess with plugging in laptops. It wouldn't project, and yeah. - So you mentioned, so Quonset Labs, and things like that. Can you give advice on how to hire great programmers, and great people? - Yeah, I would say, produce an open source project. - Yeah. - Get people contributing to it, and hire those people. - Yeah. I mean, you're doing it sort of, you may be perhaps a little biased, but that's probably 100% really good advice. - I find it hard to hire. I still find it hard to hire. Like, in terms of, I don't think, it's not hard to hire if I've worked with somebody for a couple of weeks. But an hour or two of interviews, I have no idea. - So that instinct, that radar of knowing if you're good or not, you've found that you're still not able to really-- - It's really hard, I mean, the resume can help, but again, the resume is like a presentation of the things they want you to see, not the reality of, and there's also, you have to understand what you're hiring for. There are different stages and different kinds of skills, and so it isn't just a, one of the things I talk a lot about internally at my company is just that the whole idea of measuring ourselves against a single axis is flawed, 'cause we're not, it's a multidimensional space, and how do you order a multidimensional space? There isn't one ordering. So this whole idea, you immediately have projected into a thing, and you're talking about hiring or best or worst or better or not better. So what is the thing you're actually needing, and you can hire for that. There is such a thing, generally I really value people who have the affect, that care about open source. Like so in some cases, their affinity to open source is simply kind of a filter of an affect. However, I have found this interesting dichotomy between open source contributors and product creation. I don't know if it's fully true, but there does seem to be the more experience, the more affect somebody has to an open source community, the less ability to actually produce product that they have. But the opposite's kind of true too. The more product focused are, I find a lot of people, I've talked to a lot of people who produce really great products, and they have a, they're looking over the open source communities, kind of wanting to participate and play, but they've played here, and they do a great job here, and then they don't necessarily have some of the same. Now I don't think that's entirely necessary. I think part of it is cultural, how they've emerged. 'Cause one of the things that open source communities often lack is great product management, like some product management energy. - That's brilliant, but you want both of those energies in the same place together. - Yes, you really do. And so it's a lot of it's creating these teams of people that have these needed skills and attributes that are hard. And so one of the big things I look for is somebody that fundamentally recognizes their need to learn. Like one of the values that we have in all of the things we do is learning. If somebody thinks they know it all, they're gonna struggle. - And some of that is just, there's more basic things like humility, just being humble in the face of all the things you don't know, and that's step one of learning. - That's step one of learning, right? And I've spent a lot of time learning, right? Other people have spent a lot more time, but I've spent a lot of time learning. My whole goal was to get a PhD because I love school, and I wanted to be a scientist. And then what I found is what's been written about elsewhere as well is the more I learned, the more I didn't know. The more I realized, man, I know about this, but this is such a tiny thing in the global scope of what I might wanna know about. So I need to be listening a whole lot better than I am just talking. That's changed a little bit, actually. My wife says that I used to be a better listener. Now that I'm so full of all these ideas I wanna do, she kind of says, "You gotta give people time to talk." - So you've succeeded on multiple dimensions. So one is the tenure track faculty. The other is just creating all these products, then building up the businesses, then working with businesses. Do you have advice for young people today in high school and college of how to live a life as nonlinear and as successful as yours? - Nonlinear. - A life that they could be proud of? - Well, Lex, that's a super compliment. I'm humbled by that, actually. I would say a life they can be proud of, honestly, one thing that I've said to people is, first, find people you love and care about them. Family matters to me a lot. And family means people you love and have committed to. So it can be whatever you mean by that, but you need to have a foundation. So find people you love and wanna commit to and do that, 'cause it anchors you in a way that nothing else can. And then you find other things. And then from out there, you find other kinds of things you can commit to, whether it's ideas or people or groups of people. So especially in high school, I would say, don't settle on what you think you know. Give yourself 10 years to think about the world. I see a lot of high school students who seem to know everything already. I think I did, too. I think it's maybe natural. But recognize that the things you care about, you might change your perspective over time. I certainly have over time. I was really passionate about one specific thing and that's kind of softened. I was a big, I didn't like the Federal Reserve. We can have a longer conversation about monetary policy and finances, but I'm a little more nuanced in my perspective at this point. But that's one area where you learn about something and go, oh, I wanna attack it. Build, don't destroy. Build, so often the tendency is to not like something, they wanna go attack it. Build something, build something to replace it. Build up, attract people to your new thing. It'd be far better. You don't need to destroy something to build something else. So that's, I guess, generally. And then definitely curiosity. Follow your curiosity. And let it, don't just follow the money. - And all of that, like you said, is grounded in family, friendship, and ultimately love. - Yes. - Which is a great way to end it. Travis, you're one of the most impactful people in the engineering and the computer science in the human world. So I truly appreciate everything you've done. And I really appreciate that you would spend your valuable time with me. It was an honor. - It was a real pleasure for me. I appreciate that. - Thanks for listening to this conversation with Travis Oliphant. To support this podcast, please check out our sponsors in the description. And now, let me leave you with something that in the programming world is called Hodgkin's Law. Every sufficiently advanced Lisp application will eventually be re-implemented in Python. Thank you for listening, and hope to see you next time. (upbeat music) (upbeat music)</p></div></div></body></html>