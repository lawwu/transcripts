<html><head><title>Lessons From A Year Building With LLMs</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Lessons From A Year Building With LLMs</h2><a href="https://www.youtube.com/watch?v=qBHfQT3YtyY" target="_blank"><img src="https://i.ytimg.com/vi_webp/qBHfQT3YtyY/maxresdefault.webp" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=qBHfQT3YtyY&t=0 target="_blank"">0:0</a> Introduction<br><a href="https://www.youtube.com/watch?v=qBHfQT3YtyY&t=202 target="_blank"">3:22</a> Strategic: Bryan Bischof & Charles Frye<br><a href="https://www.youtube.com/watch?v=qBHfQT3YtyY&t=887 target="_blank"">14:47</a> Operational: Hamel Husain & Jason Liu<br><a href="https://www.youtube.com/watch?v=qBHfQT3YtyY&t=1431 target="_blank"">23:51</a> Tactical: Eugene Yan & Shreya Shankar<br><h3>Transcript</h3><div class='max-width'><p>. You're about to experience something of a strange talk, and not just because Brian and I are strange, but because something kind of strange happened. Over the last year, a bunch of us were posting things on Twitter. We were writing blog posts complaining about LLNs, and we formed a little group chat.</p><p>And we were, you know, continuing to complain about LLNs to each other and sharing what we were working on when we realized we were all about to write the exact same blog post, what we learned in the last year. So we got together, and we turned what was initially a couple of short blog posts into a long white paper on O'Reilly, combining our lessons across strategic, operational, and tactical levels of building LLN applications.</p><p>And the response to that white paper was overwhelmingly positive. We got -- we heard from everybody, from people who contribute to Postgres, to venture capitalists, to tool builders, saying we loved what you wrote in that article, like I felt that pain too. And we were invited on the strength of that to give this keynote address.</p><p>And so we faced a kind of funny challenge, which is part of the appeal of this blog post of this article was that the six of us all came together to write it. As Scott Condren put it, it was like an Avengers team-up. So we had to figure out a way to deliver one keynote talk from six people.</p><p>So we pulled the Avengers together for one night only to sort of like deliver some of the most important insights from that 30-page article, to add some of our spicy extra takes that ended up on the cutting room floor, and to respond to the allegations. I'd like to state unequivocally that we are not, in fact, crypto bros who just found out that GPT-4 was the new Web3.</p><p>We all trained our first neural networks back when you had to write the gradients by hand. So we split the article up to three pieces, we split the talk into three pieces. First you're going to hear from me and Brian talking about the strategic considerations for building LLM applications.</p><p>How do you look to the future? How do you see around corners? How do you make big decisions? Then we're going to hand the clickers and the stage over to Hamel Hussein and Jason Liu who are going to share the operational considerations. How do you put together processes? How do you put together teams?</p><p>How do you think about workflows around delivering LLM applications? And then they will hand over the clickers and the stage to Shreya Shankar and Eugene Yan who will talk about the tactical considerations for building LLM applications. What are the specific techniques, tactics, and moves that have stood the test of one year's time for building LLM applications?</p><p>All right. So Brian, how do you build an LLM application without getting outmaneuvered and wasting everybody's time and money? Yes. Yes. Well, many of you may be thinking that there's really only one way to win in this new, exciting, dynamic, and very scary industry. And that, of course, is to train your own custom model.</p><p>Pre-training, fine tuning, a little RLHF here and there. You better start from scratch, buddy. Eh. Not quite. The model is actually not your moat. For almost no one in this audience, the model is the moat. You all as AI engineering devotees should be building in your zone of genius.</p><p>You should be leveraging your product expertise or your existing product. Maybe you've got one. And you should be finding your niche and digging into that niche, exploiting it. You should be building what the model providers are not. There's a high likelihood that the model providers have to build a lot of things for all of their customers.</p><p>Don't waste your calories on building these things. The Sam Altman phrase of steamrolling is appropriate here. And you should be treating the models like any other SaaS product. You should be quickly dropping them when there's a competitor that's clearly better. No offense to GPT-40, but Sonic 3.5 looking pretty sharp.</p><p>It's important to keep in mind that a model with high MMLU scores, that's not a product. 87% on Spyder SQL. That doesn't automate all data requests or even 87% of them. You can't sell human eval pass at 67. At least my GTM team doesn't know how. An excellent LLM-powered application is an excellent product.</p><p>It's well designed. It solves a job to be done. And it enhances your user. Why are we so excited about AI? Human enhancement. So, what should you build if not all of these things? Things that generalize to smarter and faster models. Things that help you maintain your product's quality bar under uncertainty.</p><p>And things that help you continuously improve. Whoa, Brian. Continuous improvement. That's my trigger phrase. The idea of continuous improvement has been brought to the world of LLM applications by, like, this shift in focus that we've all felt since the previous AI engineer summit to focus on evaluation and data.</p><p>It's nicely synagogalized by this diagram from our co-author, Hamill Hussain, showing this virtuous cycle of improvement. It has evals and data at the center. But the core reason to create those evals, the core reason to collect that data, is to drive forward this loop of continuous improvement. And despite what your expensive consultants or your -- many of the LinkedIn influencers posting about LLM apps might say, this is not actually the first time that engineers have tried to tame a complex system and make it useful and valuable.</p><p>This same loop of iterative improvement was also at the core of MLOps, at the operationalization of machine learning models before LLMs. This figure from our co-author Shreya Shankar's paper had that same loop of iterative improvement centered also on evaluation and on data collection. MLOps was also not the first time that engineers faced this problem, the problem of complexity, the problem of nondeterminism and uncertainty.</p><p>The DevOps movement that gave MLOps its name also focused on this kind of iterative improvement and on monitoring information in production to turn into improvements to products. But dear reader, DevOps was not the first time that engineers tackled this problem of uncertainty and solved it and solved it with iterative improvement.</p><p>DevOps built on the ideas of the lean startup movement from Eric Ries that was focusing not just on building an application, not just on building a machine learning model or an LLM agent, but on building the entire business. And it used this same loop centered on measurement and data to drive the improvement and building of a business.</p><p>This idea itself was not invented in Northern California, despite what some people might say. It has its roots in the Toyota production system and in the idea of Kaizen or continuous improvement. Genchi Genbutsu is one of the core principles from that movement that we can take forward into the development of LLM applications.</p><p>It means real things, real places. And at Toyota, that meant sending executives out to factory floors, getting their khakis a bit dirty. For LLM applications, the equivalent is looking at your data. That data is the real information about how your LLM application is delivering value to users. There's nothing that is more valuable than that.</p><p>Finally, there's lots of people selling tools at this conference, including myself. It's easy to get overly excited about the tools and the construction of this iterative loop of improvement and to forget where value actually comes from. And there's a great pithy, earthy statement from the Toyota production system from Shigeo Shingo that I really like.</p><p>Value is only created when metal gets bent. So we have to make sure that we don't get lost just building our evals and calculating concept drift. Instead, make sure that we continue to get out there and bend metal and create value for our users. I'm not going to lie.</p><p>I might have misunderstood earlier when you said let's get bent. Okay. So right off the bat, we need to spin that data flywheel, Bob. Oh, wait. Sorry. Wrong game show. I'm not going to lie. metrics. I'm not going to lie. I'm not going to lie. I'm not going to lie.</p><p>I'm not going to lie. I'm not going to lie. coloring this behavior. I'm not going to lie. enough. I don't have an evals framework to sell you. What I do have to sell you is this idea that you should be getting out there. You should be getting started. But wait, Brian, I'm really nervous.</p><p>What if this isn't good enough for my customers? Fear is the mind killer. Put it out there in beta. If it's good enough for these incredible companies like Apple Intelligence, Photoshop, and Hex, that's me. It's good enough for you. You need to collect this data. You need to put something in the wild.</p><p>You need to start looking at your user interactions. The real user interactions, LLM's responses deserve human eyes. You can give it some AI eyes, too, but definitely look at it with your human eyes. Binary human feedback is valuable. It's nice to add some rich feedback, too. That can be interesting.</p><p>But start with binaries. And finally, user requests will reveal the PMF opportunities that lie below your product substrate. Where is your PMF? Everybody wants to know. It's in your user interactions. What are they asking your chat bot that you haven't yet implemented? That's a really nice direction to skate if that's where the puck is going.</p><p>And despite the focus on the user interactions that you can have today, the things that you can ship right now, it's important to also think about the future. The best way to predict the future is to look at the past, find people predicting the present, and copy what they did.</p><p>In designing many of the components of the personal computing revolution, Alan Kaye and others at Park adopted as a core technique projecting Moore's law out into the future. They built expensive, unmarketable, slow, and buggy systems themselves so they could experience what it was like and build for that future and create it.</p><p>We don't have quite the industrial scaling information that Moore had when he wrote down his predictions. But we do have the beginnings of those same laws. There's been an order of magnitude decrease every 12 to 18 months at three distinct levels of capability. At the capability of DaVinci, the original GPT-3 API that brought, that excited a lot of us about the idea of building on foundation models.</p><p>The capabilities of text DaVinci 2, the model lineage underlying chat GPT that brought the rest of the world to excitement about this technology. And the latest and greatest level of capabilities with GPT-4 and Sonnet. In each case, around 15 months is enough time to drop the cost by an entire order of magnitude.</p><p>This is faster than Moore's law. And so the appropriate way to plan for the future is to think what this implies for what applications that are not economical today will be economical at the time that you need to raise your next round. So in 2023, it cost about $625 an hour to run a video game where all the NPCs were powered by a chat bot.</p><p>That's pretty expensive. In 1980, it cost about $6 an hour to play Pac-Man, inflation adjusted. That suggests that if we just wait for two orders of magnitude reduction or about 30 months from mid-2023, it should be possible to deliver a compelling video game experience with chat bot NPCs at about $6 an hour and people will probably pay for it.</p><p>So, you can't sell it now, but you can live it and you can design it and you can be ready when the time comes. So that's how to think about the future and how to think strategically when building LLM applications. I'd like to call to the stage my co-authors, Jason Liu and Hamo Hussain, to talk about the operational aspects.</p><p>Let's give him a hand. All right. So, Hamo and I have basically been doing a lot of AI consulting in the past year, right? We've worked with about 20 companies so far and, you know, we've done something from pre-seed all the way to public companies and I'm pretty bored of giving generic good advice, especially because there's such a range of operators here.</p><p>And so, instead, I'm going to invert. My goal today is to tell you how to ruin your business. First of all, everyone knows that in the gold rush, you sell shovels and so if you want to get gold, you've got to buy shovels too, right? You know, if you want to find more gold, keep buying shovels.</p><p>Where do I dig? Keep buying shovels. How do I know when to stop digging? The shovel will tell you. And how do I dig one deep hole versus making investments in plenty of shallow holes? Again, the answer is more shovels, clearly, right? And this might be generic so I'll give you some more specific advice.</p><p>If your rag app doesn't work, try a vector database, a different vector database. If the methodology doesn't work, implement a new paper. And maybe if you update the embedding model, you'll finally find product market fit. Because truth be told, success does not lie in developing expertise or processes. Try more tools.</p><p>There's no need to balance between exploring and exploiting the mechanisms that work for you. Change the tools. And the processes and the decision-making frameworks don't matter. The right tool will solve everything. How do you find a machine learning engineer who can fine tune as quickly as possible? A $2,000 per month open AI bill is very expensive.</p><p>And instead, hire someone for a quarter of a million dollars, give them 1% of their company, to fight CUDA build errors and figure out server cold starts, right? Because what's the point of growing your company if you're just a wrapper? And if your margins are too low, try fine-tuning.</p><p>It's much easier than figuring out how to build something worth charging for. It's really -- I cannot reiterate this enough. It's very important to hire a machine learning engineer as quickly as possible, right? Even if you have no data, generating products. They love fixing Vercel TypeScript build errors. And generally, if you hire a full-stack engineer who's really caught the LLM bug, they're going to lack real experience.</p><p>And this is because Python is a dead language, right? Machine learning engineers, research engineers can easily pick up TypeScript, and the ecosystem that exists in Python could be quickly re-implemented in a couple of weekends, right? The people who wrote Python code for the past 10 years doing data analysis, they're going to easily be able to transition their tools.</p><p>And if anything, it's really easy to teach things like product sense and data literacy to the JavaScript community. And most important of all, in order to find this kind of magic talent, we need to create a very catch-all job title. Let's use words like ninja and wizard or data scientist or prompt engineer or even the AI engineer.</p><p>In the past 10 years, we've known that this works really well, right? Every time we know exactly who we want, as long as we catch a very wide net of skills, it doesn't really matter whether or not we don't know what outcomes we're looking for. Anyways, to dig me out of this hole, I'll have Hamill explain and, you know, take a deep breath, think out loud step by step.</p><p>Thank you, Jason. So that was really good. I mean, let's just step back from the cliff a little bit. And let's kind of linger on the topic of AI engineer. I heard some booing in the audience. And so I love the term AI engineer. Like, much props to Swiss for kind of popularizing this term.</p><p>It allows us all to get together and have conversations like this. But I think that there's a misunderstanding of the skills of AI engineer. What skills you need to be successful. And there's a lot of inflated expectations. As a founder or engineering leader, the talent is the most important lever that you have.</p><p>And so what I'm going to do is I'm going to talk about some of the problems and perhaps some solutions when it comes to this talent misunderstanding. So just to review, what is an AI engineer? So this is a diagram that everyone has probably seen. There's a spectrum of skills in the AI space.</p><p>And there's this API dividing line in the middle. And kind of to the right of the API dividing line, we have AI engineer. The AI engineer skills are focused on things like chains, agents, tooling, and infra. And auspiciously missing from the AI engineer are tools like evals and data.</p><p>And I think a lot of people have taken this diagram too literally and taken it to heart and say, hey, we don't really need to know about evals, for example. The problem is that you can go from 0 to 1 really fast. In fact, you can go to 0 to 1 faster than ever before with all the great tools out there.</p><p>Just by using vibe checks and implementing the tools that we talked about. However, without evals, you can't make progress. Quickly lead to stagnation. Because if you can't measure what you're doing, you can't make your system better. And you can't go beyond 0 to 1. So, what can we do about this?</p><p>About this evals, skill set, and data literacy? So, Jason and I have found that we can actually get really good at writing evals and data literacy with just four to six weeks of deliberate practice. In fact, like very effective. And we think that these skills, evals and data, should be brought more into the core of AI engineer.</p><p>And it really helps solve this problem. And it's something that we see over and over again. So, the next thing I want to talk about is the AI engineer job title itself. And so, vague job titles can be problematic. What we see over and over again in our consulting is that this kind of catch-all role have very inflated expectations.</p><p>Any time anything goes wrong with the AI, people look towards that role to fix it. And sometimes that role doesn't have all the skills they need to move forward. And we've seen this before with the role of data scientists. The titles and names really matter. What I want to emphasize is I think AI engineer is very aspirational.</p><p>And you should keep learning. And it's a good thing to strive towards. But you need to have reasonable expectations. And just to kind of bring it back to data science, we've seen this before in data science as well. Where we had kind of a decade ago when this role was coined.</p><p>It was a unicorn that had all these skills. Software engineering skills, statistics, math, domain expertise. And we found out as an industry that we had to unroll that into many other different roles. Such as decision scientist, machine learning engineer, data engineer, so on and so forth. And I think similar things may be happening with the role of AI engineer.</p><p>And it's good to keep that in mind. And what I see, or what we both see in consulting, is that it's helpful to be more specific. To be more deliberate about what skills you need and at what time. And depending on your maturity, it's very helpful to not only specify what the skills are, but what kinds of products you'll be working on.</p><p>So these are some job titles from Github Co-Pilot. That kind of are very specific about the skills you need at that time. And really it's important to hire the right talent at the right time. On the maturity curve. So when you're first starting out, you only need application development, software engineering, or AI engineering to go from zero to one.</p><p>Then you need platform and data engineering to capture that data. And then only after that you should hire a machine learning engineer. Do not hire a machine learning engineer without having any data. But again, you can get a lot more mileage out of your AI engineer with deliberate practice on evals and data.</p><p>We usually find four to six weeks practice does the job. So in recap, one of the biggest failure modes is talent. We think the AI engineer is often over-scoped but under-specified. But we can fix that by learning evals. Next, I want to give it over to Shreya Shankar and Eugene Yan to talk about, dive into this evals and data literacy.</p><p>Thanks. Question. Thank you, Jason. Thank you, Hamel. Next up, Shreya and I are going to share with you about the tactical aspects of building with LLMs in production. Specifically, evals, monitoring, and guardrails. So here's a hackney's quote. How important evals are to the team is a differentiator between teams shipping out hot garbage and those building real products.</p><p>I would agree. I think here's an example of LLMs, of Apple's recent LLM, where they shared about how they actually collected 750 summaries of push notification and email summarizations. Because these are datasets, they are representative of their actual use case. So how do we build evals for our own products?</p><p>Well, I think the simple thing is to just make it simpler. For example, if you're trying to extract product attributes from a product description, break it down into title, price, rating. And then you can just simply do assertions. Similarly, for summarization, instead of trying to eval that amorphous blob of a summary, break it down into dimensions, such as factual inconsistency, relevance, and informational density.</p><p>And once you've done that, assertion-based tests can go a long way. Are we extracting the correct price? Are we extracting the correct title? Or if you're doing natural language to SQL generation, is it using the expected table? Is it using the expected columns? These are very simple to eval and reiterates what Hamel has mentioned about keeping it simple.</p><p>Lastly, assertions can do everything, but they can only go so far. So therefore, consider evaluator models. Maybe training a classifier for factual inconsistency or reward model for relevance. This is easier if your evals are classification and regression-based. But that said, I don't know how I feel about LLM as a judge.</p><p>What do you mean you don't like LLM as a judge? I personally am super bullish on LLM as a judge. And I'm curious how many of you are exploring LLM as judge or have implemented it? No. Yeah? There's a judge right here. You want to stand up? No. Actual LLM judge here.</p><p>Yeah. Anyways, we're going to go through some points on what to consider when deploying LLM as judge. First of all, it's a no-brainer. LLM as judge is the most easy to prototype. You just have to write a prompt to check for the criteria or metric that you want. And you can even align this towards your own preferences by providing few-shot examples of good and bad for that criteria.</p><p>On the other hand, fine-tuned models or LLMs that you have to collect a lot of data instead of a pipeline to train as your evaluator are not super easy to prototype and have a lot of upfront investment. Yeah. But that said, LLM as a judge is pretty difficult to align it to your specific criteria in the business.</p><p>Who here has not had any difficulty aligning the LLM as a judge to your criteria? Anyone? Okay, we've got to talk later, Shria. I think that if you just have a few hundred to a few thousand samples, it's very easy to fine-tune a simple model who can do it more precisely.</p><p>Second, if you want to do LLM as a judge and have it fairly precise, you sort of need to use chain of thought. And chain of thought is going to be, I don't know, five to eight seconds long. On the other hand, if you have a simple classifier or reward model, every request is maybe 10 milliseconds long.</p><p>That's two orders of magnitude lower and would improve throughput. Next, we want to think about technical debt. Okay, when we're implementing our validators in production, even if they run asynchronously or they run in the critical path, how much effort do we need to put in to keep these up to date?</p><p>With LLM as judge, if you don't make sure your few-shot examples are dynamic or some way of making sure your judge kind of prompt aligns with your definition of good and bad, then you're toast. And the effect is not as pronounced for fine-tuned models, but if you don't continually fine-tune your validators on new data, on new production data, then they will also be susceptible to drift.</p><p>So overall, when do you want to use LLM as judge? It's honestly a resources question and where you are in your application development. If you're starting to prototype it, you need quick evals with minimal dev effort and need something, you have a low-ish volume of evals, start with LLM as a judge and kind of invest in the infrastructure to align that over time.</p><p>If you have more resources or you know that your product is going to be sticky, go for a fine-tuned model. Next, I'm going to talk about looking at the data. Eugene mentioned, you know, you should create evals on your custom or bespoke criteria, but how do you know what criteria you want?</p><p>Simple answer, look at your data. Great AI researchers, but we changed that to engineers, great AI engineers look at their data. So how do we do this? The first question actually before how is when do you look at this? I know people who never look at their data at all or people who look at it initially after deployment.</p><p>Wrong answer. You want to look at it regularly. I work with a startup that, you know, whenever they ship a new LLM agent, they create a new Slack channel with all of the agents outputs that come in real time. After a couple of weeks, they transition this to kind of daily batch jobs and make sure that, you know, they're not running into errors that they didn't anticipate.</p><p>Second thing is what specifically are you looking for? You want to find slices of the data that are pretty simple or easy to characterize in some way. For example, data that comes from a particular source or data that has a certain keyword or phrase or is about a certain topic, right?</p><p>Simply just saying all of these are bad, but having no way of characterizing them and then improving your pipeline based on that is not going to help. Finally, some things to keep in mind throughout this whole kind of looking at your data experience is that your code base is very rapidly changing over time probably.</p><p>Your prompts, components of the pipeline, and et cetera. So when you're inspecting traces, it's super helpful to be able to know, you know, what GitHub commit or what model version or prompt version did this correspond to? I think this is one of the very successful things that traditional MLOps tools did, like MLflow, for example.</p><p>They made it very easy to trace back and then hopefully you could replay something. I see the judge shaking his head. Great. And finally, when using LLMs as APIs, pin model versions. LLM APIs are known to, you know, exhibit different behavior that is very hard to quantify for certain tasks.</p><p>So pin, you know, GPT-4, 11.06, pin GPT-4-0, whatever it is that you're using. So Shreya mentioned that we need to look at our data, but how do we look at our data all the time? I think the way to do this is via an automated guardrail. Here's Brandolini's law adapted.</p><p>The amount of energy to catch and fix defects is an order of magnitude larger than needed to produce it. And that's true. It's really easy to call an LLM API and just get something. But how do we know if it's actually bad? I think it's really important that we do have some basic form of guardrails.</p><p>And some of them are just table sticks. Toxicity, personally identified information, copyright, and expected language. Now you may imagine that this is pretty straightforward, but sometimes you don't actually have control over the context. For example, if someone's posting an ad on your English website that's in a different language, and you're asking your LLM to extract the attributes or to summarize it, you may be surprised that for some non-zero proportion of the time, it's actually in a different language.</p><p>Similarly, hallucinations happen more often than we would like. So imagine you're trying to summarize a movie based on the description. You just have a description for the trailer. It may actually include spoilers because it's trying so hard to be helpful. But that's actually a bad user experience. So sometimes you will include information that's not in there.</p><p>Here's a tip. If we spend a little bit more time building reference-free evals, we can use them as guardrails. So reference-based evals are when we generate some kind of output, and we compare it to some ideal sample. This is pretty expensive, and you actually have to collect all these goal samples.</p><p>On the other hand, if we have these labels, we can train an evaluator model and just compare it to the source document. So for example, if you're comparing summarizations, we can just check if the summary entails or contradicts the source document, and now we have a hallucination eval. So therefore, if we spend some time building reference-free evals once, we can use it to guardrail or new output.</p><p>Cool. Thanks, Eugene. So we're going to wrap up next minute or so on some high-level bird's-eye view, 2,000-foot view, whatever you want to call it, takeaways. First off, how many of you remember this figure from this pretty seminal paper in MLOps that came out maybe 10 years ago? 2015, so nine years ago.</p><p>Yeah. So I think this paper really communicated the idea that the model is a small part, and when you're productionizing ML systems, right, there's so much more around the model that you have to maintain over time. Data verification, feature engineering, monitoring your infrastructure, et cetera. So you might be wondering, you know, we have LLMs.</p><p>Does any of this matter? Yeah? You have a few nods here. Absolutely. When we have LLMs, all of these, you know, tech debt principles still apply. And you can even think of the exact mapping for every single component in here to the LLM equivalent. For example, maybe we don't have feature engineering pipelines, but, you know, cast in a new light, it's RAC, right?</p><p>We're looking at context, we're trying to retrieve what's relevant, engineer that to, you know, not distract the LLM too much. We have a ton of experimentation around that. All of this is something that needs to be maintained over time, especially as models change under the hood. Similarly for data validation and verification, right?</p><p>We have evals. We have guardrails that need to be deployed, right? It's not just simply wrap your model or GPT in some software and ship it. No, there's like a lot of investment that needs to happen around the model. All right. So I'd like to end with this quote from Kapati Senpai.</p><p>There's a large class of problems. They are really easy to imagine and build demos for, but it's extremely hard to milk products out of. For example, Charles dug up this paper of the first car driven by a neural network. That was 1988. 25 years later, Andre Kapati took his first demo drive of Waymo, 2013.</p><p>Ten years later, I hope all of you had a chance to try the Waymo. We got the driverless permit for Waymo in San Francisco. Maybe in a couple more years, we'll have it for the whole of California. The point is, going from demo to production takes time. That's all we had.</p><p>Thank you. Let's do it. We'll see you next time. We'll see you next time. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. Bye. you you</p></div></div></body></html>