<html><head><title>Product Quantization for Vector Similarity Search (+ Python)</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 80%;
        margin: auto;
        overflow: hidden;
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">back to index</a><h2>Product Quantization for Vector Similarity Search (+ Python)</h2><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI"><img src="https://i.ytimg.com/vi/t9mRf2S5vDI/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=0">0:0</a> Introduction<br><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=162">2:42</a> Dimensionality Reduction<br><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=290">4:50</a> Product Quantization<br><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=549">9:9</a> Python Code<br><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1111">18:31</a> Coding<br><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1276">21:16</a> Visualizing<br><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1346">22:26</a> Quantizing<br><br><div style="text-align: left;"><a href="./t9mRf2S5vDI.html">Whisper Transcript</a> | <a href="./transcript_t9mRf2S5vDI.html">Transcript Only Page</a></div><br><div style="max-width: 800px;"><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=0" target="_blank">00:00:00.000</a></span> | <span class="t">I will come to the next video in our series on similarity search. We're going to be covering</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=5" target="_blank">00:00:05.760</a></span> | <span class="t">product quantization, which is a very effective method for reducing the memory usage of our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=14" target="_blank">00:00:14.800</a></span> | <span class="t">vectors. Now, I'll just show you this very quickly. So we, in the first column over here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=22" target="_blank">00:00:22.560</a></span> | <span class="t">we have the recall speed and memory for a dataset of size 1 million. So we're using</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=30" target="_blank">00:00:30.480</a></span> | <span class="t">the SIFT 1M dataset here. And the dimensionality of the vectors in there is 120. It's a very small</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=36" target="_blank">00:00:36.240</a></span> | <span class="t">compared to a lot of vector sets out there. Now, the memory usage of that, when we just saw them</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=44" target="_blank">00:00:44.000</a></span> | <span class="t">as they are, is a quarter of a gigabyte, just over, which is pretty big. And you think this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=50" target="_blank">00:00:50.800</a></span> | <span class="t">is a small dataset, small dimensionality, so this is already pretty significant. And when you start</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=60" target="_blank">00:01:00.320</a></span> | <span class="t">getting into high dimensionality or just larger datasets, it quickly becomes very unmanageable.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=67" target="_blank">00:01:07.600</a></span> | <span class="t">So product quantization, or PQ, allows us to reduce that significantly. So in this example,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=75" target="_blank">00:01:15.920</a></span> | <span class="t">so the tests that we run here, we reduce the memory usage by 97%, which is pretty significant.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=83" target="_blank">00:01:23.360</a></span> | <span class="t">So from a quarter of a gigabyte to 6.5 megabytes, it's like nothing. And then the speed increase is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=89" target="_blank">00:01:29.280</a></span> | <span class="t">pretty significant as well. So just under a six-fold speed increase there. So pretty good.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=96" target="_blank">00:01:36.240</a></span> | <span class="t">Obviously, the recall also decreases a fair bit. So that's just something that we need to be</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=102" target="_blank">00:01:42.000</a></span> | <span class="t">careful with. But at the same time, there's different parameters that we can use in order to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=108" target="_blank">00:01:48.880</a></span> | <span class="t">fine-tune that. So what we're just going to cover in this video is the logic behind product</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=117" target="_blank">00:01:57.120</a></span> | <span class="t">quantization. There will also be another video, which will be following this one, where we'll</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=122" target="_blank">00:02:02.960</a></span> | <span class="t">have a look at product quantization in FICE. And we'll also have a look at a composite</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=128" target="_blank">00:02:08.320</a></span> | <span class="t">index of product quantization and inverted files, so IVF. And with that, we can actually make the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=136" target="_blank">00:02:16.800</a></span> | <span class="t">speed even faster. The memory goes up a little bit to, I think it's like nine megabytes, so pretty</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=142" target="_blank">00:02:22.960</a></span> | <span class="t">minimal. But the speed increase is very significant. It's like a 92 times speed increase over a flat</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=152" target="_blank">00:02:32.480</a></span> | <span class="t">index. So it's super fast. But we'll be covering that in the next video. For this one, I'm just</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=158" target="_blank">00:02:38.000</a></span> | <span class="t">going to work through what product quantization is and how it works. So we'll start with the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=163" target="_blank">00:02:43.440</a></span> | <span class="t">example of dimensionality reduction, which is what you can see here. So we have this S value up here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=169" target="_blank">00:02:49.040</a></span> | <span class="t">which is kind of like the scope of possible vectors that we can have, so all along here.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=176" target="_blank">00:02:56.000</a></span> | <span class="t">In the middle here, I've highlighted a single vector. So this would be X, our vector. And D</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=183" target="_blank">00:03:03.440</a></span> | <span class="t">over here is, of course, our dimensionality of that vector. So typically, well, in this CIF-1M</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=190" target="_blank">00:03:10.240</a></span> | <span class="t">data set, for example, we'd use a dimensionality of 128. Dimensionality reduction is something</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=197" target="_blank">00:03:17.200</a></span> | <span class="t">like PCA, for example, where we would just reduce the dimensionality there. And we would try to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=204" target="_blank">00:03:24.320</a></span> | <span class="t">maintain the geometric or spatial properties of that vector. Even though it has less dimensions,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=211" target="_blank">00:03:31.040</a></span> | <span class="t">we would still try and maintain that. So vectors that were close to each other before with a high</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=215" target="_blank">00:03:35.920</a></span> | <span class="t">dimensionality should be close to each other again in low dimensionality. Now, what we have here is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=223" target="_blank">00:03:43.760</a></span> | <span class="t">not dimensionality reduction. This is quantization. Now, quantization is a very generic term. And it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=230" target="_blank">00:03:50.800</a></span> | <span class="t">focuses on any method where we're trying to reduce the scope of our vectors. Now, in this case,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=237" target="_blank">00:03:57.600</a></span> | <span class="t">so beforehand, the scope is typically either a very large number or technically infinite.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=244" target="_blank">00:04:04.400</a></span> | <span class="t">So if we're using floats, for example, the number of possible vectors that you can have within that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=250" target="_blank">00:04:10.480</a></span> | <span class="t">space is usually pretty big. You may as well say it's infinite. Now, in this case, what we do is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=258" target="_blank">00:04:18.400</a></span> | <span class="t">reduce that. So we reduce the possible scope into a more finite set. Then we may be going from</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=267" target="_blank">00:04:27.680</a></span> | <span class="t">something like a practically infinite scope to something like 256 possible vectors. That would</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=275" target="_blank">00:04:35.680</a></span> | <span class="t">be a very small number, but it's just an example. Then notice that the dimensionality does not</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=280" target="_blank">00:04:40.960</a></span> | <span class="t">necessarily change. It can change with quantization, but that's not the point of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=286" target="_blank">00:04:46.000</a></span> | <span class="t">quantization. The point is to reduce the scope of our possible vectors. Now, at a very high level,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=292" target="_blank">00:04:52.640</a></span> | <span class="t">let's just kind of cover what product quantization is doing. So what we have here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=299" target="_blank">00:04:59.440</a></span> | <span class="t">this big blue block at the top here, this is our initial vector x. Now, we'll say dimensionality,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=309" target="_blank">00:05:09.040</a></span> | <span class="t">this is 128. So D equals 128. Now, the number of bits required to sort this vector, let's say it's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=318" target="_blank">00:05:18.800</a></span> | <span class="t">every value is a 32-bit float. So we have 32 bits multiplied by the dimensionality is 128.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=327" target="_blank">00:05:27.440</a></span> | <span class="t">So in total, that gives us 4,096 bits that we need to sort a single vector. Now, that is pretty</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=335" target="_blank">00:05:35.520</a></span> | <span class="t">significant. So what we are going to do with PQ is try our best to reduce that. First thing we do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=341" target="_blank">00:05:41.200</a></span> | <span class="t">with product quantization is split our vector x into subvectors, each one represented by U. So U</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=351" target="_blank">00:05:51.040</a></span> | <span class="t">to a subscript of J, where J is a value from 0 up to 7 in this case, representing the position of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=357" target="_blank">00:05:57.280</a></span> | <span class="t">that subvector. Now, the next step is the quantization of product quantization. So the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=364" target="_blank">00:06:04.240</a></span> | <span class="t">next step, we process each one of these subvectors through a clustering algorithm. Each of these</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=369" target="_blank">00:06:09.200</a></span> | <span class="t">clustering algorithms is specific to each subspace. So it's specific to J equals 0,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=375" target="_blank">00:06:15.600</a></span> | <span class="t">1, 2, 3, or so on. And within each one of those clustering sets, we have a set of centroids. Now,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=382" target="_blank">00:06:22.880</a></span> | <span class="t">the number of centroids, we set that beforehand. So when we're building our index, we set the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=388" target="_blank">00:06:28.880</a></span> | <span class="t">number of centroids that we want. And the more centroids we have, the more memory we use, but</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=394" target="_blank">00:06:34.480</a></span> | <span class="t">also the more accurate the index becomes. Because you think you have, say you have two centroids</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=401" target="_blank">00:06:41.520</a></span> | <span class="t">in one vector subspace. Your subvector will have to be assigned to one of those two centroids.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=406" target="_blank">00:06:46.880</a></span> | <span class="t">And in the case that we only have two centroids, neither of them could be particularly close</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=411" target="_blank">00:06:51.520</a></span> | <span class="t">to our vector or subvector. So that average distance between subvectors and the clusters</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=418" target="_blank">00:06:58.080</a></span> | <span class="t">that they're assigned to is called the quantization error. And for good accuracy, good recall, good</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=425" target="_blank">00:07:05.040</a></span> | <span class="t">results, we want to minimize that quantization error as much as possible. And we do that by</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=430" target="_blank">00:07:10.000</a></span> | <span class="t">adding more centroids. So if we compare our cluster of two centroids to a set of clusters</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=437" target="_blank">00:07:17.280</a></span> | <span class="t">where we have, let's say, 200 centroids, the chances are we're going to find a centroid that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=442" target="_blank">00:07:22.880</a></span> | <span class="t">is more closely fitting to our subvector in the 200 centroid algorithm than the one with just two</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=449" target="_blank">00:07:29.360</a></span> | <span class="t">centroids. So that's the logic behind it, sort of the memory usage and accuracy trade-off there.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=454" target="_blank">00:07:34.480</a></span> | <span class="t">Obviously, the more centroids we have, the more data we store in our index to cover the full</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=458" target="_blank">00:07:38.960</a></span> | <span class="t">scope of all those centroids. Now, once we've assigned a centroid to our subvector, we map</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=465" target="_blank">00:07:45.840</a></span> | <span class="t">that centroid to its unique ID. So every centroid within this index will have a unique ID. That</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=472" target="_blank">00:07:52.480</a></span> | <span class="t">unique ID is a 8-bit integer, typically. So we've now gone from-- so originally, we had a vector x</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=480" target="_blank">00:08:00.960</a></span> | <span class="t">of dimensionality 128. And each value was a 32-bit float. So the number of bits we use there,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=489" target="_blank">00:08:09.520</a></span> | <span class="t">4,096. Now we only have a ID vector, which contains eight 8-bit integers. So that's 8</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=500" target="_blank">00:08:20.240</a></span> | <span class="t">multiplied by 8. In this case, we have 64 bits. So we've compressed our 4,096-bit vector into</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=510" target="_blank">00:08:30.080</a></span> | <span class="t">a 64-bit vector. And that's what gets stored in our index.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=516" target="_blank">00:08:36.800</a></span> | <span class="t">Now, there's also something called a codebook, which maps each one of those IDs back to the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=523" target="_blank">00:08:43.440</a></span> | <span class="t">reconstruction or reproduction values, which are those centroid vectors. But of course,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=530" target="_blank">00:08:50.240</a></span> | <span class="t">because we've minimized the scope there, we don't need to store that many of those mappings. So say</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=537" target="_blank">00:08:57.360</a></span> | <span class="t">our scope is 256, we only need to store 256 of those mappings. So this is how product quantization</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=547" target="_blank">00:09:07.280</a></span> | <span class="t">can be so effective. Now, we'll go through some more visuals. But I want to actually write this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=555" target="_blank">00:09:15.360</a></span> | <span class="t">out in code as we go along. For me, at least, writing out in code makes it much easier to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=561" target="_blank">00:09:21.200</a></span> | <span class="t">at least logically understand the process. So there are a few variables that we need to define</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=570" target="_blank">00:09:30.320</a></span> | <span class="t">here. So we have this vector up here. It's very small. It's using integer values. The data types</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=577" target="_blank">00:09:37.680</a></span> | <span class="t">here don't matter. We just want to build out the process of product quantization. This is not an</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=584" target="_blank">00:09:44.640</a></span> | <span class="t">effective implementation or anything like that. We just want to understand the process and logic</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=588" target="_blank">00:09:48.720</a></span> | <span class="t">behind it. So the first thing is, how many subvectors are we going to convert our x full</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=596" target="_blank">00:09:56.080</a></span> | <span class="t">vector into? In this case, I want to create four subvectors. And we also need to get the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=603" target="_blank">00:10:03.040</a></span> | <span class="t">dimensionality of x as well, which is just the length of x. Now, we have those two. And the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=609" target="_blank">00:10:09.280</a></span> | <span class="t">first thing we need to do is make sure that d is divisible by m, because we need equally sized</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=617" target="_blank">00:10:17.600</a></span> | <span class="t">subvectors. So what we do is rewrite assert that d is, in fact, divisible by m. So we just write</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=626" target="_blank">00:10:26.640</a></span> | <span class="t">this. And if that is the case, we don't get an error. So if I just add a 1 in there, I'm going</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=632" target="_blank">00:10:32.880</a></span> | <span class="t">to throw it off. We get this assertion error. So we just add that in there to say, OK, d is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=638" target="_blank">00:10:38.960</a></span> | <span class="t">definitely divisible by m. So that's good. We can continue. And what we want to do is say, OK,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=646" target="_blank">00:10:46.160</a></span> | <span class="t">what is the length of each subvector? It's going to be equal to d divided by m. And we'll have to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=652" target="_blank">00:10:52.960</a></span> | <span class="t">convert that over to an int as well. So we'll just do that. And let's see what we get. So each</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=661" target="_blank">00:11:01.520</a></span> | <span class="t">subvector will be of size 3. Now, let's build that. So our subvector, or our set of subvectors,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=671" target="_blank">00:11:11.200</a></span> | <span class="t">will be assigned to u. And what we're going to do is go x from row to row plus d, d underscore,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=681" target="_blank">00:11:21.520</a></span> | <span class="t">for row in range 0 to d. And we're going to take it in steps of d, d underscore. OK. And then let's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=690" target="_blank">00:11:30.880</a></span> | <span class="t">see what we get. And see that we now have our subvectors. Now, what does that look like? Let's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=697" target="_blank">00:11:37.520</a></span> | <span class="t">visualize that. So here we have that vector. So d up here is our 12. And we're splitting that vector</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=706" target="_blank">00:11:46.240</a></span> | <span class="t">x of dimension 12 into four subvectors. So m equals 4 down here. We'll create four subvectors.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=714" target="_blank">00:11:54.480</a></span> | <span class="t">Now, d over m, which is what we calculated before, produces this d star. Now, in the code,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=720" target="_blank">00:12:00.880</a></span> | <span class="t">we can't write the star. So I've changed it to d underscore. And the value of that is 3. So each of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=728" target="_blank">00:12:08.800</a></span> | <span class="t">our subvectors has a dimensionality of 3. So here we have that d star dimensionality of 3 here.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=737" target="_blank">00:12:17.120</a></span> | <span class="t">These are our subvectors. We have 4 in total. So that is equal to m. Now, next thing I want to do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=744" target="_blank">00:12:24.400</a></span> | <span class="t">is answer k. So k is the number of possible values that we're going to have in our data set. So we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=754" target="_blank">00:12:34.880</a></span> | <span class="t">are going to do 2 to the power of 5. And we print it out. And we get 32. So k is going to be equal</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=762" target="_blank">00:12:42.160</a></span> | <span class="t">to 32. Now, the one thing we need to make sure of here is this k value, so the number of possible</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=771" target="_blank">00:12:51.200</a></span> | <span class="t">centroids, that is going to be shared across our entire set of subspaces or subvectors.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=780" target="_blank">00:13:00.320</a></span> | <span class="t">So we need to make sure that that is divisible by m again. So we do the same thing again. We say</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=786" target="_blank">00:13:06.480</a></span> | <span class="t">assert that k is, in fact, divisible by m. If it is, we can go on to get k star or k underscore,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=796" target="_blank">00:13:16.560</a></span> | <span class="t">which is going to be k divided by m. OK. And let's have a look at what that is.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=802" target="_blank">00:13:22.960</a></span> | <span class="t">So this means that with that, we should also make sure that's an integer,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=807" target="_blank">00:13:27.840</a></span> | <span class="t">like so. OK. So what that means is that we are going to have 8 centroids per subspace. So each</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=820" target="_blank">00:13:40.560</a></span> | <span class="t">one of these subvectors here will have the possibility of being assigned to one of the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=827" target="_blank">00:13:47.200</a></span> | <span class="t">nearest 8 centroids within its subspace. And in total, across all of our subvectors, of course,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=835" target="_blank">00:13:55.040</a></span> | <span class="t">we have a total of 32 possible centroids. Now, what that 32 there means is that we will have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=843" target="_blank">00:14:03.680</a></span> | <span class="t">a codebook. So a codebook is simply a mapping of our centroid vectors. Or, in fact, let's do the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=851" target="_blank">00:14:11.840</a></span> | <span class="t">other way around. It's a mapping of centroid vector IDs. So each one of the centroids that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=857" target="_blank">00:14:17.360</a></span> | <span class="t">we haven't created yet but we will create will be assigned a unique ID. And it maps us from the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=863" target="_blank">00:14:23.280</a></span> | <span class="t">unique ID to the actual centroid subvector. So that's where later on we call those centroids</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=872" target="_blank">00:14:32.800</a></span> | <span class="t">reproduction values. Because later on, when we're searching through our index, our index is storing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=879" target="_blank">00:14:39.440</a></span> | <span class="t">those 8-bit integers. But obviously, we can't compare those 8-bit integers to an actual vector</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=885" target="_blank">00:14:45.760</a></span> | <span class="t">that we're searching with, our query vector. So what we do is we map each one of those 8-bit</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=893" target="_blank">00:14:53.200</a></span> | <span class="t">integers, which are the IDs, back to their original centroid values. Not to the original subvector</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=900" target="_blank">00:15:00.160</a></span> | <span class="t">values, but to the original centroid values. And that's what our codebook is for. So this k value,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=907" target="_blank">00:15:07.600</a></span> | <span class="t">this 32, means that we will have a total of 32 mappings in our codebook. Now, I know that can</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=915" target="_blank">00:15:15.680</a></span> | <span class="t">maybe seem confusing. So let's have a look at what that actually looks like. So over here, we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=921" target="_blank">00:15:21.040</a></span> | <span class="t">u and our subvectors. Here, we would have, let's say, j equals 0, j equals 1, 2, 3. And over here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=930" target="_blank">00:15:30.480</a></span> | <span class="t">what we have is our reproduction value. So those centroid or those cluster centroids. Now, in this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=938" target="_blank">00:15:38.000</a></span> | <span class="t">case, we have these three centroids. In reality, we set k equal to 8. So we should actually see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=945" target="_blank">00:15:45.360</a></span> | <span class="t">not 3 centroids here, but we would actually see 8. So we have 1, 2, 3, 4, 5, 6, 7, 8. So in reality,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=954" target="_blank">00:15:54.960</a></span> | <span class="t">there would actually be that many centroids in there. And each one of those centroids can be</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=960" target="_blank">00:16:00.000</a></span> | <span class="t">referred to as c, j. So in this case, j would be 0 and i. So we would have, let's say, this centroid</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=969" target="_blank">00:16:09.920</a></span> | <span class="t">is i equals 0, this centroid is i equals 1, this centroid is i equals 2, and so on, all the way up</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=976" target="_blank">00:16:16.960</a></span> | <span class="t">to, in this case, 7. So 0 is 7, giving us the 8 centroids there. So to get to this centroid here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=985" target="_blank">00:16:25.280</a></span> | <span class="t">in our codebook, so this c represents our codebook, we would go c, 0, 0. Or this one over here, this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=994" target="_blank">00:16:34.480</a></span> | <span class="t">number 2, would be c, 0, 2. Let's say down here, this green centroid, let's say that is i equals</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1004" target="_blank">00:16:44.160</a></span> | <span class="t">4. So that means that to get to that in our codebook, we would say c, 3, 4. Okay, so that's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1012" target="_blank">00:16:52.240</a></span> | <span class="t">just the notation behind it. So our quantized subvector is one of these centroid subvectors.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1019" target="_blank">00:16:59.760</a></span> | <span class="t">And each one of our reproduction values, or those subvectors, the quantized subvectors,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1026" target="_blank">00:17:06.640</a></span> | <span class="t">will be assigned a reproduction value id, which is simply what we have here. So this c, j, i.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1033" target="_blank">00:17:13.360</a></span> | <span class="t">So in this case, this value here may be, it may be the value 0, 8 integer 0. And if we started</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1041" target="_blank">00:17:21.440</a></span> | <span class="t">counting through all of our codebook, that would relate to c, 0, 0. Now if we were to go, let's say</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1049" target="_blank">00:17:29.840</a></span> | <span class="t">down here, this is number 10, the integer value of 10. Now that if we count through, so j is going</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1058" target="_blank">00:17:38.080</a></span> | <span class="t">to go up to 7, and that's our integer value of 7. And it's going to get reset because we're going to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1064" target="_blank">00:17:44.960</a></span> | <span class="t">take j from 0 to 1, which is going to reset our i counter. So it will go from c, 0, 7. And the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1076" target="_blank">00:17:56.160</a></span> | <span class="t">next one in our codebook will be down here, which will be c, 1, 0. So this actual integer value in</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1085" target="_blank">00:18:05.920</a></span> | <span class="t">our id vector, that would be represented by the value 8. So this value here would be 8,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1093" target="_blank">00:18:13.840</a></span> | <span class="t">so we add one more. We go to 9, so that would be c, 1, 1. And 10 would be c, 1, 2. So c, 1, 2. Okay,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1102" target="_blank">00:18:22.560</a></span> | <span class="t">and that's how we represent those. And we refer back to those original centroid subvectors within</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1109" target="_blank">00:18:29.120</a></span> | <span class="t">the reproduction values codebook. But for now, we don't have those centroids, so we need to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1114" target="_blank">00:18:34.880</a></span> | <span class="t">create some. So what I'm going to do is from random, import random int. C is going to be our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1122" target="_blank">00:18:42.800</a></span> | <span class="t">overall codebook or list of reproduction values. And we're going to say for j in range m,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1130" target="_blank">00:18:50.960</a></span> | <span class="t">so we're looping through each of our subspaces here, we are going to initialize cj. Okay,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1139" target="_blank">00:18:59.840</a></span> | <span class="t">and then in here, we need to store eight different centroid vectors or reproduction values.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1147" target="_blank">00:19:07.280</a></span> | <span class="t">And of course, we refer to those as i, so position those as i, for i in range.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1153" target="_blank">00:19:13.760</a></span> | <span class="t">And here, we are looping through k_. So in our case, that would be equal to 8. So we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1160" target="_blank">00:19:20.480</a></span> | <span class="t">run through that 8 times. Here we have m, so you think 4. We loop through 4 j's,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1169" target="_blank">00:19:29.680</a></span> | <span class="t">and we loop through 8 i's for each one of those. So in total, we get that 32 value,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1176" target="_blank">00:19:36.000</a></span> | <span class="t">which is our k value. And what we want to do is say we're going to say cji is going to be equal</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1183" target="_blank">00:19:43.360</a></span> | <span class="t">to, we want to say randint from 0 up to, it's going to be our vector space, our cluster vector</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1191" target="_blank">00:19:51.360</a></span> | <span class="t">space. So we're just going to set it to the maximum value that we have in here. So we have a 9.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1199" target="_blank">00:19:59.440</a></span> | <span class="t">So we set that. So these are the centroid values, remember, not the ids for just underlying in</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1208" target="_blank">00:20:08.320</a></span> | <span class="t">range. Here we have our dimensionality of each subvector. And what we want to do is just append</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1216" target="_blank">00:20:16.160</a></span> | <span class="t">that to cj, cji. And then outside that loop, we want to append cj to c.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1226" target="_blank">00:20:26.000</a></span> | <span class="t">Okay, so we've now just created our clusters, which we can see in here. So each subspace,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1237" target="_blank">00:20:37.600</a></span> | <span class="t">so each j has a total of 8 possible centroids. So we have 0 or 1, 2, 8 here in each one. And</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1249" target="_blank">00:20:49.600</a></span> | <span class="t">we don't forget we have m of those subspaces, so we should see 4 of them, although it does</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1256" target="_blank">00:20:56.000</a></span> | <span class="t">put out here, but this is in fact just the fourth one here. Now I think it's pretty cool to be able</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1263" target="_blank">00:21:03.120</a></span> | <span class="t">to visualize that. So I'm just going to copy and paste this code across. You can see here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1268" target="_blank">00:21:08.960</a></span> | <span class="t">you can copy if you want. It will be also in the notebooks that will be linked in the description</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1274" target="_blank">00:21:14.640</a></span> | <span class="t">of the video. And we're just going to visualize each of our centroids within each of those</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1284" target="_blank">00:21:24.320</a></span> | <span class="t">subspaces. So this is c, where j is equal to 0, j is equal to 1, 2, and 3. And these here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1293" target="_blank">00:21:33.360</a></span> | <span class="t">are our centroids. Now typically, of course, we would train these, but we are not going to train</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1299" target="_blank">00:21:39.920</a></span> | <span class="t">them. We just want to create a very simple example here. So we're not going to go that far into it.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1307" target="_blank">00:21:47.920</a></span> | <span class="t">Okay, so I mean that's everything we see there. And now what we need to do, so we've produced</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1314" target="_blank">00:21:54.160</a></span> | <span class="t">those reproduction values, all those centroids, and now what we need to do is actually take our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1321" target="_blank">00:22:01.520</a></span> | <span class="t">subvector and assign it to the nearest reproduction value or centroid. Now how do we do that? We</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1328" target="_blank">00:22:08.160</a></span> | <span class="t">simply calculate the distance between our subvector and each of its equivalent reproduction values or</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1336" target="_blank">00:22:16.640</a></span> | <span class="t">centroids. I'm sure it's going to get annoying if I keep saying reproduction values or centroids,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1342" target="_blank">00:22:22.720</a></span> | <span class="t">so I'm just going to call them centroids from now on. It's so much easier. So we are going to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1347" target="_blank">00:22:27.920</a></span> | <span class="t">calculate, we're going to identify the nearest of our centroids to our specific subvector. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1356" target="_blank">00:22:36.560</a></span> | <span class="t">I'm just going to copy these functions in. The top here, we're just calculating the Euclidean distance.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1364" target="_blank">00:22:44.640</a></span> | <span class="t">It's pretty straightforward. If you need to just Google Euclidean distance, the form is pretty</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1372" target="_blank">00:22:52.720</a></span> | <span class="t">straightforward. And then here we're just using that Euclidean distance and looping through each</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1378" target="_blank">00:22:58.480</a></span> | <span class="t">of our values, so the K_, so each of the centroids within our specific J subspace. So all we need to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1387" target="_blank">00:23:07.920</a></span> | <span class="t">do there is pass a specific J subspace and our specific subvector to that function. And to do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1398" target="_blank">00:23:18.480</a></span> | <span class="t">that, all we want to do, I'll just also note that what we're doing here, these are the index</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1406" target="_blank">00:23:26.240</a></span> | <span class="t">positions, so the high positions, and we're looping through and saying if the new distance that we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1412" target="_blank">00:23:32.240</a></span> | <span class="t">calculated between, you see here we're accessing that specific centroid, if that is less than the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1418" target="_blank">00:23:38.800</a></span> | <span class="t">previous one between our subvector and that centroid, then we assign the nearest ID to that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1426" target="_blank">00:23:46.880</a></span> | <span class="t">vector, not necessarily distance. We don't care about distance, we just want to see the nearest ID</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1432" target="_blank">00:23:52.720</a></span> | <span class="t">to nearest IDX, which is what we return. So what we're going to return there are in fact</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1439" target="_blank">00:23:59.040</a></span> | <span class="t">the I values for those centroids. So first thing we're going to do is initialize our ID's vector,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1445" target="_blank">00:24:05.520</a></span> | <span class="t">so here we're actually going to build that 8-bit integer IDs. In this case, there's not going to be</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1452" target="_blank">00:24:12.240</a></span> | <span class="t">eight of the values, there will be four, because the length of this vector is always going to be</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1457" target="_blank">00:24:17.760</a></span> | <span class="t">equal to M. So we have 4J in range M, I is equal to the nearest between CJ and UJ. I want to say</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1476" target="_blank">00:24:36.800</a></span> | <span class="t">ID's append I. And then let's see what we have. Okay, so that is our quantized subvector, so each</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1486" target="_blank">00:24:46.960</a></span> | <span class="t">one of these IDs here represent one of our centroid positions. So if we wanted to get those</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1496" target="_blank">00:24:56.480</a></span> | <span class="t">centroid positions, so in this case I'm going to call them the reproduction or reconstruction values,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1501" target="_blank">00:25:01.520</a></span> | <span class="t">we would do this. So this is going to be our reconstructed vector.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1507" target="_blank">00:25:07.040</a></span> | <span class="t">I'm going to go between, so we're going to go for each J in range M, again remember,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1515" target="_blank">00:25:15.840</a></span> | <span class="t">we're going to say CJI, so the reconstruction value, is equal to C for J. And then the I</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1527" target="_blank">00:25:27.680</a></span> | <span class="t">position is whichever value we have in here, so we need to say ID's J. Okay, and then we're going to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1535" target="_blank">00:25:35.440</a></span> | <span class="t">do Q, extend, CJI, and now let's have a look at what we get for Q. So this is our fully reconstructed</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1546" target="_blank">00:25:46.160</a></span> | <span class="t">vector. Now earlier on I said that we get the quantization error, and we typically measure that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1553" target="_blank">00:25:53.920</a></span> | <span class="t">using the mean squared error, so this function here, you can see it there. So what we can do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1561" target="_blank">00:26:01.920</a></span> | <span class="t">is we can measure the error, or mean squared error, between our quantized vector and the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1568" target="_blank">00:26:08.400</a></span> | <span class="t">original vector. So all we do here is we go mean squared error, X, and Q. And here we get the total</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1577" target="_blank">00:26:17.040</a></span> | <span class="t">squared error, mean squared error, between our original vector and the quantized version.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1582" target="_blank">00:26:22.960</a></span> | <span class="t">Through sort of increasing the M value, or increasing K, we should be able to minimize</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1590" target="_blank">00:26:30.800</a></span> | <span class="t">this, and therefore improve the performance of our index. So I have one final thing to show you,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1597" target="_blank">00:26:37.760</a></span> | <span class="t">which is how the search works in PQ. So on the right we have just a single ID vector.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1607" target="_blank">00:26:47.360</a></span> | <span class="t">We would use our codebook, C, so that they would each go into this, like so.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1619" target="_blank">00:26:59.360</a></span> | <span class="t">And from there we would output our quantized subvectors. So these are their reproduction</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1627" target="_blank">00:27:07.280</a></span> | <span class="t">values. Now on the left we have our query vector, and we would split that, of course,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1637" target="_blank">00:27:17.600</a></span> | <span class="t">like we did before with our initial vectors. So we would split that, and we would get this.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1648" target="_blank">00:27:28.080</a></span> | <span class="t">Now, what we would do is we calculate the Euclidean distance between these,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1654" target="_blank">00:27:34.800</a></span> | <span class="t">and what we would get is we would simply add all of these up. So we'd take the product of all of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1663" target="_blank">00:27:43.520</a></span> | <span class="t">them, hence why this is called product quantization, and the total distance would be all of those</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1670" target="_blank">00:27:50.800</a></span> | <span class="t">added together. Okay, let's say this. Now we would do that for all of our vectors. So this is a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1681" target="_blank">00:28:01.680</a></span> | <span class="t">single, so this is like QU. That's a single quantized vector, or set of quantized subvectors.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1691" target="_blank">00:28:11.120</a></span> | <span class="t">We need to do that for all of them. And then we just find one that produces the lowest or the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1696" target="_blank">00:28:16.720</a></span> | <span class="t">lowest or the smallest product distance. Now, as well, it's worth noting, because we're taking</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1702" target="_blank">00:28:22.560</a></span> | <span class="t">the product, this isn't really the distance between the two vectors, between U or the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1708" target="_blank">00:28:28.240</a></span> | <span class="t">quantized version of U and XQ, but it's almost like a proxy value for that. And then that's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1718" target="_blank">00:28:38.800</a></span> | <span class="t">what we use to find, to identify the nearest vector. Now, I'm not going to go into the code</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1725" target="_blank">00:28:45.280</a></span> | <span class="t">behind this because it's quite long, but I am going to, I'm definitely going to record that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1730" target="_blank">00:28:50.560</a></span> | <span class="t">and just leave it as like an extra or almost bonus video if you do want to go through that.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1735" target="_blank">00:28:55.920</a></span> | <span class="t">But it is, it's pretty long, so I wouldn't say you necessarily need to. But in the next video,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1742" target="_blank">00:29:02.240</a></span> | <span class="t">anyway, we're going to have a look at how we implement all this in FICE, which is obviously</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1747" target="_blank">00:29:07.200</a></span> | <span class="t">much more efficient. And it is in that video that we will also introduce the IVF and PQ</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1755" target="_blank">00:29:15.440</a></span> | <span class="t">CompSetIndex, which just allows us, if you have a look at the speed here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1759" target="_blank">00:29:19.200</a></span> | <span class="t">to really reduce the speed an insane amount. It's like a 90 times increase in the speed</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1767" target="_blank">00:29:27.760</a></span> | <span class="t">of our search. So it's pretty cool. But yeah, that's it for this video.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=t9mRf2S5vDI&t=1771" target="_blank">00:29:31.840</a></span> | <span class="t">So thank you very much for watching, and I will see you in the next one.</span></div></div></body></html>