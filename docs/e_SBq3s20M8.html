<html><head><title>Locality Sensitive Hashing (LSH) for Search with Shingling + MinHashing (Python)</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">back to index</a><h2>Locality Sensitive Hashing (LSH) for Search with Shingling + MinHashing (Python)</h2><a href="https://www.youtube.com/watch?v=e_SBq3s20M8"><img src="https://i.ytimg.com/vi/e_SBq3s20M8/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=0">0:0</a> Intro<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=81">1:21</a> Overview<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=358">5:58</a> Shingling<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=525">8:45</a> Vocab<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=567">9:27</a> One-hot Encoding<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=670">11:10</a> MinHash<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=951">15:51</a> Signature Info<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1088">18:8</a> LSH<br><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1340">22:20</a> Tuning LSH<br><br><div style="text-align: left;"><a href="./e_SBq3s20M8.html">Whisper Transcript</a> | <a href="./transcript_e_SBq3s20M8.html">Transcript Only Page</a></div><br><div style="max-width: 800px;"><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=0" target="_blank">00:00:00.000</a></span> | <span class="t">Hi and welcome to the video. Today we're going to be covering another technique in</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=5" target="_blank">00:00:05.280</a></span> | <span class="t">similarity search called locality sensitive hashing or LSH. Now LSH is a hugely popular</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=13" target="_blank">00:00:13.680</a></span> | <span class="t">technique used in efficient similarity search. Now there are a huge number of companies that use</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=21" target="_blank">00:00:21.600</a></span> | <span class="t">similarity search. I mean you have big names like Google. I mean Google is built from similarity</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=27" target="_blank">00:00:27.760</a></span> | <span class="t">search and then you have Netflix, Amazon, Spotify. All of them are constantly recommending you</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=33" target="_blank">00:00:33.840</a></span> | <span class="t">different products, films, music and they do that by comparing you to other customers. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=41" target="_blank">00:00:41.520</a></span> | <span class="t">they are performing a similar search between you other customers and identifying the most similar</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=45" target="_blank">00:00:45.920</a></span> | <span class="t">ones. Now you have two approaches. You have exhaustive which is comparing all of the data</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=54" target="_blank">00:00:54.400</a></span> | <span class="t">points. I'm just going to call them vectors from now on because that's what we'll be using. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=58" target="_blank">00:00:58.240</a></span> | <span class="t">comparing all these vectors and obviously it's slow. Approximate search allows us to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=66" target="_blank">00:01:06.080</a></span> | <span class="t">approximate those vectors, restrict our scope to a more relevant range of vectors</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=73" target="_blank">00:01:13.280</a></span> | <span class="t">and so on. So it covers a lot of different techniques. It's not just one technique here.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=77" target="_blank">00:01:17.760</a></span> | <span class="t">The one we're going to be covering today is locality sensitive hashing. So at its core LSH</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=86" target="_blank">00:01:26.000</a></span> | <span class="t">is a hashing algorithm which attempts to maximize hash collisions. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=93" target="_blank">00:01:33.520</a></span> | <span class="t">what we see on screen right now is a dictionary, like a typical Python dictionary in the way that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=102" target="_blank">00:01:42.080</a></span> | <span class="t">it hashes different items. So we have our keys which are items that we're hashing. We process</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=109" target="_blank">00:01:49.440</a></span> | <span class="t">them through a hashing function and that hashing function attempts to minimize hashing collisions,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=117" target="_blank">00:01:57.600</a></span> | <span class="t">e.g. to not put keys in the same bucket. It wants every key to go to a separate bucket.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=125" target="_blank">00:02:05.600</a></span> | <span class="t">And then these are connected. They don't contain the values but they're connected</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=130" target="_blank">00:02:10.080</a></span> | <span class="t">to the values that we relate back to our keys. So that's a Python dictionary. That's our Python</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=137" target="_blank">00:02:17.440</a></span> | <span class="t">dictionary. But we're not wanting to minimize collisions. We are wanting to maximize the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=144" target="_blank">00:02:24.240</a></span> | <span class="t">collisions. So what we see here is a hashing function that maximizes those collisions. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=151" target="_blank">00:02:31.920</a></span> | <span class="t">this is essentially what LSH is doing. So we are attempting to, for any similar keys, so these here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=161" target="_blank">00:02:41.040</a></span> | <span class="t">and these here, they're all similar enough for us to want to put them into the same bucket. So we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=168" target="_blank">00:02:48.240</a></span> | <span class="t">put two of them into here and then the other three into this bucket. Now, there are quite</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=174" target="_blank">00:02:54.880</a></span> | <span class="t">a few different ways of doing this and there are a lot of different LSH methods. In fact, LSH is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=181" target="_blank">00:03:01.760</a></span> | <span class="t">a very generic term that applies to a lot of different algorithms. And the one that we will</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=187" target="_blank">00:03:07.280</a></span> | <span class="t">be covering is what I see as the traditional version. So it's the original version of LSH.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=194" target="_blank">00:03:14.400</a></span> | <span class="t">And what we'll be covering in this video is shingling, minhashing, and that LSH function.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=202" target="_blank">00:03:22.560</a></span> | <span class="t">So we'll get to understand why very soon. So here is the overview of the process that we're going to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=212" target="_blank">00:03:32.640</a></span> | <span class="t">be walking through. So we have shingling. So we have at the very start, we have this text. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=220" target="_blank">00:03:40.720</a></span> | <span class="t">flying fish flew by the space station. Now, that's just a string. And what we want to do is extract</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=230" target="_blank">00:03:50.400</a></span> | <span class="t">all of the unique pairs of text. So when we say shingling, it's K shingling. And in this case,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=239" target="_blank">00:03:59.840</a></span> | <span class="t">our K value is two because we're taking two characters at once. If we were to take</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=244" target="_blank">00:04:04.720</a></span> | <span class="t">K equals four, for example, then we would take like pace and then move on. We'd take ace and a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=253" target="_blank">00:04:13.200</a></span> | <span class="t">space and so on. So that's the shingling. And from that, we create a set. So if we have duplicate</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=263" target="_blank">00:04:23.120</a></span> | <span class="t">shingles, we remove those. So we just end up with one. So in this, I don't know if we do have any</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=271" target="_blank">00:04:31.360</a></span> | <span class="t">duplicates, but say maybe down here, we had IN again, because we also have it up here.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=278" target="_blank">00:04:38.400</a></span> | <span class="t">We would end up with just a single IN in the set. We wouldn't have two. And then we one-hot encode</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=284" target="_blank">00:04:44.800</a></span> | <span class="t">those. So that means we take a vocabulary from all of our text. So not just this one sentence,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=292" target="_blank">00:04:52.080</a></span> | <span class="t">but we'll have more than one sentence, obviously, that we're comparing. And we'll use that to build</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=296" target="_blank">00:04:56.560</a></span> | <span class="t">a one-hot vector from the vocab and our shingle set. Then we process that through something called</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=304" target="_blank">00:05:04.080</a></span> | <span class="t">a min hash function, which produces this dense vector or signature. So this thing down here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=312" target="_blank">00:05:12.560</a></span> | <span class="t">that is what's called a signature. And then we band that into this final bit here. This is our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=326" target="_blank">00:05:26.080</a></span> | <span class="t">actual LSH process. So we band that vector into multiple sub-vectors, and then we hash them. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=337" target="_blank">00:05:37.280</a></span> | <span class="t">where we find that we have any two sub-vectors go to the same hash bucket, then that means that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=344" target="_blank">00:05:44.160</a></span> | <span class="t">the full vector that they both come from is considered, or the two full vectors that they</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=351" target="_blank">00:05:51.040</a></span> | <span class="t">both come from are considered a candidate pair. And we take those and we then calculate some other,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=356" target="_blank">00:05:56.560</a></span> | <span class="t">we calculate the similarity between them. Okay. So the first step in our process,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=362" target="_blank">00:06:02.960</a></span> | <span class="t">like we discussed, is the shingling operation. So shingling is simply where we take a window</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=370" target="_blank">00:06:10.880</a></span> | <span class="t">of length K characters, and we simply move that down through our text, like you can see here.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=378" target="_blank">00:06:18.800</a></span> | <span class="t">And from that, we create the shingle set. So in Python, what we would do to shingle these three</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=388" target="_blank">00:06:28.720</a></span> | <span class="t">sentences we have here is we'll create a shingle function here. And this is going to take some</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=396" target="_blank">00:06:36.000</a></span> | <span class="t">text, which is a string. And we're going to say, we're going to define the K values of number of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=403" target="_blank">00:06:43.200</a></span> | <span class="t">characters we take within each window, which is obviously an integer. Now we initialize our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=409" target="_blank">00:06:49.600</a></span> | <span class="t">shingle set here, we'll make a string initially. And then what we do is for i in range, and then</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=419" target="_blank">00:06:59.280</a></span> | <span class="t">here we want to go from the, or we want to go to the length of our text, minus K. So minus that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=430" target="_blank">00:07:10.240</a></span> | <span class="t">window length, plus one, because we want to go right up to the end of that. And then here, all</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=436" target="_blank">00:07:16.000</a></span> | <span class="t">we do is shingle set.append. And then we write, so we have the text and we want to go from i up until</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=446" target="_blank">00:07:26.960</a></span> | <span class="t">i plus K. Okay, that's our shingle list, I suppose. And then we want to return a set. So this will</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=458" target="_blank">00:07:38.400</a></span> | <span class="t">remove any duplicates that we have. So shingle set. Okay, so that's our shingle function. And</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=466" target="_blank">00:07:46.160</a></span> | <span class="t">we just want to process each one of our sentences through that. So we'll go a equals shingle,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=475" target="_blank">00:07:55.520</a></span> | <span class="t">a. Also, we need to define K, which can be two. I'll just define K here.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=486" target="_blank">00:08:06.640</a></span> | <span class="t">Okay, and then let's have a look at what we have. And we see that we have this, it's shuffled,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=492" target="_blank">00:08:12.560</a></span> | <span class="t">there's no order to our set here. And we see that we have all of the pairs of words in there.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=501" target="_blank">00:08:21.440</a></span> | <span class="t">So we have S for the start of the space part here, or station actually, could be either.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=510" target="_blank">00:08:30.480</a></span> | <span class="t">And if we try and find, okay, so here we have the very sorts of fly, or flying of the ly there as</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=517" target="_blank">00:08:37.600</a></span> | <span class="t">well, i n. So that's, that's our shingle set. And with this, we have all of our shingles.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=526" target="_blank">00:08:46.480</a></span> | <span class="t">So the next step is to create our vocabulary, which is just all of our shingles,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=534" target="_blank">00:08:54.000</a></span> | <span class="t">our shingle sets, a union together. So to create that, all we do is go a union, b.union.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=543" target="_blank">00:09:03.600</a></span> | <span class="t">Like that.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=546" target="_blank">00:09:06.720</a></span> | <span class="t">And we can see again, we have just a lot more text in there now, or a lot more,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=555" target="_blank">00:09:15.120</a></span> | <span class="t">many more shingles. That is our vocab. So now we have our shingle set, and we have our vocab.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=563" target="_blank">00:09:23.840</a></span> | <span class="t">So we can tick both of those off. Now what we need to do is create our one hot encoding</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=570" target="_blank">00:09:30.960</a></span> | <span class="t">over here. And the only other thing we need is a zero vector. So there's two, well, I mean,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=579" target="_blank">00:09:39.200</a></span> | <span class="t">there's more than two ways to do this. But I think there's two ways of thinking about it. Normally,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=583" target="_blank">00:09:43.760</a></span> | <span class="t">the more efficient way would be to create a numpy array full of zeros, and then just</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=589" target="_blank">00:09:49.680</a></span> | <span class="t">add the ones in where we have matches between our vocab and shingle set. But I'm not going to do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=595" target="_blank">00:09:55.440</a></span> | <span class="t">that. I'm just going to keep things incredibly simple in the code that we're writing. So I'm</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=603" target="_blank">00:10:03.600</a></span> | <span class="t">going to do a, there's one hot. Or the one thing we should do is make this a list, because we want</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=610" target="_blank">00:10:10.640</a></span> | <span class="t">order in our vocab, and not have it shuffled. So the, what we do here is we say one for x in a,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=624" target="_blank">00:10:24.080</a></span> | <span class="t">or sorry, no. One if x is in a, else zero for x in vocab. So what we're doing here is looping</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=638" target="_blank">00:10:38.640</a></span> | <span class="t">through the vocab, and every single shingle within there, we're saying, if that exists in our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=645" target="_blank">00:10:45.600</a></span> | <span class="t">signature, make that point in our list a one. Otherwise, make it a zero. So that's simply our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=655" target="_blank">00:10:55.680</a></span> | <span class="t">one hot encoding. So if we do a, b, c, and then we have a look at our a one hot, we see that we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=666" target="_blank">00:11:06.000</a></span> | <span class="t">this one hot encoded, or this sparse array. Now, min-hashing is the next step in our process,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=674" target="_blank">00:11:14.960</a></span> | <span class="t">and it allows us to convert our, what are currently sparse vectors, into dense vectors,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=680" target="_blank">00:11:20.240</a></span> | <span class="t">which we call signatures. Now, what you see here is a run-through of how we do this for maybe one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=687" target="_blank">00:11:27.440</a></span> | <span class="t">signature. We want to do that for multiple signatures though, so we would actually run</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=692" target="_blank">00:11:32.400</a></span> | <span class="t">through this process multiple times. So what we're doing here is we're creating a randomly</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=697" target="_blank">00:11:37.680</a></span> | <span class="t">permuted array, which counts from one to the length of our vocab. And then what we are essentially</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=706" target="_blank">00:11:46.560</a></span> | <span class="t">doing, I know, so in this we're basically shuffling it, and then we're counting through until we find</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=712" target="_blank">00:11:52.080</a></span> | <span class="t">the first alignment to one within our vector. In reality, you just take all of your values,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=720" target="_blank">00:12:00.000</a></span> | <span class="t">and you find a minimum one that aligns to one. So that's if you're using NumPy, which we'll see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=727" target="_blank">00:12:07.280</a></span> | <span class="t">later on. I'll just show you the code, I'm not going to actually write all of it though.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=731" target="_blank">00:12:11.520</a></span> | <span class="t">So in code, that would look something like this. So we would start with a list, which is the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=742" target="_blank">00:12:22.000</a></span> | <span class="t">range from one to the length of our vocab. And if we have a look at that, we just see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=748" target="_blank">00:12:28.320</a></span> | <span class="t">a count. We're going to shuffle that, so from random import shuffle,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=755" target="_blank">00:12:35.600</a></span> | <span class="t">and we just do it like this. So it modifies it in place, so we don't need to do anything there. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=769" target="_blank">00:12:49.520</a></span> | <span class="t">let's view that. Okay, so now we've shuffled that, shuffled it twice now, but that's fine.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=782" target="_blank">00:13:02.160</a></span> | <span class="t">And let's just loop through five of those. So four, we can loop through more. For i in range</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=792" target="_blank">00:13:12.320</a></span> | <span class="t">from one to 10, what we're going to say is I just want to print</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=797" target="_blank">00:13:17.200</a></span> | <span class="t">i, which aligns to the hash example index for that value. Okay, if we print that, we see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=813" target="_blank">00:13:33.840</a></span> | <span class="t">so one, the value one, where is it? Here, is at index 85, two is at 53, and so on.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=826" target="_blank">00:13:46.560</a></span> | <span class="t">And essentially what we're doing here is saying loop through these, identify this index, and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=834" target="_blank">00:13:54.640</a></span> | <span class="t">this index in our one-hot vector, does it align to a one? You can see that here, we find the first</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=845" target="_blank">00:14:05.520</a></span> | <span class="t">one at eight. And that means that our signature value for this point is, or for this min hash</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=855" target="_blank">00:14:15.920</a></span> | <span class="t">vector and our one-hot sparse vector here, that signature value will be eight. And we repeat that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=864" target="_blank">00:14:24.080</a></span> | <span class="t">for multiple min hash vectors, which is what you can see here. So if we were to work through this,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=872" target="_blank">00:14:32.320</a></span> | <span class="t">so we start at one here, that does not align to a one. So we work up to two, and we find that it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=880" target="_blank">00:14:40.880</a></span> | <span class="t">does align to a one. So that is why we have this here. And then we go on to this one here, we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=888" target="_blank">00:14:48.720</a></span> | <span class="t">find one does not align, two still does not align, three does not align, and four does align. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=899" target="_blank">00:14:59.360</a></span> | <span class="t">then we assign a four in our min hash function. We go along and keep doing that to create our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=908" target="_blank">00:15:08.000</a></span> | <span class="t">signature. Okay, so if we, I'm going to use these functions here, it's just what we wrote before,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=913" target="_blank">00:15:13.920</a></span> | <span class="t">but put into a cleaner format. And what I'm going to do is create 20 min hash vectors,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=920" target="_blank">00:15:20.400</a></span> | <span class="t">run that. And then here we are going to run each of our one-hot sparse vectors through our create</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=932" target="_blank">00:15:32.240</a></span> | <span class="t">hash function, which is here. And it's going to convert them into our signatures as we described</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=938" target="_blank">00:15:38.080</a></span> | <span class="t">before. And we see here that we have also what I meant. So here we have 20 min hash vectors,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=945" target="_blank">00:15:45.760</a></span> | <span class="t">which means we have a length of 20 for each signature. So what we see here are our dense</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=955" target="_blank">00:15:55.680</a></span> | <span class="t">vectors. And these are just compressed versions of our sparse vectors. And we can check that that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=964" target="_blank">00:16:04.080</a></span> | <span class="t">is true by, we'll define a, we'll create a Jaccard similarity function. So we take,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=972" target="_blank">00:16:12.080</a></span> | <span class="t">and here we take x and y, both will be sets. And we just return the length of the intersection</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=981" target="_blank">00:16:21.520</a></span> | <span class="t">between both of those. So the intersection between those divided by the union of both of those. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=989" target="_blank">00:16:29.600</a></span> | <span class="t">that is how you calculate Jaccard similarity. This should be a y.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=999" target="_blank">00:16:39.120</a></span> | <span class="t">Okay. And then if we do Jaccard on both of those, so we have a sig, b sig.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1012" target="_blank">00:16:52.240</a></span> | <span class="t">These will have to be converted into sets, I forgot. So like that.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1017" target="_blank">00:16:57.680</a></span> | <span class="t">And then if we also take the Jaccard for, I think it's just a and b, right?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1028" target="_blank">00:17:08.880</a></span> | <span class="t">So I'm going to copy that. Okay. So we get, this is 0.6 and this is 1.4. Now, if we look up here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1042" target="_blank">00:17:22.400</a></span> | <span class="t">I think it's a and b are not supposed to be very similar. So that's fine. And then b and c should</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1048" target="_blank">00:17:28.320</a></span> | <span class="t">be similar. So if we swap this for c and then c here, we should both get higher values. And they</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1057" target="_blank">00:17:37.520</a></span> | <span class="t">should be roughly in the same ballpark. I mean, they're not perfect because we're using a very</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1061" target="_blank">00:17:41.920</a></span> | <span class="t">low number here. We're only using 20 values and typically use a lot more.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1068" target="_blank">00:17:48.960</a></span> | <span class="t">But that's fine. So you can see that they, they're both aligned, right? So despite converting these</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1076" target="_blank">00:17:56.720</a></span> | <span class="t">into the signature vectors, it recognizes that they are pretty similar. And converting these</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1083" target="_blank">00:18:03.360</a></span> | <span class="t">into signature vectors, it still recognizes that they are reasonably similar. So that's good.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1089" target="_blank">00:18:09.600</a></span> | <span class="t">That's what we want. Now, the final step in our whole LHS process is the LHS function itself.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1099" target="_blank">00:18:19.760</a></span> | <span class="t">So this is essentially what it does. So we have our signature over here, which we built</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1108" target="_blank">00:18:28.880</a></span> | <span class="t">using the steps that we just went through, which you can, you can see here. And from that signature,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1114" target="_blank">00:18:34.880</a></span> | <span class="t">we take a certain number of equal length subvectors. So we define that using this here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1123" target="_blank">00:18:43.440</a></span> | <span class="t">this b. So b is three. So that means we split our signature into three different subvectors,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1129" target="_blank">00:18:49.040</a></span> | <span class="t">which we see over here. And ideally, what we want to be doing here is saying, okay,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1139" target="_blank">00:18:59.680</a></span> | <span class="t">we process our subvectors each through a, either a different hash function, or it can be the same</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1146" target="_blank">00:19:06.320</a></span> | <span class="t">hash function, just as long as we use that same hash function for the equivalent subvector in</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1151" target="_blank">00:19:11.920</a></span> | <span class="t">another signature, which you'll see in a moment, it'll make sense. And, you know, once we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1157" target="_blank">00:19:17.920</a></span> | <span class="t">multiple signatures going together through those hash functions, you can see here that they're</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1162" target="_blank">00:19:22.240</a></span> | <span class="t">equivalent on both sides, hash one, hash one here. These can all just be a single hash function as</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1168" target="_blank">00:19:28.080</a></span> | <span class="t">well, which is what we're going to do. We're not really going to use a hash function. And what we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1174" target="_blank">00:19:34.000</a></span> | <span class="t">get here is three opportunities to identify these signatures as being potential candidate pairs,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1181" target="_blank">00:19:41.760</a></span> | <span class="t">which is where we consider it for further similarity comparisons. In this case,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1189" target="_blank">00:19:49.040</a></span> | <span class="t">hash threes both collide down here. So we say, okay, that means that a and b are candidate pairs.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1199" target="_blank">00:19:59.360</a></span> | <span class="t">I'm just going to put canned pairs. So this active of splitting our signatures up into</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1208" target="_blank">00:20:08.400</a></span> | <span class="t">multiple subvectors just gives us more opportunities to identify similarities,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1212" target="_blank">00:20:12.160</a></span> | <span class="t">because if we were to use the full vectors, the full vector would have to be very similar</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1219" target="_blank">00:20:19.600</a></span> | <span class="t">for them to be put into the same hash bucket. With this, we only part of it to be very similar. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1226" target="_blank">00:20:26.560</a></span> | <span class="t">increases the chances of us finding those similar signatures. So we're going to implement a very</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1232" target="_blank">00:20:32.720</a></span> | <span class="t">simple version of this. I'm going to keep this very simple. Here, we're just splitting our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1238" target="_blank">00:20:38.320</a></span> | <span class="t">signature vector. So we add our signature and b, which is the number of bands.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1242" target="_blank">00:20:42.800</a></span> | <span class="t">And the first thing we do is just make sure that our signature can be split into b bands</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1248" target="_blank">00:20:48.320</a></span> | <span class="t">equally. So where we take the remainder after the division here, it must be equal to zero.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1256" target="_blank">00:20:56.640</a></span> | <span class="t">And then we say, we need to calculate the rows. So the number of rows within each band,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1263" target="_blank">00:21:03.040</a></span> | <span class="t">we should just see the length of the signature divided by b. And then we initialize a subvector</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1269" target="_blank">00:21:09.520</a></span> | <span class="t">array or list. And then we loop through and append subvectors. Really simple, simple</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1278" target="_blank">00:21:18.160</a></span> | <span class="t">implementation. And let's apply that to b and c. So we have said that we want 10 bands. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1289" target="_blank">00:21:29.760</a></span> | <span class="t">we only have 20 items or 20 numbers within our signature vectors. So obviously, we only get</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1299" target="_blank">00:21:39.760</a></span> | <span class="t">bands of two rows at a time. And we should find that at least one of those match. So what we do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1307" target="_blank">00:21:47.840</a></span> | <span class="t">is we loop through and we say, if b rows equals c rows, break. And we find very quickly that there</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1317" target="_blank">00:21:57.040</a></span> | <span class="t">is a candidate pair there. So that means that b and c, the full vectors, would be considered as</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1323" target="_blank">00:22:03.040</a></span> | <span class="t">a candidate pair. Let's do the same for a. And we should find, OK, so for both a and b and a and c,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1332" target="_blank">00:22:12.720</a></span> | <span class="t">it's not considered a candidate pair because there's just no similarity there. So that's good.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1338" target="_blank">00:22:18.320</a></span> | <span class="t">That's exactly what we wanted to happen. That is our implementation of this. So the LSH,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1346" target="_blank">00:22:26.080</a></span> | <span class="t">traditional LSH approach. Now, a few other things that we haven't covered but we should</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1355" target="_blank">00:22:35.440</a></span> | <span class="t">just touch on quickly. And you can find-- so there's an article link in the description</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1361" target="_blank">00:22:41.840</a></span> | <span class="t">which covers this. I walk through all of this. And there will also be a notebook where I'm getting</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1367" target="_blank">00:22:47.920</a></span> | <span class="t">these results from in the first place. So you can also look at that. That includes the NumPy</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1372" target="_blank">00:22:52.800</a></span> | <span class="t">implementations of what we've just done, which is slightly more efficient, although not super</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1379" target="_blank">00:22:59.680</a></span> | <span class="t">efficient because I want it to still be readable. So what we have here is a visualization that shows</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1388" target="_blank">00:23:08.080</a></span> | <span class="t">the similarity, the cosine similarity, of our signature vectors and whether they were considered</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1394" target="_blank">00:23:14.960</a></span> | <span class="t">as candidate pairs or not. So these up here, these are our candidate pairs. This is just</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1405" target="_blank">00:23:25.840</a></span> | <span class="t">a random sample. I think the actual full data set is really big. So running this, all of them,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1411" target="_blank">00:23:31.360</a></span> | <span class="t">is super inefficient because we're also running everything else through. So I can actually</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1416" target="_blank">00:23:36.640</a></span> | <span class="t">have the visualization here. But if you run just LSH on it, it does work just fine.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1423" target="_blank">00:23:43.600</a></span> | <span class="t">So at the top there, we have our candidates. At the bottom, we have our non-candidates. We</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1429" target="_blank">00:23:49.280</a></span> | <span class="t">have similarities. So you can see that high similarity does correlate with them being</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1432" target="_blank">00:23:52.880</a></span> | <span class="t">classified as candidate pairs, which is good. It's obviously what we want. And there is this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1439" target="_blank">00:23:59.600</a></span> | <span class="t">formula that I did not write down, which I should have done, which is p equals 1 minus 1 minus s,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1449" target="_blank">00:24:09.120</a></span> | <span class="t">which is our similarity down here, to the power of r, which is the number of rows in each band,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1454" target="_blank">00:24:14.960</a></span> | <span class="t">and all of this to the power of b, which is the number of bands. Now, that correlates to this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1463" target="_blank">00:24:23.360</a></span> | <span class="t">line here, this probability. Obviously, it's P, capital P. So that's where it's coming from.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1469" target="_blank">00:24:29.920</a></span> | <span class="t">And if we run this with different similarity values, this is the pattern that we get.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1477" target="_blank">00:24:37.840</a></span> | <span class="t">And obviously, that correlates, you can see, with whether something is classified as a candidate</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1483" target="_blank">00:24:43.680</a></span> | <span class="t">pair or not. And what we can do is we can modify b to push the number of candidate pair</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1494" target="_blank">00:24:54.240</a></span> | <span class="t">classifications either up or down. So here, we have different b values. At the side, we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1501" target="_blank">00:25:01.360</a></span> | <span class="t">black, which is 50. Then we go 25, 20, which is what we used before, and 5. So let's say we found</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1510" target="_blank">00:25:10.000</a></span> | <span class="t">that we're not identifying enough candidate pairs. We could push that down a little bit. Maybe we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1514" target="_blank">00:25:14.960</a></span> | <span class="t">don't do too much. So we could change b from 20 to 25. And if we do that, we see this. So in green,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1522" target="_blank">00:25:22.880</a></span> | <span class="t">you have our old results and our old probability line. And then in blue and pink, we have the new</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1530" target="_blank">00:25:30.480</a></span> | <span class="t">ones again, or blue and magenta. So what we see here is we've pushed that down. So we've changed</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1540" target="_blank">00:25:40.400</a></span> | <span class="t">b to 25. And now we're returning more results. So over here, we have these, for example,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1548" target="_blank">00:25:48.960</a></span> | <span class="t">which we're not returning before. And there are also more values in here as well. And there are</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1554" target="_blank">00:25:54.720</a></span> | <span class="t">less values down here. So that's the result of us modifying b. So we can visualize that. So if we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1565" target="_blank">00:26:05.600</a></span> | <span class="t">increase b, we move it in this direction, which increases the number of candidate pairs,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1577" target="_blank">00:26:17.680</a></span> | <span class="t">which also increases the number of false positives that we're going to return. This</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1582" target="_blank">00:26:22.320</a></span> | <span class="t">line, by the way, is our threshold. It's a similarity threshold. This is basically where</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1586" target="_blank">00:26:26.480</a></span> | <span class="t">we want the cutoff to be between things being identified as candidate pairs and not candidate</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1591" target="_blank">00:26:31.440</a></span> | <span class="t">pairs. It's like our target, almost. Or if we wanted to reduce the number of candidate pairs,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1599" target="_blank">00:26:39.440</a></span> | <span class="t">because maybe we're getting too many false positives, we can push it this way, which will</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1605" target="_blank">00:26:45.360</a></span> | <span class="t">result in less candidate pairs, but also results in more false negatives. So non-candidate pairs</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1615" target="_blank">00:26:55.200</a></span> | <span class="t">where we should have candidate pairs. So it's just a case of balancing both of those. But that's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=e_SBq3s20M8&t=1620" target="_blank">00:27:00.640</a></span> | <span class="t">everything for this video. I hope it's been useful. And I will see you in the next one.</span></div></div></body></html>