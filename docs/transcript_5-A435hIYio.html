<html><head><title>New Features in Python 3.10</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 80%;
        margin: auto;
        overflow: hidden;
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>New Features in Python 3.10</h2><a href="https://www.youtube.com/watch?v=5-A435hIYio" target="_blank"><img src="https://i.ytimg.com/vi/5-A435hIYio/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=5-A435hIYio&t=0 target="_blank"">0:0</a> Intro<br><a href="https://www.youtube.com/watch?v=5-A435hIYio&t=45 target="_blank"">0:45</a> Type Annotations in Python<br><a href="https://www.youtube.com/watch?v=5-A435hIYio&t=70 target="_blank"">1:10</a> Typing Union Operator<br><a href="https://www.youtube.com/watch?v=5-A435hIYio&t=127 target="_blank"">2:7</a> Parenthesized Context Managers<br><a href="https://www.youtube.com/watch?v=5-A435hIYio&t=307 target="_blank"">5:7</a> Structural Pattern Matching<br><a href="https://www.youtube.com/watch?v=5-A435hIYio&t=571 target="_blank"">9:31</a> Better Error Messages<br><h3>Transcript</h3><div class='max-width'><p>Hi and welcome to this video. We're going to explore what is new in Python 3.10. There are a few different things I want to cover there. We have some more additions to typing, which I think are pretty cool. The parenthesized context manager, which is kind of an interesting update because it's not really an update, so we'll get into that pretty soon. We have structural pattern matching, which I've covered before, and we're just going to run through it really quickly in this video. And then there is also a load of new error messages, which are pretty interesting, actually. There's some really good ones in there. So we'll go through all of those new features in Python 3.10. Okay, so in the last few iterations of Python, there's been a steady improvement of the Python's type hinting or type annotations capabilities. And with Python 3.10, we are seeing more of that again. Now, there's a few changes or a few updates and features with the typing in Python 3.10, but I think the most interesting one is the addition of a new operator. So this is what we used to have to do in Python 3.9 and before. So in here, I'm just defining really simple function that adds two integers or floats together. Now, if we want to define x and y as being potentially an integer data type or a float data type, then we would have to use this union operator, which we would import from typing up here. Now, with Python 3.10, we don't have to do that anymore. It's much simpler. All we do is include the pipe character here, which is our new union operator, which obviously it looks a lot cleaner. So that's the main new feature with type annotations in 3.10. So let's move on to the new parenthesize context manager. Okay. So what we're talking about when we talk about context managers is exactly what you can see on the screen now. So we have, this is the most common example of a context manager in Python. And this is just how we read in our files. So we have with, so this is setting up our context. And here we are assigning this stream here as F. Okay. And then within this indented area, we can read F, but outside of it, we can't. So we couldn't write something like text equals F dot read, because in this case, F just doesn't exist outside of that context. So that's what we mean by context manager. Now, if we wanted to open multiple context managers within the same area, we could write something like this. So we'd have with open and we have another open afterwards, and then we would be able to access both of those within this indented area. The only problem is that we would have to keep all of this on the same line due to limitations with Python's previous parser. Now, the parser got updated in Python 3.9, which is why I say this is kind of not really a new update, but it is a new update. So before then, we had to keep everything on a single line. And we can get around that a little bit by adding the line continuation character, and this would work as well. But the problem with this is that it's not technically Pythonic, which I mean, for most people, it doesn't really matter. But now what has been added, thanks to the new Python parser, which introduced in 3.9, is we can include parenthesized context managers. So we can add these inside brackets. And that will now work. And this is officially a new feature for Python 3.10. But we can actually switch back to Python 3.9. And if I run this again, we see that it still works. So that's kind of weird, right? Now, the reason for that is that the parser, the new parser introduced in 3.9, allows this syntax to work. But it was not added as a genuine new feature until Python 3.10. Now, why that has been done, I really can't tell you because I don't understand. But that is just how it is. Now, if we take this back one version further to 3.8, we see that we do actually get the invalid syntax. So this is a new feature, but it's also not a new feature. So yeah, that's a strange one. Now, the next one, which I think is probably the most hyped new feature of 3.10, and with good reason, it is very cool, is the structural pattern matching. Now, we can write this statement here. And this is just a simple example. We're going to move on to a real example in a moment. This is an if-else statement. And we're just checking this code. We can run that without a problem. And some new syntax has been added in Python 3.10. And that is the match case statement. So this is the equivalent of what we did up here, but using the new match case syntax, which, OK, that's interesting. It's cool. But it doesn't really bring us anything new. We could just do that with a if-else statement before. So that's not particularly interesting. But what is interesting is the structural pattern matching part of this new syntax, which allows us to do this match case comparison. But rather than specifying whether that HTTP code is an exact match to whatever values are in those case statements, we can check the structure of a object and check if it matches a pattern which we pass through the case statement, which is very, very cool. Now let's see how that works. So if I remove these two, I'm going to define a dictionary here. So dictionary A and dictionary B. Now, these two both contain similar information, but they're in a different structure. So that means that we would have to access both of these using different paths. Now, what we can do is create a pattern that matches both of these and add them both within a match case statement. And we can use that to check which pattern we have and perform a different operation on each one. So to do that, first, so this is our code. We're going through in a loop through dictionary A, dictionary B, and I've just added this string called test that shouldn't match to anything because it's just a string. Okay. So looping through each of those, and we're going to test the match case on each one. So first, so we're matching here and then we have our case. And then here is our pattern. So this is a pattern we want to match. Now, if we compare that pattern, we'll see that we have ID and meta, ID and meta, and inside meta, we have another dictionary, which contains source and location. And here we have source and location as well. Now this doesn't need to be perfect match, by the way, we could, this would also match if I got rid of location like that. And obviously we'd have to go to loc here as well. So it doesn't have to be a perfect match, just as long as whatever you have entered does fit into the structure that we are comparing against. Now that's the first one, but that will not match to this because we don't have the meta key and the meta does not contain no dictionary. Okay. And in dict B, but it does match this one, which is ID source and location. Same as this one here. So that will match. And then here we have our catch all statement. So this is like our else statement, and this will just catch any items that do not match either of those cases, e.g. our test at the end there. So let's run that and see what it prints. Okay. So we see that we get the first one. So it manages to extract, ident, source and loc, and print those all out. And then for the second one, it does the same, even though they're a different structure because it matches to this different case. And then here we have our catch all and we print out no match. So this, I think easily is the coolest feature in 3.10. And I've already found it useful for processing data in a similar way to what I'm showing here. So it's, in my opinion, super cool and something to be excited for. So let's move on to our final new feature, which are the new and improved error messages. Okay. So let's move on to the new error message in 3.10. So they've done quite a few new messages here that are just a lot easier to understand. So for example, if we take this unclosed dictionary in 3.9, we get this unexpected EOF while parsing. EOF means end of file. So this basically is telling us that the parser has gone all the way to the end of the file and it hasn't found the closing bracket of our dictionary. And okay, fair enough. Once you've been using Python for a while, you know what it means, that's fine. But this isn't particularly clear, especially if you're new to Python. I mean, I'm certain that the first time I got this error, and I'm certain that almost everyone, the first time I got this error, will have had to Google what this means. Now in Python 3.10, now it's really simple. It's telling us that our dictionary was never closed, which is much better. Now in the same sort of area, we also have unclosed strings where we get this EOL, which is end of line. And that means the same thing again, saying we've got to the end of the line and your string isn't closed. Now in Python 3.10, rather than that, we get this untermated string literal, and that's just so much easier to understand. Another one is assignment versus comparisons. So obviously here we should have a double equal sign because we're comparing, we're not making two equal to three. So if we run that, we just get invalid syntax. Now for us, obviously we know what's going on there, but maybe if you're new to the language, it might not be so clear. So now what we get is cannot assign to a literal here. Maybe you meant double equal sign, not a single equal sign. So a lot clearer again. Now another area that I think is pretty interesting, although I can't seem to get it working at the moment, is where we enter a incorrect attribute name. So usually we get this attribute error, and that is essentially what we will also get over here in Python 3.10. But as well as this, although we don't see it here, we should also get a suggested attribute name based on whichever attribute has the closest match. Now I'm not sure why it doesn't work here, but if we take a look here on the actual What's New Python page, we can see that this should give us a recommendation of do you mean named tuple, which I think is pretty cool. And we should also get the same with named errors as well. So if we have this new variable on the left, we'll see that we get this name error. New VR is not defined because we have a typo. It's fine. And then in Python 3.10, what we should find is that this will also recommend, hey, this isn't quite right. Maybe you meant new VR. And we can see this in this example here on the What's New page. So overall, I think those new error measures are definitely a lot clearer. And they're probably going to help a lot of people. So that's really good to see. Okay, so that's everything for this video. I hope it's been useful. And I will see you in the next one.</p></div></div></body></html>