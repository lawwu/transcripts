<html><head><title>LangChain Interrupt 2025   Uber   Agentic Developer Products with LangGraph – Sourabh Shirhatti</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>LangChain Interrupt 2025   Uber   Agentic Developer Products with LangGraph – Sourabh Shirhatti</h2><a href="https://www.youtube.com/watch?v=pntF0_t8184" target="_blank"><img src="https://i.ytimg.com/vi/pntF0_t8184/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>What we think we can make the most important role is always learning, that's why we're here, see what everyone else is up to and see what else we can target. And lastly, what I was going to say is the kind of pillar of our strategy is we don't want to build the right, we call it cross-current derivatives.</p><p>There's a lot of traditional analytics that pretty much align all your solutions, your property dealer too, and having the right abstractions in place, the right frameworks, like tooling, helps us build more solutions and build them faster. And lastly, what I was going to say is probably the cornerstone of this strategy is what we call intentional background stuff.</p><p>We've taken a better on a few product areas, we want to build them, we want to build them as fast as possible, but we do stop and be deliberate about, hey, what here is useful? What can we spun out into something that reduces the value for the next problem we want to solve?</p><p>And so, LandEffects is our integrated framework we built, that helps, like LandDrop and LandChain, it makes it work better with Uber systems. And it was born out of necessity, right? We had the first couple of products emerge, and they wanted us all. The problems in HR, they expanded it, they wanted us to build a new system in the north, and LandDrop was the first thing to do it.</p><p>Because we saw this proliferating from the organization, we made it available, and we built a new data framework around it. So, you know, I think enough of the view, let's dive into one of the products, one of the students validate it. Yeah, absolutely. So, the first product showcases the ASL validator.</p><p>Now, what it is, is that the NIDs, like I said, blackout, dash-backed discrimination for security issues for engineers, and code, automatically. So, it is effectively a man-ground region that pulls a nice ID U.S. around. And, you know, let's take a look at how it works. So, we have this feature here, that shows a user opening build file.</p><p>And, what they have in there is, they notified of a violation in this case. So, they have a little bit of a typos that they can mouse over. And they get a nice photo, saying, "Hey, in this case, you're using the incorrect method to create a temporary test file.</p><p>You know, this will leak into closing, and you want to have it automatically get up for you." So, what do you do about it? What can the user do? Well, they have multiple choices. They can apply a pre-computed fix that they have to share for them in the background.</p><p>Or, if they choose so, they can ship off the fix to their ID identity system. So, that's what we have in the text line, actually. The fix provides them to ship out, and we log back with the fix from the ID. So, the issue is no longer present, and the user tagging into the issue is resolved.</p><p>So, that's super. Some of the key ideas that we found out about building this. The main thing is that the agent abstraction allows us to actually compose multiple sub-agents under a central validator, for example. So, we have a, you know, sections, a sub-agent for validator that calls into that a list of practices and sort of gets those points of feedback.</p><p>Dissolved or returned. But, there's also an interesting fit, where, for example, we want to discover link issues from data vendors. So, if there's nothing stopping us from running a link tool, and then passing on to the rest of the graph, that allows us to, you know, re-comput it even for those.</p><p>So, that's the 30. And, in terms of impact, you know, we've seen thousands of fixed interactions today from data side engineers that fix their problems in code before they come back later to find them. And, I think, you know, we think we've built a compelling experience today. Like, we met developers where they are in the ID team.</p><p>We have to link that onto the background. We just combine, you know, we don't use the capabilities like we use case part of Google. We find our way to the desk boundary live. We're able to evaluate issues against a set of curated best practices, lack of violations. And, comfortably, the most expressive way to deliver this back to the user.</p><p>Short of the ID. Give them a way of applying fixments. But we thought, why stop there? For sure. So, why stop and validate? Let's help engineers by welcoming their tests from the get-off. Now, you know, the second thing we're showing you up here is called AutoCover. And, it is a tool to help engineers build, or generate, rather.</p><p>Building, passing, coverage raising, business case testing. And, you know, validate and implementation testing tests. So, like, really high quality tests, what we're showing you for here. And, the intent is to save the engineer time. So, they're all built. And, you want to get there just quickly, and move on to the next business feature that you want to implement.</p><p>So, the way we got to do this is, actually, we took a bunch of experts doing expeditions. We actually threw in the validator there, as well, and warned that later. And, we arrived at the test generation tool. So, let's take a look at our works. We have a screenshot of, you know, a source graph, as an example.</p><p>And, the user can, you know, invoke it in a lot of other ways. If they want to open for the whole file, and sort of both generate, they can do a right-click, as shown in the screenshot, and just invoke it. And, at once, the user clicks the button. What happens next is a whole bunch of stuff happens in the background.</p><p>So, we start with adding a new target to the built system. We, you know, we set up a test file. We run an initial coverage check to get a sort of target space for us to operate on. All while that is being done, we also analyze the surrounding source to get the business markets out, so that we know what to test against.</p><p>And, what the user sees really is just, they get switched to an empty test file. In this case, it can also be populated. And then, because we did all that stuff in the background, we're starting to already generate tests. And, what the user will see is, there's a stream of tests coming.</p><p>And then, the file will be constant flux. There will be tests coming in at a fast speed. We will build. This does the fast. We'll take it out. Some tests might get converged. Some tests might get removed because they're redundant. You might see benchmark, like concurrency tests come in later.</p><p>And so, you know, the user is sort of watching this experience. And then, at the end, we're running a nice set of validated beta tests. That's what we want. That's the magic we want for our users here. Yeah, and that's what we want. Let's dive a bit deeper into the graph here to see how it actually functions.</p><p>So, here's the graph. Now, on the bottom right, you can actually see value there, which is the same agent that we just talked about previously. So, you can already see some of the composability learnings that we found useful. But, so how do we arrive at this graph? We look at the sort of heuristics that an engineer would use while writing tests.</p><p>And, so for example, you want to prepare a test environment. You want to think about which business, in this case, to test. That's the job of a scaffolder. Then you want to think about new test cases. Whether it be for extending existing tests or just writing new tests altogether.</p><p>That's the job of a generator. And then you want to run your builds, your tests. And then if you, you know, those are passing, you want to run a coverage check to see what you missed. That's the job of an expert. And so, we go on to, you know, complete the graph this way.</p><p>And then because we don't, no longer have anyone involved, we can actually supercharpe the graph. Sort of juice it up so that we can do a hundred iterations of code generation at the same time. And another hundred executions at the same time. We've seen, you know, for a sufficiently large source file, you can do that.</p><p>And that's sort of where our key learning comes in. We found that having these super capable domain expert agents gives us unparalleled performance. Sort of exceptional performance compared to other agendic coding tools. We benchmarked with the industry agendic coding tools that are available for test generation. And we get about two, three times more coverage in about half the time compared to them.</p><p>because of the speed ups that we did in creating this graph view. And sort of the custom bespoke knowledge that we built into our agency. And in terms of impact, we have, the school has helped raise the whole developer platform coverage by by 10%. So that maps to about 21,000 that are saved, which we're super happy about.</p><p>And we're saying continue to use of thousands of test generated monthly. So, yeah, that's very happy about that. I'm sorry, take us through some more questions. Yeah, so we don't want to stop it, but I would just mean, like, we built this primitive, right? We're going to give you a sneak peek of what else we've been able to do when we organize this with this.</p><p>So what you see on the screen right now is our hoover assistant builder. Think of it like our internal custom GPT store where you can build jackpots that are, you know, steep to hoover knowledge. So, like, one of them you see on the screen is the security score bar.</p><p>And it has access to some of the same tools that we showed you. You know, it's conceived of who's best practices. It can detect security at that battery. So even before I get to the point of I'm getting my ID right forward, I can ask questions about architecture, figure out whether my implementation is secure or not, right?</p><p>Same primitives, power, different experience. Next up we have Picasso. Picasso is our internal workflow management platform. And we build a contractual AI, as well as GD. I got that. It understands workflow automation. It understands the source of truth. And it can give you feedback, grounded in product, through, like, aware of what the product does.</p><p>The other thing I want to show you, and this is not an exhaustive list, right? Is our tool called Q2View. Obviously, we build stuff in the ID. We try and flag at the values earlier in the process. But sometimes things also need to track. You know, why not reinforce the major qualities and force before, you know, what gets landed, before your VR gets merged.</p><p>So, again, Power could some of the same tools that you saw earlier in Power, like Validator, and Death Generator. We're able to flag, you know, both of you comments and both suggestions that developers can apply during the view panel. I think with that, we'll just jump over to the learnings.</p><p>Yep, it's awesome. So, in terms of the learnings, we already sort of talked about this, but we found that building domain expeditions that are streamable are actually the way to go to get outside results. So, they use hotness better. You can upload things in which state. They use loosely less.</p><p>And then, you know, the outgoing result is much better. So, an example that I already talked about is the execute agent. So, we're able to connect our load system to allow us to, on the same file, execute the hunting tests, on the same test map, without writing, and then also get separate coverage reports.</p><p>That's an example of a domain expeditions that's super capable and gives us that performance that we want. Secondly, we found that when possible, composing agents with deterministic subagents, or just have the whole agent deterministic, makes a lot of sense. If you can solve the problem, you have deterministic weight.</p><p>So, you know, one example of that is the lit-agent undervalidator. We want to have reliable output. And if we have deterministic tools that we get to give out that intelligence, we need to allow, we can have that reliable, often pass on the learnings to the rest of the graph and have them fixed.</p><p>And then, third, we found that we can scale up our data efforts quite a bit by solving a problem by creating an agent and then using it in multiple applications. So, you already saw it with the statin-blown experience and the value of the part of our test generation valuation.</p><p>But I'm going to give you one more lower-level example. That's the build system agent. That's actually used for both of the products. That's the lower-level abstraction that is required for us to be able to, you know, have the agents be able to execute builds and execute tests in our build system.</p><p>So, Sorak, I think it's supposed to be a strategic learning. Yeah. So, I might have talked to us about some of the tech benefits, but this is the one I'm probably most excited to share. Like, you can set up your organization for success if you want to build a agent with AI.</p><p>I think we've done a pretty good job of it at Cooper. We haven't developed an AI on-trades. We're all building in collaboration and I think these are our biggest takeaway. The third thing is, you know, encapsulation with collaboration. So, when there are well-thought-out abstractions like Landgraf and there are opinions on how to do things like handle, state management, how to deal with the currency, it really allows us to scale development horizontally.</p><p>Let's just tackle more problems and more complex problems without creating this operational model entry. An example I'll give you is, our security team was able to guide tools for validated like the the product we did earlier. It's able to guide security on that matter. The security team knew nothing about this part of security.</p><p>They knew nothing about AI agents and how they're constructed. But they were still able to add value into the large part of all the works. And so, like a natural segue from that is if you're able to encapsulate, you know, work into these well-defined works. Then, like graphs are the next thing to think about, right?</p><p>Like graphs are the next thing to think about, right? Like graphs model these interactions perfectly. They often have to mirror how developers already interact with the system. So, when we do the processing process engineering and identify process bottlenecks of inefficiency, it doesn't just help accelerate or boost the AI workflows.</p><p>It also helps improve the experience for people not even interacting with the AI tools, right? So, it's not like a haunt or should we relate to this or should we improve our existing system. it usually segments into, like, helping each other. Like, you know, we talk about our agenting test generation and we find multiple inefficiencies through, like, how are you doing mock generation quickly?</p><p>How do you modify build files that will, like, interact with the build system? Are you going to execute the depths? And in the process of, like, fixing all these paper cuts, we improve the experience for just, like, non-TAG applications for developers to interact with our systems. And it's been hugely beneficial.</p><p>And, you know, with that, I want to bring this up to Penny. We really enjoyed presenting here. Thank you for the opportunity. Hopefully, you all learned something and we'll take something back to your documents. Thank you. Thank you.</p></div></div></body></html>