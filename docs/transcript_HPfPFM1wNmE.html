<html><head><title>Best hidden feature of Python | Chaining comparison operators</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 80%;
        margin: auto;
        overflow: hidden;
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Best hidden feature of Python | Chaining comparison operators</h2><a href="https://www.youtube.com/watch?v=HPfPFM1wNmE" target="_blank"><img src="https://i.ytimg.com/vi_webp/HPfPFM1wNmE/maxresdefault.webp" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>This is a hidden feature of Python that I recently came across, the chaining of comparison operators that is not available in almost any mainstream programming language. I think it's elegant and intuitive and doesn't make any sense to me why it's not available in most languages. So what is it?</p><p>Say we assign the values 2 and 3 to x and y, and then look at a single statement that includes several comparison operators chained together, 1 less than x less than y less than 4. In Python this evaluates to true. The way Python evaluates the statement is the same way that we would intuitively or mathematically look at the statement, which is as a chain of binary comparison operators.</p><p>1 is less than x and x is less than y and y is less than 4, which again evaluates to true. Now you can use any comparison operator, less than, greater than, less than or equal to, greater than or equal to, and mix and mash them together in a single arbitrarily long chain of comparison operators.</p><p>Now if we change the original statement to include a greater than operator as the last comparison, then the entire statement returns false because y which is equal to 3 is not greater than 4. And then finally again we can flip the 4 and the y to make the statement return true because all the individual comparisons are true.</p><p>1 is less than x which is equal to 2, x is less than 4, and 4 is greater than y, y being equal to 3. Now this feature is available in a few other languages, not many, like Perl 6 or Reiku, I think it's been renamed to, not sure how to pronounce it, and Julia.</p><p>And as shown here it's also a first class citizen in some functional languages like Scheme, Common Lisp, and Closure, with the added constraint that the chaining of the operator includes only the same operator, so you can't mix and match. So shown here the greatest language of all time which is Lisp, the equals operator applied to a list of numbers, 3 and 3 returns true, 3 and 5 returns false, all 3s returns true, all 3s except one of them being 5 returns false.</p><p>So again that's chaining the equality comparison operator across the entire list. And the same is true for the less than operator applied to the entire list. Below 3 less than 5 is true, and then a long sequence returning true if it's in strictly increasing order, and false if it's not in strictly increasing order.</p><p>I put some links in the description. One of the more interesting ones is in the Software Engineering Stack Exchange which discusses from a semi-philosophical perspective why most mainstream languages do not include this feature. You should check out some of the answers on that page. But to summarize some of the discussion, the reason to do it is despite the initial intuition about this feature being difficult to implement, it's actually very easy to implement.</p><p>And as I said it's a mathematically intuitive and just elegant statement which I think makes it one of the best hidden features, at least to me, of Python. In the discussion the reasons that come up not to do it is fundamentally just laziness in that its importance versus other features is quite low, and it doesn't seem to be the kind of feature that pops up as an intuitive first feature to implement when the language is first born.</p><p>And as with certain other features this can potentially break backward compatibility if this kind of chaining operators was allowed previously, syntactically speaking, meaning it was allowed but it didn't do the intuitive thing, it can certainly break in quite painful ways backward compatibility. But still, as I said in the previous video, list comprehensions I think is the best feature of Python, and the chaining of comparison operators I think is the best hidden feature, or not well-known feature, of Python.</p><p>Quick shout out to ExpressVPN. Click their link in the description. It's the best way to support the podcast I host and these videos that I make. If you enjoy these, subscribe, and remember, try to learn something new every day. you you you you you you you you you you you you you you you you you you you you you you you you you you</p></div></div></body></html>