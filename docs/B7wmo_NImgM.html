<html><head><title>Choosing Indexes for Similarity Search (Faiss in Python)</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 80%;
        margin: auto;
        overflow: hidden;
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">back to index</a><h2>Choosing Indexes for Similarity Search (Faiss in Python)</h2><a href="https://www.youtube.com/watch?v=B7wmo_NImgM"><img src="https://i.ytimg.com/vi/B7wmo_NImgM/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=0">0:0</a> Intro<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=53">0:53</a> Getting the data<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=153">2:33</a> Flat indexes<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=447">7:27</a> Highlevel indexes<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=961">16:1</a> Coding<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1282">21:22</a> Performance<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1360">22:40</a> Inverted File Index<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1568">26:8</a> Implementation<br><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1790">29:50</a> Summary<br><br><div style="text-align: left;"><a href="./B7wmo_NImgM.html">Whisper Transcript</a> | <a href="./transcript_B7wmo_NImgM.html">Transcript Only Page</a></div><br><div style="max-width: 800px;"><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=0" target="_blank">00:00:00.000</a></span> | <span class="t">Hi welcome to the video. I'm going to take you through a few different indexes in FISE</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=5" target="_blank">00:00:05.980</a></span> | <span class="t">today so FISE for similarity search and we're going to learn how we can decide which index</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=11" target="_blank">00:00:11.940</a></span> | <span class="t">to use based on our data. Now these indexes are reasonably complex but we're going to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=19" target="_blank">00:00:19.420</a></span> | <span class="t">just have a high level look at each one of them. At some point in the future we'll go</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=24" target="_blank">00:00:24.940</a></span> | <span class="t">into more depth for sure but for now this is what we're going to do. So we're going</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=29" target="_blank">00:00:29.580</a></span> | <span class="t">to cover the indexes that you see on the screen at the moment. So we have the flat indexes</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=33" target="_blank">00:00:33.540</a></span> | <span class="t">which are just plain and simple nothing special going on there and then we're going to have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=38" target="_blank">00:00:38.380</a></span> | <span class="t">a look at LSH or locality sensitive hashing, HNSW which is hierarchical navigable small</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=46" target="_blank">00:00:46.460</a></span> | <span class="t">worlds and then finally we're going to have a look at an IVF index as well. So first thing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=54" target="_blank">00:00:54.020</a></span> | <span class="t">I'm going to show you is how to get some data for following through this. So we're going</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=58" target="_blank">00:00:58.340</a></span> | <span class="t">to be using the SIFT1M dataset which is 1 million vectors that we can use for testing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=65" target="_blank">00:01:05.660</a></span> | <span class="t">similarity. Now there's a little bit of code so I'm just going to show it to you. So we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=70" target="_blank">00:01:10.500</a></span> | <span class="t">have here we're just downloading the code. There'll be a notebook for this in the description</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=77" target="_blank">00:01:17.540</a></span> | <span class="t">as well so you can just use that and copy things across. But we're downloading it from</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=83" target="_blank">00:01:23.840</a></span> | <span class="t">here and this will give us a tar file. So we download that and then here all we're doing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=90" target="_blank">00:01:30.740</a></span> | <span class="t">is extracting all the files from inside that tar file. And then here I'm reading everything</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=99" target="_blank">00:01:39.120</a></span> | <span class="t">into the notebook. So inside that tar file we get these FVEX files and we have to open</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=106" target="_blank">00:01:46.380</a></span> | <span class="t">them in a certain way which is what we're doing here. So we're setting up the function</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=111" target="_blank">00:01:51.100</a></span> | <span class="t">to read them, sorry, here. And then here I'm reading in two files. So we get a few different</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=117" target="_blank">00:01:57.340</a></span> | <span class="t">files here. So I'm sorry this should be SIFT. So we get the base data which is going to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=128" target="_blank">00:02:08.420</a></span> | <span class="t">be the data that we're going to search through and then we also have query data here. And</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=133" target="_blank">00:02:13.100</a></span> | <span class="t">then what I'm doing here is just selecting a single query or single vector to query with</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=138" target="_blank">00:02:18.540</a></span> | <span class="t">rather than all of them because we get quite a few in there. And then here we can just</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=142" target="_blank">00:02:22.340</a></span> | <span class="t">see so this is our query vector, the XQ. And then we also have WB here which is going to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=147" target="_blank">00:02:27.300</a></span> | <span class="t">be the data that we'll index and search through. And we can see some of it there as well. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=153" target="_blank">00:02:33.580</a></span> | <span class="t">that's how we get data. Let's move on to some flat indexes. So what you can see at the moment</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=162" target="_blank">00:02:42.620</a></span> | <span class="t">is a visual representation of a flat L2 index. Now up here, this is what we're doing. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=173" target="_blank">00:02:53.700</a></span> | <span class="t">we're calculating, we have all of these points. So these are all of the WB points that we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=178" target="_blank">00:02:58.780</a></span> | <span class="t">saw before and this is our query vector. And we just calculate the distance between all</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=183" target="_blank">00:03:03.380</a></span> | <span class="t">of those. And then what we do is just take the top three. So the top K in reality but</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=190" target="_blank">00:03:10.380</a></span> | <span class="t">in this case it's top three. Now we also have IP so we have both L2 distance and IP distance</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=200" target="_blank">00:03:20.260</a></span> | <span class="t">as well. IP works in a different way. So we're using a different formula to actually calculate</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=208" target="_blank">00:03:28.660</a></span> | <span class="t">the distance or similarity there. So it's not exactly as you see it here. But before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=215" target="_blank">00:03:35.460</a></span> | <span class="t">we write any code, I just want to say that with flat indexes, they are 100% quality.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=222" target="_blank">00:03:42.460</a></span> | <span class="t">And typically what we want to do with FICE and similarly other search indexes is balance</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=229" target="_blank">00:03:49.800</a></span> | <span class="t">the search quality versus the search speed. Higher search quality, usually slower search</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=234" target="_blank">00:03:54.900</a></span> | <span class="t">speed. And flat indexes are just pure search quality because they are an exhaustive search.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=242" target="_blank">00:04:02.100</a></span> | <span class="t">They check the distance between your query vector and every other vector in the index.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=248" target="_blank">00:04:08.340</a></span> | <span class="t">Which is fine if you don't have a particularly big data set or you don't care about time.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=253" target="_blank">00:04:13.700</a></span> | <span class="t">But if you do, then you probably don't want to use that because it can take an incredibly</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=259" target="_blank">00:04:19.100</a></span> | <span class="t">long time. If you have a billion vectors in your data set and you do 100 queries a minute,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=266" target="_blank">00:04:26.340</a></span> | <span class="t">then as far as I know, it's impossible to run that. And if you were going to run that,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=272" target="_blank">00:04:32.500</a></span> | <span class="t">you'd need some pretty insane hardware. So we can't use flat indexes and exhaustive search</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=278" target="_blank">00:04:38.780</a></span> | <span class="t">in most cases. But I will show you how to do it. So first I'm just going to define dimensionality</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=288" target="_blank">00:04:48.820</a></span> | <span class="t">of our data, which is 128, which we can see up here, 1 to 8. I'm also going to say how</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=297" target="_blank">00:04:57.180</a></span> | <span class="t">many results do we want to return. I'm going to say 10. Okay. We also need to import FICE</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=304" target="_blank">00:05:04.580</a></span> | <span class="t">before we do anything. And then we can initialize our index. So I said we have two. So we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=310" target="_blank">00:05:10.860</a></span> | <span class="t">FICE index flat 02 or IP. I'm going to use IP because it's very slightly faster. It seems</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=320" target="_blank">00:05:20.980</a></span> | <span class="t">from me testing it, it's very slightly faster, but there's hardly any difference in reality.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=326" target="_blank">00:05:26.660</a></span> | <span class="t">So initializes our index and then we want to add our data to it. So we add WB and then</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=331" target="_blank">00:05:31.660</a></span> | <span class="t">we perform a search. So let me create a new cell and let me just run this quickly. Okay.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=351" target="_blank">00:05:51.180</a></span> | <span class="t">And what I'm going to do is just time it so you can see how long this takes as well. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=355" target="_blank">00:05:55.580</a></span> | <span class="t">I'm going to do time and we're going to do index. So DI equals index search. Then in</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=363" target="_blank">00:06:03.380</a></span> | <span class="t">here we have our query vector and how many samples we'd like to return. So I'm going</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=370" target="_blank">00:06:10.140</a></span> | <span class="t">to go with K. Okay. So that was reasonably quick and that's because we don't have a huge</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=380" target="_blank">00:06:20.700</a></span> | <span class="t">dataset and we're just searching for one query. So it's not really too much of a problem there.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=386" target="_blank">00:06:26.740</a></span> | <span class="t">But what I do want to show you is, so if we print out I, that returns all of the IDs or</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=392" target="_blank">00:06:32.900</a></span> | <span class="t">the indexes of the 10 most similar vectors. Now I'm going to use that as a baseline for</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=401" target="_blank">00:06:41.660</a></span> | <span class="t">each of our other indexes. So this is, like I said, a hundred percent quality and we can</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=407" target="_blank">00:06:47.400</a></span> | <span class="t">use this accuracy to test out other indexes as well. So what I'm going to do is take that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=415" target="_blank">00:06:55.460</a></span> | <span class="t">and convert it into a list. And if we just have a look at what we get, we'll see that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=419" target="_blank">00:06:59.380</a></span> | <span class="t">we get a list like that. And we're just going to use that, like I said, to see how our other</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=426" target="_blank">00:07:06.060</a></span> | <span class="t">indexes are performing. So we'll move on to the other indexes. And like I said before,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=430" target="_blank">00:07:10.460</a></span> | <span class="t">we want to try and go from this, which is the flat indexes, where it's just a hundred</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=434" target="_blank">00:07:14.580</a></span> | <span class="t">percent search quality to something that's more 50/50. But it depends on our use case</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=439" target="_blank">00:07:19.000</a></span> | <span class="t">as well. Sometimes we might want more speed, sometimes higher quality. So we will see a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=444" target="_blank">00:07:24.780</a></span> | <span class="t">few of those through these indexes. So we start with LSH. So a very high level. LSH</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=454" target="_blank">00:07:34.380</a></span> | <span class="t">works by grouping vectors in two different buckets. Now, what we can see on the screen</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=461" target="_blank">00:07:41.000</a></span> | <span class="t">now is a typical hashing function for like a Python dictionary. And what these hashing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=466" target="_blank">00:07:46.980</a></span> | <span class="t">functions do is they try to minimize collisions. So a collision is where we would have the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=472" target="_blank">00:07:52.860</a></span> | <span class="t">case of two items, maybe say these two, being hashed into the same bucket. And with a dictionary,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=481" target="_blank">00:08:01.460</a></span> | <span class="t">you don't want that because you want every bucket to be an independent value. Otherwise</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=486" target="_blank">00:08:06.020</a></span> | <span class="t">it increases the complexity of extracting your values from a single bucket if they've</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=492" target="_blank">00:08:12.700</a></span> | <span class="t">collided. Now, LSH is slightly different because we actually do want to group things. So we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=498" target="_blank">00:08:18.500</a></span> | <span class="t">can see it as a dictionary, but rather than, whereas before we were avoiding those collisions,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=504" target="_blank">00:08:24.460</a></span> | <span class="t">you can see here we're putting them into completely different buckets every time. Rather than</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=509" target="_blank">00:08:29.360</a></span> | <span class="t">doing that, we're trying to maximize collisions. So you can see here that we've pushed all</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=514" target="_blank">00:08:34.220</a></span> | <span class="t">three of these keys into this single bucket here. And we've also pushed all of these keys</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=521" target="_blank">00:08:41.180</a></span> | <span class="t">into this single bucket. So we get groupings of our values. Now, when it comes to performing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=527" target="_blank">00:08:47.120</a></span> | <span class="t">our search, we process our query through the same hashing function and that will push it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=534" target="_blank">00:08:54.300</a></span> | <span class="t">to one of our buckets. Now, in the case of maybe appearing in this bucket here, we use</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=540" target="_blank">00:09:00.820</a></span> | <span class="t">hamming distance to find the nearest bucket. And then we can search or we restrict our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=548" target="_blank">00:09:08.300</a></span> | <span class="t">scope to these values. So we just restricted our scope there, which means that we do not</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=556" target="_blank">00:09:16.860</a></span> | <span class="t">need to search through everything. So we are avoiding searching through those values down</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=562" target="_blank">00:09:22.820</a></span> | <span class="t">there. Now let's have a look at how we implement that. So it's pretty straightforward. All</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=567" target="_blank">00:09:27.980</a></span> | <span class="t">we do is index, we do vice index, LSH. We have our dimensionality. Then we also have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=574" target="_blank">00:09:34.620</a></span> | <span class="t">this other variable, which is called n bits. So I will put that in a variable up here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=582" target="_blank">00:09:42.020</a></span> | <span class="t">do n bits. And what I'm going to do is I'm going to make it D multiplied by four. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=587" target="_blank">00:09:47.580</a></span> | <span class="t">n bits, we will have to scale with the dimensionality of our data, which comes into another problem,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=593" target="_blank">00:09:53.460</a></span> | <span class="t">which I'll mention later on, which is the curse of dimensionality. But I'll talk more</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=598" target="_blank">00:09:58.660</a></span> | <span class="t">about it in a moment. So here we have n bits, and then we add our data like we did before.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=606" target="_blank">00:10:06.780</a></span> | <span class="t">And then we can search our data just like we did before. So we do time and we do, we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=613" target="_blank">00:10:13.060</a></span> | <span class="t">want d pi equals index search. And we are searching using our query, our search query,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=624" target="_blank">00:10:24.900</a></span> | <span class="t">and we want to return 10 items. Okay. So quicker speed, see here. And what we can also do is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=639" target="_blank">00:10:39.300</a></span> | <span class="t">compare the results to our 100% quality index or flat index. And we do that using NumPy</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=647" target="_blank">00:10:47.620</a></span> | <span class="t">in 1D, baseline i. Okay. So I'm just going to look at it visually here. So we can see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=657" target="_blank">00:10:57.860</a></span> | <span class="t">we have quite a lot of matches. So plenty of trues, a couple of falses, true, false,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=662" target="_blank">00:11:02.820</a></span> | <span class="t">false, false, false. So these are the top 10 that have been returned using our LSH algorithm.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=670" target="_blank">00:11:10.220</a></span> | <span class="t">And we're checking if they exist in the baseline results that we got from our flat index earlier.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=678" target="_blank">00:11:18.780</a></span> | <span class="t">And we're returning that most of them are present in that baseline. So most of them</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=682" target="_blank">00:11:22.940</a></span> | <span class="t">do match. So it's reasonably good recall there. So that's good. And it was faster. So we've</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=688" target="_blank">00:11:28.100</a></span> | <span class="t">got 17.6 milliseconds here. How much did we get up here? We got 157 milliseconds. So slightly</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=697" target="_blank">00:11:37.260</a></span> | <span class="t">less accurate, but what is that? 10 times faster. So it's pretty good. And we can mess</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=703" target="_blank">00:11:43.200</a></span> | <span class="t">around with n bits. We can increase it to increase the accuracy of our index, or we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=709" target="_blank">00:11:49.300</a></span> | <span class="t">decrease it to increase the speed. So again, it's just trying to find that balance between</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=713" target="_blank">00:11:53.820</a></span> | <span class="t">both. Okay. So this is a graph of just showing you the recall. So with different n bit values.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=721" target="_blank">00:12:01.500</a></span> | <span class="t">So as we saw before, we increase the n bits value for good recall, but at the same time,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=728" target="_blank">00:12:08.340</a></span> | <span class="t">we have that curse of dimensionality. So if we are multiplying our dimensionality value</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=734" target="_blank">00:12:14.540</a></span> | <span class="t">D by eight in order to get a good recall, then if we have a dimensionality of four,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=741" target="_blank">00:12:21.420</a></span> | <span class="t">that's not a very high number. So it's going to be reasonably fast. But if we increase</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=746" target="_blank">00:12:26.260</a></span> | <span class="t">that to dimensionality, for example, 512, that becomes very, very complex very quickly.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=757" target="_blank">00:12:37.060</a></span> | <span class="t">So you have to be careful with your dimensionality. Lower dimensionality is very good for LSH.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=761" target="_blank">00:12:41.740</a></span> | <span class="t">Otherwise it's not so good. You can see that here. So at the bottom here, I've used, this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=768" target="_blank">00:12:48.580</a></span> | <span class="t">is on the same dataset. So an n bits value of D multiplied by two, with LSH, it's super</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=777" target="_blank">00:12:57.180</a></span> | <span class="t">fast. It's faster than our flat index, which is what you would hope. But if we increase</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=784" target="_blank">00:13:04.560</a></span> | <span class="t">the n bits value quite a bit, so maybe you want very high performance, then it gets out</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=793" target="_blank">00:13:13.400</a></span> | <span class="t">of hand very quickly and our search time just grows massively. So you kind of have to find</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=800" target="_blank">00:13:20.320</a></span> | <span class="t">that balance. But what we got before was pretty good. We had a D multiplied by four, I think,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=806" target="_blank">00:13:26.100</a></span> | <span class="t">and we got reasonable performance and it was fast. So it's good. And that also applies</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=813" target="_blank">00:13:33.240</a></span> | <span class="t">to the index size as well. So low n bits size, index size isn't too bad. With higher n bits,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=820" target="_blank">00:13:40.440</a></span> | <span class="t">it's pretty huge. So also something to think about.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=828" target="_blank">00:13:48.080</a></span> | <span class="t">Now let's move on to HNSW. Now HNSW is, well the first part of it is NSW, which is Navigo</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=838" target="_blank">00:13:58.280</a></span> | <span class="t">Small World Graphs. Now what makes a graph small world, it's essentially means that this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=849" target="_blank">00:14:09.360</a></span> | <span class="t">graph can be very large, but the number of hops, so the number of steps you need to take</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=854" target="_blank">00:14:14.120</a></span> | <span class="t">between any two vertices, which is the points, is very low. So in this example here, we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=861" target="_blank">00:14:21.320</a></span> | <span class="t">this vertex over here. And to get over to this one on the opposite side, we need to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=868" target="_blank">00:14:28.200</a></span> | <span class="t">take one, two, three, four hops. And this is obviously a very small network, so it doesn't</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=882" target="_blank">00:14:42.880</a></span> | <span class="t">really count, but you can see this sort of behavior in very large networks. So I think</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=889" target="_blank">00:14:49.360</a></span> | <span class="t">in 2016, there was a study from Facebook. And at that point, I don't remember the exact</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=897" target="_blank">00:14:57.600</a></span> | <span class="t">number of people that they had on the platform, but I think it's in the billions. And they</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=905" target="_blank">00:15:05.040</a></span> | <span class="t">found that the average number of hops that you need to take between any two people on</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=910" target="_blank">00:15:10.200</a></span> | <span class="t">the platform is like 3.6. So that's a very good example of a Navigo Small World Graph.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=919" target="_blank">00:15:19.400</a></span> | <span class="t">Now hierarchical NSW graphs, which is what we are using, they're built in the same way</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=927" target="_blank">00:15:27.860</a></span> | <span class="t">like a NSW graph, but then they're split across multiple layers, which is what you can see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=932" target="_blank">00:15:32.880</a></span> | <span class="t">here. And when we are performing our search, the path it takes will hop between different</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=942" target="_blank">00:15:42.640</a></span> | <span class="t">layers in order to find our nearest neighbor. Now it's pretty complicated, and this is really,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=949" target="_blank">00:15:49.960</a></span> | <span class="t">I think, oversimplifying it a lot, but that's the general gist of it. I'm not going to go</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=956" target="_blank">00:15:56.000</a></span> | <span class="t">any further into it. We will, I think, in a future video and article. Now let's put</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=962" target="_blank">00:16:02.960</a></span> | <span class="t">that together in code. So we have a few different variables here. We have M, which I'm going</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=973" target="_blank">00:16:13.360</a></span> | <span class="t">to set to 16. And M is the number of connections that each vertex has. So of course, that means</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=984" target="_blank">00:16:24.160</a></span> | <span class="t">greater connectivity. We're probably going to find our nearest neighbors more accurately.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=989" target="_blank">00:16:29.920</a></span> | <span class="t">EF search, which is what is the depth of our search every time we perform a search. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=998" target="_blank">00:16:38.200</a></span> | <span class="t">we can set this to a higher value if we want to search more of the network, or a low value</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1004" target="_blank">00:16:44.880</a></span> | <span class="t">if we want to search less of the network. Obviously low value is going to be quicker.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1008" target="_blank">00:16:48.240</a></span> | <span class="t">High value is going to be more accurate. And then we have EF construction. Now this, similar</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1017" target="_blank">00:16:57.400</a></span> | <span class="t">to EF search, is how much of the network will we search, but not during the actual search,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1026" target="_blank">00:17:06.000</a></span> | <span class="t">during the construction of the network. So this is essentially how efficiently and accurately</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1033" target="_blank">00:17:13.480</a></span> | <span class="t">are we going to build the network in the first place. So this will increase the add time,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1041" target="_blank">00:17:21.680</a></span> | <span class="t">but the search time, it makes no difference on. So it's good to use a high number, I think,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1046" target="_blank">00:17:26.280</a></span> | <span class="t">for this one.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1052" target="_blank">00:17:32.920</a></span> | <span class="t">So we'll initialize our index. And we have this FICE index, HNSW, flat. So we can use</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1060" target="_blank">00:17:40.880</a></span> | <span class="t">different vector series. We can, I think, PQ, PQ there. And essentially, what that's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1069" target="_blank">00:17:49.320</a></span> | <span class="t">going to do is make this search faster, but slightly less accurate. Now this is already</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1076" target="_blank">00:17:56.640</a></span> | <span class="t">ready fast with flats, and that's all we're going to stick with. But again, like I said,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1080" target="_blank">00:18:00.880</a></span> | <span class="t">we will return to this at some point in the future and cover it in a lot more detail for</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1086" target="_blank">00:18:06.240</a></span> | <span class="t">sure. So dimensionality, we need to pass in our M value here as well.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1093" target="_blank">00:18:13.200</a></span> | <span class="t">Now we want to apply those two parameters. So we have EFSearch, which is obviously EFSearch.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1104" target="_blank">00:18:24.600</a></span> | <span class="t">And then we also have HNSWD, obviously the EF construction. So that should be everything</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1119" target="_blank">00:18:39.080</a></span> | <span class="t">ready to go. And all we want to do now is add our data. So index.addWB. Now like I said,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1129" target="_blank">00:18:49.080</a></span> | <span class="t">we have that EF construction. We've used a reasonably high value. So you can see this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1132" target="_blank">00:18:52.800</a></span> | <span class="t">is already taking a lot longer than the previous indexes to actually add our vectors into it.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1140" target="_blank">00:19:00.760</a></span> | <span class="t">But it's still not going to take that long.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1144" target="_blank">00:19:04.720</a></span> | <span class="t">And then once it is done, we are going to do our search, just like we did every other</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1151" target="_blank">00:19:11.000</a></span> | <span class="t">time. So we have DI equals search. Sorry, index.search. And we are going to pass in</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1163" target="_blank">00:19:23.120</a></span> | <span class="t">our query, and also K. So 43.6 seconds to add the vectors there, so a fair bit longer.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1172" target="_blank">00:19:32.520</a></span> | <span class="t">And then look at this, super fast, like that, 3.7 milliseconds. So much faster than the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1180" target="_blank">00:19:40.640</a></span> | <span class="t">last one. I think the last one was 16 milliseconds. This is a flat index, 157. LSH, we have 17.6.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1193" target="_blank">00:19:53.400</a></span> | <span class="t">So really quick, which is cool.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1197" target="_blank">00:19:57.040</a></span> | <span class="t">So how's the performance? So let's have a look. OK, so we get quite a few faulters here,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1208" target="_blank">00:20:08.800</a></span> | <span class="t">and only a couple of trues. So OK, it's not so great. It was really fast, but it's not</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1214" target="_blank">00:20:14.320</a></span> | <span class="t">very accurate. But fortunately, we can fix that. So let's increase our EF search. I'm</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1224" target="_blank">00:20:24.120</a></span> | <span class="t">going to increase it a fair bit. Let's go 32.32. And this is probably, I would imagine,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1233" target="_blank">00:20:33.600</a></span> | <span class="t">more than enough to get good performance. So run this, and run this. OK, and now we</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1243" target="_blank">00:20:43.000</a></span> | <span class="t">see we get pretty good results. Now, the wartime is higher. So it's just a case of balancing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1248" target="_blank">00:20:48.400</a></span> | <span class="t">it, because this is now higher than LSH. But what we can do is increase EF construction</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1255" target="_blank">00:20:55.040</a></span> | <span class="t">time. The value for EF construction increases or decreases, depending on what everyone says.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1260" target="_blank">00:21:00.880</a></span> | <span class="t">A lot of flexibility with this, and it can be really fast. HNSW is essentially one of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1267" target="_blank">00:21:07.060</a></span> | <span class="t">the best performing indexes that you can use. If you look at the current state of the art,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1272" target="_blank">00:21:12.260</a></span> | <span class="t">a lot of them are HNSW, or they're based on HNSW in some way or another.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1277" target="_blank">00:21:17.720</a></span> | <span class="t">So these are good ones to go with. You just need to play around them a little bit. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1284" target="_blank">00:21:24.120</a></span> | <span class="t">this is a few of the performance I found using the same data set. But I'm messing around,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1291" target="_blank">00:21:31.560</a></span> | <span class="t">so we have the EF construction values down here. So we start with 16 over here, up to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1298" target="_blank">00:21:38.440</a></span> | <span class="t">64. EF search values over here, and our M values over here. And we've got pretty good</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1308" target="_blank">00:21:48.120</a></span> | <span class="t">recall over 64 on the EF construction. So EF construction is a really good one to just</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1313" target="_blank">00:21:53.960</a></span> | <span class="t">increase, because it doesn't increase your search time, which is pretty cool, I think.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1320" target="_blank">00:22:00.700</a></span> | <span class="t">And then here is the search time. Again, HNSW, M, and EF search. Obviously, I didn't include</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1327" target="_blank">00:22:07.720</a></span> | <span class="t">EF construction there, because it doesn't make a difference. And this is the one thing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1332" target="_blank">00:22:12.880</a></span> | <span class="t">with HNSW. The index size is absolutely huge. So that's just one thing to bear in mind.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1342" target="_blank">00:22:22.020</a></span> | <span class="t">The index size can take a lot of memory. But otherwise, really, really cool index.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1349" target="_blank">00:22:29.280</a></span> | <span class="t">And then that leaves us on to our final index, which is the IVF index. And this is super</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1356" target="_blank">00:22:36.400</a></span> | <span class="t">popular, and with good reasons. It is very good. So the inverted file index is based</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1365" target="_blank">00:22:45.800</a></span> | <span class="t">on essentially clustering data points. So we see here, we have all of these different</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1371" target="_blank">00:22:51.800</a></span> | <span class="t">data points, the little crosses. And then we have these three other points, which are</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1377" target="_blank">00:22:57.400</a></span> | <span class="t">going to be our cluster centroids. So around each, or based in each of our cluster centroids,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1385" target="_blank">00:23:05.200</a></span> | <span class="t">we expand the catchment radius around each of those. And as you can see here, where each</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1392" target="_blank">00:23:12.280</a></span> | <span class="t">of those circles collides, it creates the edge of what are going to be our almost like</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1397" target="_blank">00:23:17.520</a></span> | <span class="t">catchment cells. And this is called a Voronoi diagram, or it's a really hard word, Dirichlet</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1404" target="_blank">00:23:24.960</a></span> | <span class="t">tessellation. I don't know if that's correct, but I think it sounds pretty cool. So I thought</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1410" target="_blank">00:23:30.680</a></span> | <span class="t">I'd throw that in there. So we create these cells. In each one of those cells, any data</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1417" target="_blank">00:23:37.640</a></span> | <span class="t">point within those cells will be allocated to that given centroid. And then when you</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1424" target="_blank">00:23:44.000</a></span> | <span class="t">search within a specific cell, you pass your XQ value in there. And that will be compared,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1432" target="_blank">00:23:52.120</a></span> | <span class="t">the XQ value will be compared to every single cluster centroid, but not the other values</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1437" target="_blank">00:23:57.640</a></span> | <span class="t">within that cluster or the other clusters, only the cluster centroids. And then from</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1443" target="_blank">00:24:03.240</a></span> | <span class="t">that, you find out which centroid is the closest to your query vector. And then what we do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1450" target="_blank">00:24:10.000</a></span> | <span class="t">is we restrict our search scope to only the data points within that cluster or that cell.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1459" target="_blank">00:24:19.400</a></span> | <span class="t">And then we calculate the nearest vector. So at this point, we have all the vectors</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1465" target="_blank">00:24:25.400</a></span> | <span class="t">only within that cell, and we compare all of those to our query vector. Now, there is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1470" target="_blank">00:24:30.280</a></span> | <span class="t">one problem with this, which is called the edge problem. Now, we're just showing this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1474" target="_blank">00:24:34.440</a></span> | <span class="t">in two-dimensional space. Obviously, in reality, for example, the dataset we're using, we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1480" target="_blank">00:24:40.280</a></span> | <span class="t">128 dimensions. So dimensionality, the edge problem's kind of complicated when you think</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1485" target="_blank">00:24:45.960</a></span> | <span class="t">about it in the hundreds of dimensions. But what this is, is say with our query, we find</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1494" target="_blank">00:24:54.320</a></span> | <span class="t">our query vector is right on the edge of one of the cells. And if we set our nprobe value,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1500" target="_blank">00:25:00.920</a></span> | <span class="t">so I mentioned nprobe here, that's how many cells we search. If that is set to one, it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1506" target="_blank">00:25:06.920</a></span> | <span class="t">means that we're going to restrict our search to only that cell, even though if you look</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1512" target="_blank">00:25:12.000</a></span> | <span class="t">at this, we have two, or we have, I'm trying to think. So this one for sure is closer to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1519" target="_blank">00:25:19.640</a></span> | <span class="t">our query vector than any of the magenta data points, and possibly also this one and this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1526" target="_blank">00:25:26.560</a></span> | <span class="t">one, and maybe even this one. But we're not going to consider any of those because we're</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1532" target="_blank">00:25:32.960</a></span> | <span class="t">restricting our search only to this cell. So we're only going to look at these data</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1541" target="_blank">00:25:41.840</a></span> | <span class="t">points and also these over here. So that's the edge problem, but we can get around that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1550" target="_blank">00:25:50.960</a></span> | <span class="t">by not just searching one cell, but by searching quite a few. So in this case, our nprobe value</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1558" target="_blank">00:25:58.640</a></span> | <span class="t">is eight, and that means we're going to search eight of the nearest centroids or centroid</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1564" target="_blank">00:26:04.000</a></span> | <span class="t">cells. And that's how IVF will work. Let's go ahead and implement that in code. So first</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1573" target="_blank">00:26:13.160</a></span> | <span class="t">thing we need to do is set our nlist value, which is the number of centroids that we will</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1578" target="_blank">00:26:18.100</a></span> | <span class="t">have within our data. And then this time, so this is a little bit different, we need</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1585" target="_blank">00:26:25.440</a></span> | <span class="t">to set the final vector search that we're going to do. So this is split into two different</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1592" target="_blank">00:26:32.520</a></span> | <span class="t">operations. So we're searching based on clusters, and then we're actually comparing the full</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1599" target="_blank">00:26:39.160</a></span> | <span class="t">vectors within the selected clusters. So we need to define how we're going to do that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1603" target="_blank">00:26:43.800</a></span> | <span class="t">final search between our full vectors and our query vector. So what we do is write FICE.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1612" target="_blank">00:26:52.320</a></span> | <span class="t">So we do index flat. We're going to index flat IP. You can use L2 as well. We set our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1617" target="_blank">00:26:57.560</a></span> | <span class="t">dimensionality. So we're just initializing a flat index there. And then what we're going</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1622" target="_blank">00:27:02.080</a></span> | <span class="t">to do is feed that into our IVF index. So our IVF index is FICE, index IVF, and flat,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1631" target="_blank">00:27:11.280</a></span> | <span class="t">because we're using the flat indexes, the flat vectors there. We need to pass our quantizer.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1637" target="_blank">00:27:17.520</a></span> | <span class="t">So this step here, the other step to the search process, the dimensionality, and also our</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1645" target="_blank">00:27:25.840</a></span> | <span class="t">nlist value. So how many cells or clusters we're going to have in there. And with this,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1652" target="_blank">00:27:32.040</a></span> | <span class="t">because we're clustering data, we need to do something else. So let me show you. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1658" target="_blank">00:27:38.120</a></span> | <span class="t">if we write index.is_trained, we get this false. If we wrote off any of our other indexes,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1665" target="_blank">00:27:45.000</a></span> | <span class="t">this would have been true, because they don't need to be trained, because we're not doing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1668" target="_blank">00:27:48.280</a></span> | <span class="t">clustering or any other form of training or optimization there. So what we need to do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1674" target="_blank">00:27:54.280</a></span> | <span class="t">is we need to train our index before we use it. So we write index_train, and we just pass</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1680" target="_blank">00:28:00.200</a></span> | <span class="t">all of our vectors into that. It's very quick, so it's not really an issue. And then we do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1688" target="_blank">00:28:08.880</a></span> | <span class="t">index add, pass our data. And then what we do, one thing I want to show you, we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1699" target="_blank">00:28:19.280</a></span> | <span class="t">our nprobe value. We'll search with one for now. So we'll search one cell. And to search,</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1708" target="_blank">00:28:28.080</a></span> | <span class="t">we write di, as we have every other time, search, xq, k. So it's super fast, 3.32 milliseconds.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1720" target="_blank">00:28:40.020</a></span> | <span class="t">I think that's maybe the fastest, other than our bad-performing or low-quality HNSUbU index.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1731" target="_blank">00:28:51.300</a></span> | <span class="t">So let's see how that's performed. So we write np.in_on_d, baseline. Hi. You see, it's not</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1745" target="_blank">00:29:05.220</a></span> | <span class="t">too bad, to be fair, like 50/50 almost. So that's actually pretty good. But what we can</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1752" target="_blank">00:29:12.820</a></span> | <span class="t">do if we want it to be even better is we increase the nprobe value. So let's go up to four.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1759" target="_blank">00:29:19.900</a></span> | <span class="t">So that's increased the wartime quite a bit. So from like 3 to 125, which is now super</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1765" target="_blank">00:29:25.580</a></span> | <span class="t">slow, actually. But now we're getting perfect results. We can maybe decrease that to two.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1772" target="_blank">00:29:32.180</a></span> | <span class="t">So now it's faster. That could have been a one-off sometimes. Occasionally, you get a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1775" target="_blank">00:29:35.980</a></span> | <span class="t">really slow search. It just happens sometimes. So we set nprobe to two, super fast and super</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1786" target="_blank">00:29:46.460</a></span> | <span class="t">accurate. So that's a very good index as well. So these are the stats I got in terms of recall</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1795" target="_blank">00:29:55.460</a></span> | <span class="t">and search time in milliseconds for different nprobe values and different endless values.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1800" target="_blank">00:30:00.880</a></span> | <span class="t">So again, it's just about balancing it again. Index size, the only thing that affects your</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1808" target="_blank">00:30:08.140</a></span> | <span class="t">index size here is obviously the size of your data and the endless value. But you can increase</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1812" target="_blank">00:30:12.540</a></span> | <span class="t">the endless value loads and the index size hardly increases. So this is like increasing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1817" target="_blank">00:30:17.940</a></span> | <span class="t">by 100 kilobytes per double of the endless value. So it's like nothing.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1827" target="_blank">00:30:27.140</a></span> | <span class="t">So that's it for this video. And we covered quite a lot. So I'm going to leave it there.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1834" target="_blank">00:30:34.980</a></span> | <span class="t">But I think all these indexes are super useful and quite interesting. And figuring out, just</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1841" target="_blank">00:30:41.460</a></span> | <span class="t">playing around with them. Like you've seen, I've done loads with these graphs, just seeing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1847" target="_blank">00:30:47.540</a></span> | <span class="t">what is faster, what is slower, where the good quality is. And just playing around the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1852" target="_blank">00:30:52.260</a></span> | <span class="t">parameters and seeing what you can get out of it is super useful for actually understanding</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1858" target="_blank">00:30:58.460</a></span> | <span class="t">these.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1860" target="_blank">00:31:00.060</a></span> | <span class="t">Now what I do want to do going forward is actually explore each one of these indexes</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1865" target="_blank">00:31:05.980</a></span> | <span class="t">in more depth. Because we've only covered them at a very, very high level at the moment.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1872" target="_blank">00:31:12.940</a></span> | <span class="t">So in future videos, articles, we're going to go into more depth and explore them a lot</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1880" target="_blank">00:31:20.460</a></span> | <span class="t">more. So that will be pretty interesting, I think.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1884" target="_blank">00:31:24.020</a></span> | <span class="t">So that's it for this video. Thank you very much for watching. And I'll see you in the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1890" target="_blank">00:31:30.380</a></span> | <span class="t">next one. Bye.</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=B7wmo_NImgM&t=1891" target="_blank">00:31:31.260</a></span> | <span class="t">[BLANK_AUDIO]</span></div></div></body></html>