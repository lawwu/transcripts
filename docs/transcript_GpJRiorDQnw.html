<html><head><title>Evo 2: Systems and Algorithms for Convolutional Multi-Hybrid Language Models at Scale</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Evo 2: Systems and Algorithms for Convolutional Multi-Hybrid Language Models at Scale</h2><a href="https://www.youtube.com/watch?v=GpJRiorDQnw" target="_blank"><img src="https://i.ytimg.com/vi/GpJRiorDQnw/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>Hey. All right. We got it. Okay. All right. So, great. I stayed up late last night putting these slides together. Didn't have a ton of time to prepare, so hopefully they're clear. If you have questions or want to dig in, go ahead. I have about -- I think I have about 45 minutes worth of slides, probably.</p><p>But there's a lot of -- like, there's probably four hours worth of information in these papers that I could cover. So, if we do want to dig into any of the -- especially the bio side of things, I can describe a lot of what's going on in more detail.</p><p>But I focus mostly on the machine learning stuff. But I'm going to give a little bit of a, you know, genetics -- two-slide introduction to genetics just for people who don't have -- don't have experience with it. Okay. Great. So, whoops. Why is it not? Okay. So, this is sort of the why.</p><p>So, the Evo is a foundation model. It's like in a series of -- there was like hyena DNA and then there was Evo and then Evo 2. it's a 7b and 40b model. And the purpose of a model like this -- so, it's nucleotide-based, meaning it's actually modeling the DNA sequences.</p><p>And the purpose -- these are some of the applications on this slide for that. So, like, there's a lot of prediction things where you can -- like, for just like -- I'll go through these. Maybe not all of them, but I'll go through a lot of them. So, like -- so, like, if I -- if I knock out genes, is it important?</p><p>Does it impact -- you know, does it impact, like, the health of the person or some -- the function of something? Or does it not matter? Or, like, a portion of the gene? What -- this one is actually really, really important and hard to do. So, they seem to have made progress.</p><p>I don't know enough about the biology to know how realistic what they're saying -- they're claiming is and how well they've tested it. But, you know, being able to predict the effect of your genetic variations on, like, drug treatments, your health, other things like that, is sort of the precision medicine promise.</p><p>And it's quite difficult. And -- but this kind of model seems to be helpful for that. Like, designing genome scale things, I didn't -- I don't really understand that use case super well. in terms of, in terms of practical things, maybe for a study. But, like, looking at -- predicting, like, sort of -- protein mutations based on gene changes.</p><p>You know, sort of things in the protein. Like, what feature -- like, identifying structures in the feature -- uh, structures in protein folds. You know, sort of designing proteins. Predicting, you know, sort of, like, in the RNA, like, being able to -- find mutations. You know, sort of, predict whether a RNA strand will be stable or not.</p><p>Sort of, like -- sort of, like -- and then, um, things in the epigenome. Epigenome is, like, how -- is other physical mechanisms that cause genes to be more or less expressed. And so -- and chromatin is, like, a major -- one of the most important things with that.</p><p>And so, um, like, sort of, making predictions about that. So, like, all of these things, they have these really -- either really important scientific or sort of -- scientific consequences, like being able to understand or monitor or measure things better. or they actually have impact on your ability to, um, sort of, sort of, make clinical decisions with.</p><p>So, I think -- so, there's, like -- doing this well is exciting. And it does seem like -- like, um, this does seem like a bit of a step change to me, um, with not knowing a whole lot. There's been a lot of attempts at models like this, and they do work.</p><p>But this seems to -- you know, because it's well-funded and done, um, by a large team and, um, you know, sort of, like, has support from NVIDIA and other things, it seems to be, like, a pretty -- pretty impressive effort. Um, so, uh, this is -- so, uh, the interesting thing about EVO is that this is not just for a human genome.</p><p>This is for -- so, they -- they incorporated, uh, genomes. So, each point on this UMAP is a separate genome. Um, and -- or, uh, part of -- at least part of a separate genome. And -- Um, and, um, so, you can see there's, like, a ton of different, uh, ton of different genomes here.</p><p>And I think this core data, that's where humans would be, um, somewhere in there. So, uh, um, so you can see -- and that's, I guess, this one, probably. So, um, this area. So, like, uh, you can see that it's -- you know, that there's a lot of other stuff that got included.</p><p>And that the purpose of that is to be able to, uh, transfer your understanding of the behavior of genetics from these other species into humans and also to study those other species. Okay. Okay. Is that clear before I dive into this? Please interrupt if you guys have questions. Um, okay.</p><p>So, uh, this is -- I say, probably wrong, because this is -- -- this is just my pretty lay understanding based on, like, you know, you know, college biology and, uh, and, you know, conversations with, you know, um, computational biologists and things like that. So, um, but I think that for AI, you know, I think that for AI engineers, we don't need to understand it too well.</p><p>There's, like, sort of -- so I'm going to give a conceptual view and then maybe one level deeper. Um, that -- so, um, there's -- genetics kind of deals with, um, these three factors. And then there's lots of other stuff that is related, but DNA, RNA, and then proteins.</p><p>So -- and then proteins turn into into larger structures and -- and signaling and all sorts of stuff. But, um, you know, sort of, like, at its core, at least from my understanding, um, uh, you know, you sort of have DNA, and this is, like, the long-term storage. And so -- and I like to think about this as the software, right?</p><p>Like, this is the -- this is the -- this is the program that your cells follow in order to create proteins, proteins, which are sort of like hardware and sort of like software. So, like, either -- and you could call it software or RTL. So, like, you're, you know, describing how to synthesize a piece of hardware, maybe.</p><p>Um, and then RNA is like -- and then RNA is like -- is a less stable, um, kind of very similar to DNA, but less stable, more reactive, and it gets duplicated from RNA. And I think that the important thing about it -- one -- or one of the important things about it is it -- it actually gets, uh, repeatedly copied, right?</p><p>So -- and so that the -- in the level of -- the -- the amount of expression of that -- that -- that, um, the genes in RNA impact the behavior of the cell. So, that could be because it affects the behavior -- or the -- the expression of other genes.</p><p>It could be because it signals to other places in the cell or outside the cell. um, and it also -- um, the RNA is sort of the mechanism by which proteins are created, um, in the -- in the cell. And I -- I think that, um, when I previously understood -- until, like, the sort of modern era, when I -- like, you know, when you learn this way back when I was learning it in college or whatever, um, I learned -- you know, I just had this concept of, like, these abstract things and their proteins and, you know, they're just, like, these strands and they kind of fold.</p><p>And, like, I didn't really get what they -- like, how -- how that, like, sort of fits into -- like, creates all these, like, structures, right? And, like, these are enormously complex cells. So, I -- I -- I think -- I want to just click on this -- this -- um, this video really quick.</p><p>So, this is -- this is what's called an enzyme. An enzyme -- excuse me -- is a -- is a molecular machine. It's created by -- from many proteins, right? And this particular one is called ATP synthase. It's what turns -- it, like, sort of re-freshes -- I think it's ATD, I think -- um, and it turns it into ATP by adding -- um, by, like, sort of mechanically -- um, by mechanically putting two pieces of -- of -- of protein together.</p><p>And that that -- putting the proteins together sort of, like, causes -- you know, it gives the energy that can be released later, like a spring or something. And -- and so they -- like, there's -- so this video -- sorry. So -- Can you guys hear that or no?</p><p>I don't know if I can hear. You can -- You cannot. You cannot. Oh, yeah, that's okay. So, like, I -- the important thing here is that -- like, so these are ATPs that are going into here, right? And then -- So, like, this is all just a bunch of proteins together, right?</p><p>And you can see the -- there's this -- there's this -- there's this sort of -- thing that's turning in here. And there's actually literally an electric motor. So, you can see it down at the bottom here. So, the -- there's, like -- there's a membrane, and then there's, like, a bunch of proteins -- or, sorry, a bunch of hydrogen ions down at the bottom -- or -- So, protons or hydrogen ions.</p><p>And they're those, like, sort of, you know, like, sort of super energized things at the bottom. And that causes this to turn. And that causes you -- it to re -- like, refresh the ATP. Right? So, like, this is -- this is what -- this is, like, one example, one of the more impressive ones, but still, like, just one example of the crazy stuff that gets constructed by -- -- by basically folding by -- by, like, sort of putting together these proteins into these molecular machines, enzymes, plus signaling, plus other structures.</p><p>So, I -- I just -- I -- I -- I -- I wanted to just go over that just to be clear. that there's, like, there's, like, this -- this is, like, what's being constructed. It's not just, like, some soup of -- of protein that somehow magically turns into -- into, like, a cell, and then cells into people.</p><p>-- Okay. Sorry. So, that's -- that's, like, my -- okay. That's, like, sort of the conceptual view. And then, there's -- so, then, there's, like, a logical view that I have that is, like, basically -- so, for DNA, there's basically four nucleotides. -- and this is kind of an approximation, actually, but it's more or less -- there's four nucleotides.</p><p>So, and they have names, but you just remember A, T, C, G. And they -- they kind of -- they -- they fit together. Like, I think A and T and C and G fit together. So, they're called base pairs. But you -- they can also fit to -- they can, like, bind to each other next to each other.</p><p>So, you can just have these -- from a conceptual standpoint, you just have a long sentence of -- with four -- four letters in them. -- right? For -- so, there's four tokens, A, T, C, and G. And then, you just have a sequence of those. And that's what code -- so, those, sort of, are in your long-term storage.</p><p>And then, DNA gets transcribed into RNA, which is basically the same, but you -- the T is a U in RNA in it. So, that has different chemical properties. It's less stable, meaning -- and -- and so, that allows it to be more -- and it doesn't turn into a double helix.</p><p>So, that it -- it allows it to be more easily, like, chopped up and -- and shuttled around. And, like, it's just more convenient for transcribing. So, that what happens is DNA gets copied into RNA. You get these, like, sequences. And then, you know, shorthanding quite a bit, the RNA turns into -- there's, like, sequences of three RNAs.</p><p>And those are called codons. And the codons attach to amino acids. And so, that these codons, sort of, like, these patterns of codons, then turn into amino acids, like -- or bind to amino acids and stick them together into these long, what's called a polymer chain. And that -- that polymer chain is a protein.</p><p>And then, the proteins fold because of their chemical properties. And they turn into those amazing molecular machines. Okay. So, like, that's very, very, like, high-level summary. So, but I think the important thing for an AI engineer to know about this is that there's kind of two main things that I've been calling out here.</p><p>One is that the genes are, like, really long, right? Like, you have these long, long, long, long sequences, you know, in the 1,000 to 1 million token range. Right? And then, the vocab is obviously very small. So, your vocabulary is for tokens. And then, they actually added some other special tokens because they're just using a single byte encoding.</p><p>So, what do you do with the rest of the possible tokens? And so, they have them, like, one token per species, basically. Okay. Is that -- so, that's my introduction to genetics. Is -- I hope that's enough for you guys to understand the rest of the discussion. Do you guys want to ask any questions?</p><p>I just want to say, I love the effort put into translating things for AI engineers. I think it's very -- this slide, quite important. And, yeah. I like it. Okay. Excellent. Thank you. Okay. All right. So, okay. So, let's -- now we're going to, you know, here's like a, you know, like a, like a gear shift with no clutch here.</p><p>So, I'm going to switch to the sort of -- okay, this is the main sort of mechanism by which this model is able to have long, like, efficient inference on very long context. So, like, with that -- so, I'll build up to why that -- this mechanism works. But, basically, starting in this -- this has been research that has been developed at Stanford over the past several years.</p><p>So, this -- this part of it is a little old. But -- and this refers to a previous paper that isn't in the list that we read today. So, basically, they developed this -- what they call a hyena operator. I don't know the origin of the name. But, basically, as a surrogate -- originally, as a surrogate for attention, right?</p><p>So, how can we -- and the sort of research question, I think, was basically, how can we replace attention with something that is -- is based on convolutions, which is kind of similar -- like, you've probably heard of state-space models. So, this is an example of a type of state-space model.</p><p>And so, because -- the reason why you would want to do that is because you can -- convolutions are more efficient to calculate than a full attention -- self-attention matrix, right? So -- so that they can be -- and it's not obvious why from this diagram. I'll show you why.</p><p>But that -- that's sort of the why of it, is they're more efficient to calculate. And so -- and the -- you know, just to be clear, what's going on here is that you have these sort of like -- you know, so you have like -- this is a convolution.</p><p>And this is called a toplitz matrix, which is just a -- you know, sort of like an unrolling of the convolution into -- into a matrix. And then, you have weightings on those convolutions. And so, you have these pairs of like a weight plus the convolution plus a weight plus a convolution and some like arbitrary number of those stuck together.</p><p>And then, you can get this thing that kind of sort of approximates the behavior of attention. So, this H U is basically a replacement or a surrogate for attention. But -- and -- and -- and it's important to note that there's two ways to represent -- and like there's probably more, but like there's two -- at least two ways to represent this convolution.</p><p>One is as this toplitz matrix. But the other is this -- quote unquote -- they call it implicit -- parameterization, which means is -- think IIAR filter, if you're familiar with those, or recurrent model, if you're familiar with those, where you're taking the previous state and you're just calculating an update.</p><p>rather than having all of the updates sort of written out for you. Good so far? Okay. So -- and then, here's the why again. Convolution is faster than attention. it's faster than attention. But, you know, note -- and they actually talk about this in the paper. And that's true in the limit.</p><p>It's not true at short sequence lengths. Right? So, if you look at hyena here, it's actually slower than flash attention up until you get to this like 3 -- 10 to the 3.8, which I don't know what -- that's probably what -- like about, you know, maybe 5,000 or something -- context length.</p><p>And also notice the -- the performance, although, you know, they claim is, you know, sort of like a surrogate for attention. It doesn't actually do as well as -- as -- as GTP -- GTP, NEO, which is a regular attention-based model, or our WKV. Hopefully, Eugene's on the call.</p><p>So, Eugene, you're waiting to -- I'm waiting to help answer questions for this part if needed. Yeah, yeah. Please. I -- I don't have any questions yet. But if other people do -- and -- and especially, like, sort of details on space models, I know -- you know a lot about them in comparison to RWKV.</p><p>Okay, so -- so -- so then, this is a slide on striped hyena. So -- and also striped hyena -- and striped hyena, too. This is what they use for EVO2. So, they actually -- so here, in this Toplitz matrix here, you see that, like, the question is sort of like, oh, well, I have this full attention block, and then I have, like, my fully realized Toplitz matrix.</p><p>So, like, how am I actually saving in memory or whatever, right, or computation? And so, like, part of the answer is, well, you know, you can -- you can perform -- perform this convolution in the frequency domain, and it's faster. So that is a good answer. But also, part of it is, well, actually, it's both, like, more efficient and -- and more -- both more efficient and better results.</p><p>If you actually use different -- different convolutional -- or these hyena operators -- so this, like, sort of -- this, like, sort of -- pair of, like, this guy plus this guy, you know, and then you have, like, a chain of those. So you can do that in different ways.</p><p>And so they have three different ways that they propose to do this. one is this short explicit, and you can -- disappointingly, they didn't have a good Toplitz matrix diagram of this. But you can see, like, this is basically a line here. So it's -- it's, like, sort of -- you can think of it as -- as, like -- being somewhat related to local attention, right, where you have just a few tokens of context close by that you're looking at, and everything else is zero.</p><p>And then you have this medium regularized, which is, like, more context in the -- in the range of a couple hundred tokens of context, and everything else is zero. And then you have this long implicit, which -- which means I'm going to use this implicit representation. So maybe I'll have to do recurrence in, you know, in -- in the -- in this block, or maybe I will, like, sort of hybridize that with, you know, sort of some implicit and some explicit representation.</p><p>But in any event, you have this -- it has a more efficient way of calculating using FFTs. So this -- even if it's, you know, like, sort of fully realized, it still is more efficient than attention to calculate. So -- and then, you know, so the idea is that you have this stack.</p><p>So instead of having attention block, attention block, attention block, you know, you have this S-E-M-R-L-I, and then an attention block, and then S-E-R-L-R-M-R-L-I. And then, like, so you kind of stack these up so that you end up with, you know, sort of your different layers calculating sort of their attention surrogates in different ways.</p><p>And it turns out -- well, first of all, just to be a little more clear, this -- so this is like a FIR filter, you know, four to seven tokens in depth. This is like a FIR filter, and they, quote, unquote, regularize this. I actually -- so Eugene, this is actually one place where I had a question.</p><p>They say that this alpha is swept across channels. I don't actually quite understand what that means. Do you have a -- did you -- I don't know if you read the paper or not, but, like, did you understand what this is? So I think the way to view these segments, right, and this makes sense once you view -- understand how, like, future states-based models work, right, is a way to visualize it as you process the tokens.</p><p>So let's just say -- and you can view this as a genetic sequence, left to right. I hope people can see my hands right now. Like, left to right, the whole sequence. Same thing with types as well. The way -- the way these tokens are being merged is the -- at the start, like, these tokens gets processed and gets merged together.</p><p>So as a state-space model built the state by merging everything together over the layers. Does that make sense? Over time and over the layers. So -- and -- and so -- so what this means here, right, in this case, right, they had these few -- first few layers that process the tokens that come in.</p><p>So we're talking about 47 tokens, and then it gets regularized and then merged into other chunks of tokens. There's, let's say, 47. I can't remember what's the exact size for future states-based models and the models at that time. And then it just keeps merging, cascadingly. And therefore, like -- therefore, like, the layers that deal with the longer implicit attention, they get -- they view the summarized information from the previous layers that then gets merged in.</p><p>So, hence, why -- why -- why they show that separation? Because at -- at this point, they were still testing and trying to figure out how to best manage long contact sync. And -- and -- for -- for genetic modeling. And -- and -- and part of the evaluation was that if they just use -- if they just keep one state, and then they keep merging in, it performed worse in the case of state space.</p><p>And to have, like -- have it, like, pre -- pre-processed with the short explicit, and then subsequently merge into medium, and then merge into large. Yeah. Yeah. Yeah. Yeah. So, I guess -- yeah, yeah. Yeah, exactly. Like, the pre-processing. But I -- so, that's a really good way to think about it.</p><p>Yeah. Yeah. What I was actually asking about was this alpha parameter is -- it -- it says in the paper that it's swept across the channels, and they don't really go into what that means. And that means that I -- I think I understand what channels are, is just basically the different dimensions in your hidden dimension.</p><p>Is that right? So -- but then, like, I wouldn't understand -- I don't really understand why sweeping this would be a good idea. Or, like, what -- or if I'm completely misunderstanding what they're saying. I -- I think it's just view it as -- it's applying that decay as the information flows in, to force the model to, like, just summarize it even further.</p><p>Because -- because even -- even in RRKV, we have that decay mechanism, where -- where, by default, every piece of information will be tried to be forgotten, unless the model has decided that this is important to remember. Okay. Yeah. So -- so -- so -- so that decay, right, kicks in to help force the model to forget things by default.</p><p>Right, yeah. Unless -- as part of the metric multiplication calculations, it decides that, hey, I should amplify this signal instead. And -- and if -- and I think genetic modeling is a very good example of, like, understanding why recurrent models are highly favorable to, like, even this use case, or even -- or even sometimes can be used for tags.</p><p>It's because at the end of the day, right, like, if you look at the genetic code, right, it's one of the cases where it's highly repetitive, the data. Yeah. but there is, like, slight changes that we need to capture meaning. Yeah. And if you view it from a compression point, we were talking, like, zip compression and things like -- it's highly compressible.</p><p>Yeah. Yeah. And so -- so what you actually -- what you want the model to actually learn is the pattern and the anomalies, the peaks. Yeah. So -- and to discard the repetitions. I know I'm -- this is not the accurate way to say it, but in this use case, right, so by default, if we discard everything towards decay, the peaks -- like, hey, this is weird.</p><p>Why is genome 364, for example, is ABBBA, not as what the repetition should be? Yeah. Then the matrix multiplication will pick that value, and then it will try to, like, conserve it into memory. So -- Right. So that's why -- it may sound vague, but it's more of, like, the decays there by default and how it works from there.</p><p>Okay. Yeah. Okay. Thank you. Okay. So -- let's see. Okay. So -- so basically -- and this is just, like, sort of -- this is kind of an ablation. They -- they -- they studied, okay, the multi-head attention with their -- you know, sort of, like, if they -- you just make these all multi-head attention, you -- you train for 400 billion tokens, and then you get a perplexity of 3.09, right?</p><p>Right. And then they looked at this LI LI LI LI, which is this one. This was the original design of striped hyena. And you get this .2.87, so a bit better. And then, interestingly, if you just replace these two first LIs with these SEs, you get the same basic perplexity, so these LI -- so it doesn't hurt to have this more efficient, very short convolution instead.</p><p>And then they found that, like, you do even slightly better if you stick an MR in it. So -- so -- so -- and -- and, you know, like, for what it's worth at -- at this -- you know, in this model at -- with this data, like, at this point in the training process, beating multi-head attention.</p><p>And then -- and then I actually -- here's another place I don't understand what this ABF positional embedding is. I stuck it in here more as a hope that someone else would explain this slide. I -- if not, I don't think it -- they didn't seem to think it was super important, but that, like, basically, this -- it's a more scalable, you know, this ABF is more scalable, and they get up to a million tokens.</p><p>It seems -- one -- one thing I was a little unclear about is why is the perplexity going down as the context length goes up, you guys? Is it just data distribution difference, or -- I'm not sure. Did anyone pick up on that? For genetic sequencing, that is -- should be expected.</p><p>Mostly because, like, say, majority of the data is going to be repetitive. So once you've seen the pattern, you should be able to at least answer the pattern. Yeah. Okay. I see. Yeah, that makes sense. Okay. All right. So training -- so training here is -- is, you know, sort of, like, on both 7B and -- and 40B.</p><p>Notice this is log scale significantly faster than dense transformer. You know, like, you can see it here, but I think maybe easier to understand is that, you know, like, one would be the same amount of time as Stripe Tyena 2. So they beat, you know -- sorry, Tyena 1 plus they beat -- oops, sorry -- they beat the dense transformers by a factor of three or more here, and a little more than three and a little less than three here at the long context, right?</p><p>So you can -- this is what we expect, but it's sort of validation of this was one of the primary design points, and they're saying we kind of met the design point. Okay. And then they get into a lot of detail. I'm not -- I'm not going to go into a ton of detail here.</p><p>But there's -- there's this sort of efficient two-stage block convolution algorithm that works well for these explicit parameterizations. So, like, you know, from the upper left, here's, like, just a Toplitz matrix, and you can envision this as just blocks of matrices, right? So, you know, so this is just the full Toplitz, you know, lower triangular matrix.</p><p>I'm just making it into a smaller -- or I'm just chunking it into these different H -- capital Hs. And then -- so what they're saying is that if you -- so you have this, like, a convolution, could -- like, if it's not a full -- if it's, you know, like, a short FIR filter, it's only L sub H long, then I have all these zeros here, right?</p><p>And so that I can actually -- if -- if this is kind of short, then I can actually represent this with just two -- like, the diagonal H0 and then H1 on the -- right next to the diagonal, right? And so I -- this might not be clear from the diagram.</p><p>I'm going to go into that. But just notice there's zeros here, so you don't need -- in this -- you don't need any -- any of the Hs in this lower left-hand corner. And that's sort of -- so, you know, this is a pretty good example. So if you just -- you know, let's say your sequence length is 6 and your -- and your filter length is 4, then -- then you have this, you know, sort of, like, on the diagonal.</p><p>So you have this -- you can look at, like, this here is this, right? And then it's repeated here, right? And then you have this off -- right adjacent to the diagonal, you have this guy, and that's right there. And so that could be decomposed into this plus this, right?</p><p>And so what this allows you to do is much more efficient multiplication. So, and they -- so they, you know, study this, and it's indeed significantly faster in terms of the throughput, especially in terms of teraflops per second. You know, it's basically double or more, two and a half times, I guess, at scale.</p><p>So that's a good thing. And so this can be used for -- definitely for the SE, the small one, and then the small explicit, and then the medium regularized as well, depending on the block size. And so, like -- and then this is a comparison of those blocks to other types of blocks.</p><p>So this is -- this is flash attention, this SPDA is -- is, like, non-flash attention, I guess, and then it compares to Mamba, and then XLSTM, and DeltaNet, which I don't -- I'm not familiar with these two, but presumably they're state-space models. They're linear models, basically, yeah. Okay. Okay.</p><p>Okay. So this is another point. I did not understand this diagram, so I stuck it here in case someone wants to explain it to me. Like, I get the gist of it. So this context parallelism, you know, so basically taking your sequence of, in this case, genes, of tokens, and, you know, sort of inferring it in parallel, and then sharing the -- you know, sort of doing a -- sort of, like, scatter-gatherer approach or whatever.</p><p>I think this is scatter-gatherer, or the all-to-all, to, you know, sort of, like, communicate the pieces that are missing. But this is at a bulk level. I don't -- I have trouble understanding this diagram. I did -- this one is more, you know, sort of obvious to me. And, like, fortunately, we just went over the ultra-scaling handbook.</p><p>And, you know, this is covered in -- in, like, sort of -- or context parallelism is covered in the ultra-scaling handbook that we just went over. But, like, it's a little bit -- I think it's a little bit simpler for convolution than it is for attention. But with that said, you know, this -- this seems pretty -- this is basically ringing attention.</p><p>what -- and you just, like -- this overlap has to be forwarded to the next guy before they can compute. So, I don't -- this one, I don't get. Does anyone understand this diagram? I think it's -- I think to simplify it is think of it as tensor-parallel. So, basically, the bulk of the calculations are done in parallel on multiple GPUs.</p><p>And then, once again, like, you know, state-space models, like, at the end, they are just, like, compression of the states as they merge together. So, done in parallel, merge, done in parallel. And -- and that's -- Oh, I see. That's part of the -- so, the first part is, like, the first chunk in parallel, and, like, by context thing.</p><p>And then, after that, the information is synced across, and then they get merged, and then you get your outputs. Ah, okay. Yeah, yeah, yeah. So, that -- I think I see now. Okay. Yeah. One thing that I actually do admire the state-space team -- their formulation on is -- well, the high-level parts, right, the math can be rather complicated, right?</p><p>They actually design it in a way where you can reduce the operations onto a very few brilliant operations. that is extremely counterintuitive, but it's mathematically right. So, they can do proof that this is a cheap and faster way to, like, do those steps, even though it may seem weird.</p><p>Yeah. Yeah, no. So, I spent, actually, quite a bit of time going through the -- sort of the background papers here to understand how the -- like, especially that -- the mapping from their surrogate attention to -- to, like, these hyena operators. And, like, actually, the math -- I didn't put it in the talk.</p><p>It's actually pretty understandable, and I -- there's no, like -- you don't need differential equations, which is -- like, you need -- if you wanted to do the -- you know, sort of the continuous version, you need to use differential equations. But for the discrete version, like, you just -- it's all just basic algebra to understand.</p><p>I recommend, if anyone really wants to understand what's going on under the hood here, you can go and check out the hyena paper. I can give a link. It's actually linked up above in the talk. Okay. So, that's sort of, like, the machinery. Does anyone want to ask or comment on the machinery part of this?</p><p>Okay. Good. So, they did a bunch of -- they did a whole bunch of evals. I think part of that is because, unlike the sort of, like, actual, you know, natural language version, there are not so many benchmarks. There are some benchmarks, but -- so, they have to -- so, a lot of what they do is benchmark against real-world, you know, sort of, like, real-world data sets that -- that -- that are, like, somewhat commonly used for evals or for -- or in some cases, they just came up with data sets to test against.</p><p>So, they basically developed their own benchmarks for the study in a lot of cases. So, it's a little bit hard for me to understand how -- how well they're actually doing. This is an exception. I guess, needle and haystack, we're all familiar with. And it looks like they -- like, they do pretty well.</p><p>There's not any red except for this guy. This 7B model seems to have trouble at a million context length with depth at 100%. So, for -- I don't really understand why I didn't look into it. So -- but in any event, like, they -- they seem to do pretty well.</p><p>And the way that they do this is they just stick a generated 100 base pair sequence somewhere in the context, you know, at 10% and 20% and whatever. And then they -- and then they perturb it and see if that -- how much that impacts the -- the sort of -- the likelihood of the -- the same sequence at the end of the context.</p><p>So, I think this is -- this closely matches what is typically done for a needle in a haystack test. Except -- one thing that I -- was questionable to me was that -- they used a generated 100 base pair sequence. Instead of -- just a generated 100 base pair sequence instead of using some actual out of distribution, you know, sort of like held out sequence from a genome that is not part of the training set.</p><p>Because -- and I -- I find this questionable because since it's in distribution law, of course, you're going to naturally be perturbed if you have a -- if -- you're -- you're naturally going to have a lower -- or -- -- lower likelihood if you perturb the -- the -- the needle.</p><p>Right? Does that make sense? No, I think that makes sense. So, so I feel like they -- this is -- unless I'm misunderstanding, I don't feel like this is the right test. Like, they should have used something out of distribution. Like, they actually -- in other places, they were really careful to hold out -- like, they held out certain viruses because -- I think for other reasons, but that -- they test whether or not, like, their performance on these out-of-distribution viruses.</p><p>And it's really poor. And that's what -- they had actually intended that -- to be the design. Because I didn't -- I think they didn't want to bring in -- So I feel like they, this is, unless I'm misunderstanding, I don't feel like this is the right test, right?</p><p>They should have used something out of distribution. Like, they actually, in other places, they were really careful to hold out, like, they held out certain viruses, because I think for other reasons, but that they test whether or not, like, their performance on these out of distribution viruses, and it's really poor.</p><p>And that's what they had actually intended that to be the design, because I didn't, I think they didn't want to bring in the genetics from those viruses into the study, or into the model for some reason. Or it might have been just for monitoring, but in any event, they should have used something that was held out from the distribution, or from the training set, sorry.</p><p>So, okay, anyway. So then here, like, they have these, so one thing I love about these bioinformatics papers is their diagrams are often really, really good, and really interesting. So, I don't want to, like, I don't want to, like, I can talk about a few of these. I think the important thing is the title here is that they're able to predict the mutational effect of, on, like, proteins, and as measured in various ways, on RNA, on organism, organismal fitness, and across different domains of life, right, like, not only in humans or something.</p><p>So, so I, if anyone's interested, I can go into the, I think I understand most of these diagrams, but, but I think one interesting thing to note is that these, all these zero shot, So, like, zero shot is really clear what it means in language modeling. In this case, I was a little confused about what they meant by a zero shot prediction here.</p><p>And so what they're typically doing with these, all these studies is they're looking at what is the, you know, the change, like, in some cases, it's the change in likelihood or the likelihood of, you know, sort of a sequence. I mean, using that to, as a threshold on that likelihood or other more complicated things to, to make a prediction.</p><p>So they, so like, in this case, they're using the change in likelihood when they mutate a sequence and they use that as an indicator of whether it's essential or not. Like, and I don't understand the biology of why that's a good test in this case, but, but that's generally, you know, you can see that here as well.</p><p>Here, maybe, I'm not sure it's, it can, can you guys read this, by the way, it might be hard to read and, but like the, so the delta likelihood, you know, like sort of is used to predict that whether or not it's an essential gene. Right. So is that, is that kind of clear from a, at least from a high standpoint?</p><p>So they did it, like you can see each one of these is a section in the paper and they, they really, I think, did a very complete job of looking at, okay, we're trying to build a foundation model. So does it generalize to a lot of different use cases without being explicitly trained on those use cases?</p><p>And I think they did a good job of, of, of making that claim. Okay. And then this is, you know, more of the same kind of, but enables, you know, sort of like human clinical variant effect prediction. So, and I thought one of the, yeah. So basically, similar stuff, but with human clinical effects, right?</p><p>So, and this is probably one of the most important use cases for this model is being able to, to like, like I was saying in the beginning, being able to predict what will this, given the specific genetics of this patient, what will their response to this medication be or something like that?</p><p>Or like, or like, what will their progress, how, how, what, which, how will their, their specific set of mutations impact the way a disease progresses, right? Those are like super useful, you know, things you can imagine everyone gets, you know, you get a blood prick when you get, get on medication, they do, they sequence your genome if it's not already on file.</p><p>And then you, you can, you know, you can pick which medication to take based on, on your specific genome, right? So that's, that's like, and this is kind of enabling that. We don't, I don't know how they claim they're doing a good job. I think it'll, you know, I think it'll, whether that bears out from a clinical standpoint, I don't know, but it like, you know, looks very promising.</p><p>Okay, so a little, sorry, anyone want to ask questions about either of these two slides? Okay, we got 10 more minutes. Okay, so, okay, so let me move Eugene. So, um, this is like information on how they train the model. Uh, um, so interestingly, you know, the way that they thought about this was how do, like, we're going to do a, um, we're, we're going to, uh, train, you know, a base, like, as, as is common with long context models.</p><p>They do like a base training, um, and then they extend the context in, in like, sort of what they're calling mid training, um, that they did that the way they think about this is like, okay, what are the, what are the sort of genetic, um, units that we can fit in, you know, a certain, like an AK context link.</p><p>And so that, you know, you have like these, um, I think tRNA is transcript RNA, you have certain bacterial genes, um, non-coding RNA sequences, which help with the mechanism of transcription and other things like that. Um, and, but like things you don't have are like these sort of like larger eukaryote genes, phages, um, you know, sort of like these transcript domains, um, for humans or yeast cells.</p><p>So like need a longer context. So it's interesting because I think unlike language modeling, you're the, there's the, like these, the things that are here and the things that are here are more qualitatively different, I think. So it's interesting. Um, I found this to be a, like an interesting difference in language modeling.</p><p>Um, and this sort of shows, do you like the, the, um, the token counts for the two models. Um, I won't go into this, the rest of this. I, okay. So then there was a, two really clever things that they did or like that clearly they are, um, they thought carefully about the evals here.</p><p>So they, um, and I, this is part of a larger diagram that I can show, but they, um, is like super hard to understand, or it's like really chaotic and would take like 10 minutes to talk through. So I, but the, the, the gist of it is all captured here where they, you know, they train a sparse autoencoder, they extract features, and then they identify biological features that, that they correspond to.</p><p>Right. And, and so they valid, and they were using this partly as, um, a way to verify that their model is actually learning biologically, uh, relevant things. Right. So there's like sort of the operational standpoint that we already saw where like, yeah, we're able to predict things that are important, but this is more of a, look, you know, sort of a conceptual standpoint.</p><p>Like, can, can, can our, can we learn features that correspond to, um, you know, sort of like boundaries of genes and, um, you know, different kinds of different types of genes and other things like that. Does that make sense? So I, I thought this was, um, interesting to include in an eval.</p><p>Um, I think it's something that maybe, uh, we could do in language modeling as well, now that sparse autoencoders are becoming easier to work with. And, um, the other thing that I thought was pretty clever was that they, um, they, so this chromatin accessibility is like basically an important, uh, so this is epigenetics.</p><p>Um, meaning it's like heritable differences in, uh, the way that your genes are expressed, um, that are impacted by the environment. So basically you're, so it's kind of, you know, I'm probably going to, it's like a geneticist will probably like, you know, throw up if I say it wrong.</p><p>But, um, you know, it's like basically a way that your, your, your genome can learn about its environment, right? So that like you can, so that it impacts how much, or how the ways in which your genome is, is actually expressed based on your environment. And you can pass this in some cases onto your children.</p><p>And so it's also heritable, but it's a different mechanism. Um, chromatin is one of the main ones. There are others, so, um, so what's going on here is, um, they, uh, they basically want in order to, to be able to either do, you know, sort of like in, like, um, like in, uh, com computer simulation.</p><p>Um, like using their model or other things of chromatin accessibility, or actually to design, um, design genes that they can, you know, use CRISPR and other, um, additive mechanisms to stick, uh, things into, uh, into the genome. Um, and, and, and, and, and be able to control it's, you, this quote, unquote, chromatin accessibility.</p><p>So what they. Did was they basically sampled sequences and then they use this. Like, you can just think of this as a classifier basically is, is, is, is this region accessible or not? Um, and then they would, they accept some and rejects them and then they just shop out the rejected part and then like, according to the criteria and then, um, and then just keep reject and then take the only the accepted part.</p><p>And then generate from there on and, and then just keep iterating in that. So it's sort of like a, um, um, constrained generation basically using this sort of, um, this, this, um, really complex model to be the, be the signal that decides whether or not to reject or, or, or like the constraint.</p><p>So I thought this was also very clever, um, take on constrained generation. Um, and like, sort of get, it, it, it got me to thinking about, okay, what besides like, you know, right now we have these very deterministic things that we do, uh, constrained generation with what are the, you know, sort of more, uh, more sophisticated things and like sort of models and downstream things that you could use for constrained generation.</p><p>So that's okay. So like this, you know, again, like sort of truck driver stop, but that's the end of the slides. Does anyone want to comment, ask questions? I can review stuff. We have only three minutes. Uh, there's a question regarding, do you get a chance to look into how the data collection was done?</p><p>Like what was done for evil one? What was done for evil two, um, specifically, I guess for the training and processes and all that. Yeah. So, uh, they do go over that in the paper. Um, uh, they actually, they, they formed a reasonably large data set. Um, here, let me see if I can grab the paper.</p><p>Uh, let's see. So, um, um, I think it's, there's a good table of contents. Let me look at that. But basically, um, the, the nutshell is that they had a, they had a data set that they reused from between evil one and evil evil two. Um, they, they curated, there's a whole data collection section.</p><p>Maybe it's towards the end. Or in the appendix, maybe here, um, inclusion, additional results. No, uh, sorry, I don't have, I can't pull it up, but, um, yeah, so I, I, so they, um, augmented. So the, the, the thing that stood out for me was that they, um, they added, so they use both DNA and RNA to train, so they, um, so they, you, and they did that explicitly because they wanted to be able to model, uh, RNA sequences and protein as well, or like sort of, um, do downstream tasks related to RNA and DNA.</p><p>So, and what they did was they, uh, um, they switched the U symbol to the T symbol, so it looks like DNA and so that they keep the vocabulary the same. And the, the other thing that, uh, they, that was notable in my mind was that they, uh, they left out certain viruses or many viruses from the, I think bacterial viruses out of the training set.</p><p>And I, I actually don't recall whether that was because they didn't want to pollute the data set with genes that were, that would be problematic or whether it was just because we want, it's different and we want to be able to measure the difference between in and out of distribution data.</p><p>So, um, but yeah, they left that out. Um, there is, it is in the paper. It, it's, it's well-documented how they collected the data. I just don't remember it. Hmm. I guess, did they collect the data or did they filter existing public data sets? Yeah. Yeah. Yeah. No, no, no.</p><p>Yeah. It's all, I mean, it would be enormously expensive to collect the data yourself. Yeah. They, they, they filtered public data sets. Uh, actually there's one thing that I found very interesting about the, can you scroll up to, to the part where they do the 8k to, to, to the larger context thing?</p><p>Yeah. Uh, that's in the beginning, I think. Oh, uh, oh, sorry. You had, you had it in one of your slides. Yeah. Yeah. It's yeah. Let me, I'll just go back to the slides. I guess. Yeah. Yeah. Uh, yeah. Where was it? So here, oh no, it's, it's down here.</p><p>Like, to be fair, I am no, I am not a genome expert. So, so, so, so, so there was, there was some things that I found interesting in that one, uh, which maybe some, uh, someone else who, who's a genome expert can chime in. But what I found interesting, right.</p><p>Is that, so in text modeling, for example, right. Um, when we want to train on the smaller context thing, right. One of the things that we do is just chunk the data. So we're, so like in the equivalent, right. We'll take the large, large Wikipedia pages, let's just say the, the bacteria, and we just split them into like a hundred chunks.</p><p>And then we just throw it into the, into the training for 8K. But in this case, from what you explained, I think you kind of said that they didn't do that. Um, they basically just use all the, all the infer, all the genome sequences that were less than 8K as the training data.</p><p>That's what it seemed like to me. Yeah. And that generalized. And that to me was surprising because, because it's like, it just means that the vocabulary, like the grammar, so the, the equivalent would be like the English grammar here, right. Is consistent enough at 8K that even generalized to, to the larger context thing.</p><p>And, and the, the analogy in my head, right. Is let's just say all of this, um, the, the, the, there is a basic grammatical rules of, uh, Anglo-Saxacan languages, basically English, French, that, that, that whole category, not including Chinese and Japanese, because there's, there's a different category altogether. Like they all same, they share the same lineage.</p><p>And so that they have some approximate equivalent. And if you just learn the, the, uh, the early Latin languages equivalent, and then you follow down that trail, somehow it's convertible. So that to me was interesting because it just means that the fundamental concept is maybe at the end of their base pairs, um, there's just some meaning and rules that we, we haven't fully understand and this, and it's captured in 8K.</p><p>Yeah. Yeah. Yeah. No, I, I thought that was really interesting too. Yeah. Yeah. But once again, I know, you know, expert, I may have gotten that completely wrong. Yeah, exactly. That's the same language modeling thinking. Yeah. Yeah. Awesome. Well, I think we're out of time. Uh, I don't want to hold people past the, the, the close.</p><p>I'm happy to, uh, continue chatting on, on discord or whatever. Um, uh, but you know, thanks. Thanks a lot for listening. I hope I, I hope this was interesting to people. I'm super excited about, uh, genetics. I think I'm going to dig in further. I'm working with, uh, somebody to actually put together a class on, uh, on single cell AI models, um, and the sort of things downstream from those.</p><p>So, um, you know, if you're interested, let me know, I'll, I'll try to include you. The, I actually think it's interesting because like the, I've seen papers on genetic modeling. There is like sub model size. You can conduct a class to build reasonable models on a laptop. Yeah. Yeah.</p><p>Yeah. Yeah. Yeah. Well, and especially in single cell, the models are much smaller too, right? Cause you're looking at gene level, not at nucleotide level. Yeah. Cool. All right, guys. Well, see you guys on discord. Thank you very much. So it's fun for me. Hope it was fun for you.</p><p>See you guys. Bye. way.</p></div></div></body></html>