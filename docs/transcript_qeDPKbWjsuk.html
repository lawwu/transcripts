<html><head><title>Keynote: The AI developer experience doesn't have to suck – why and how we built Modal</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Keynote: The AI developer experience doesn't have to suck – why and how we built Modal</h2><a href="https://www.youtube.com/watch?v=qeDPKbWjsuk" target="_blank"><img src="https://i.ytimg.com/vi_webp/qeDPKbWjsuk/maxresdefault.webp" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>Hi, my name is Eric Bernhardson. It's great to be here virtually. Who am I? I am the CEO of a company called Modal. We are based here in New York. Most of my background is in data, AI, machine learning. And in particular, I was at Spotify for many years and built a music recommendation system there.</p><p>I did leave about 10 years ago and did all kinds of other stuff in between. But started Modal about four or five years ago during a pandemic. And the mission I had at that point was to build an infrastructure platform for data, AI, machine learning in a way that makes it fun again to write these applications.</p><p>Basically to deploy models, scale them out, run large-scale back jobs, making it possible to focus on writing code and not have to deal with infrastructure. As it turned out, Gen.AI was a perfect use case for this. We just didn't know it at that time. Modal is very much focused on high code use cases.</p><p>What that means is we focus on people who want to write their own code, in particular, writing their own models, but also in many cases using existing models in a way where you want to have control over the workflow or other thing. And so you can think of it more as like Kubernetes or AWS Lambda in the sense that we can run arbitrary containers or arbitrary code.</p><p>We do focus on Python right now, might add other languages in the future. Unlike a system like Kubernetes, we're fully managed. So we run all the infrastructure. We have a big pool of thousands of GPUs and CPUs, but we let you run all kinds of applications in our cloud.</p><p>And this could really be anything. In that sense, we're not an AI API. We don't have one model or 10 models that we put behind an API doing that token prediction. You can really run anything, which puts a little bit more onus on the developer to build this thing, but it also makes this a lot more powerful.</p><p>In particular, when I think about platforms and how they make you productive and makes it fun to write code, a lot of my experience is that it comes down to fast feedback loops. So in order to make engineers fast and make it more productive, you want to have this like super fast feedback loop that let you iterate on code very quickly.</p><p>I think cloud has been a phenomenal invention and lets us build things with far more powerful things. But it's arguably a step backwards in terms of developer experience. And thinking a lot about this problem, what I realized was in order to solve this, we had to build our own system to start containers in the cloud very fast.</p><p>Because if you can start containers in the cloud very fast, you can take code that the user is building locally and execute in the cloud, maybe inside a custom image running on a GPU, whatever, and have that sort of fast feedback loop that you like when you run things locally.</p><p>As it turns out, solving container cold start in a distributed system is a very, very deep rabbit hole. We had to build our own scheduler. We had to build our own file system and many other things. We set out on a multi-year journey that we still haven't completed, building a lot of this very, very core, very foundational infrastructure.</p><p>Model today, you can think of it as two facets. One is a big resource pool. We run thousands of GPUs, different types, H100s, A100s, L4s, T4s, you name it. And the only way to access those is through a Python SDK. We might have a language in the future, like I mentioned, but right now it's Python.</p><p>And the reason we started with Python is obviously that Python is such a dominant language in AI. machine learning and data applications. One way to think about modal is that it's a serverless framework that basically lets you take any Python function and turn that into serverless function. And so you do that by applying this decorator, as you can see in this code sample.</p><p>I'll show you a little bit more examples in a second. People use modal for very large-scale applications, but also small-scale applications. The biggest use case is most likely Gen.AI in France. We, in particular, have seen a lot of traction within diffusion models. So, for instance, AI-generated music, video images, but also a lot of batch jobs, a lot of, for instance, processing very large-scale medical images or doing computer vision on frames of videos.</p><p>I'm seeing a lot of traction in computational bio, things like protein folding, both things running on GPUs, but also CPUs. Of course, LLMs. You can't talk about Gen.AI without mentioning LLMs. We have a lot of fine-tuning applications, batch embeddings, of course, inference as well. Some of our customers, one of the customers I always think is incredibly cool is Suno.</p><p>They do AI-generated music and run a lot of their inference on modal, but we have many other use cases for modal, some running a very large scale, doing all kinds of different applications. Modal, it's a little bit abstract to talk about modal without going into code. So I'm going to do some live coding, so let's jump into the terminal, and I'll show you exactly, try to give you an idea of what it looks like in code.</p><p>So let's look at a very, very basic modal application. Modal, basically, one way to think about it is we take Python functions and turn them into things that run in the cloud. There's a very simple function called square, which returns a square of a number and also prints on stuff to standard error.</p><p>And this decorator that we apply, app.function, takes that and turns that into a serverless function running in the cloud. And there's a few different ways to invoke this thing, but we have a little thing here that basically makes sure to trigger it from our laptop when we run it from the command line.</p><p>So we're going to do that. So modal has a little command line interface where basically it lets you run things interactively. And what happens when we run this thing is we take the code, we stick it in a container, we execute it in the cloud. As it's executing, it streams the output back.</p><p>And the whole point of this is, like, we want to make it fast and feel like we're almost developing things locally. It's almost as fast as running things locally. And this extends to things like, let's say we want to edit this thing and just, you know, print something else.</p><p>And instead of having to rebuild a container, push up the container to the cloud, download logs, et cetera, with a slow feedback loop, it just picks up the latest code, right? And rebuilds the container automatically and all these things, right? And so while you're, like, building applications and rewriting code, you can always just run things in the cloud very, very fast.</p><p>So far, this is just showcases, like, the sort of iteration speed. But also, let's look at the power of modal. Like, what can you do with modal? Like, what kinds of stuff can you, can we get to scale? Can we run things on other types of hardware? So let's actually run this on an H100.</p><p>And the way in modal you do that is by saying just on the function decorator, you say GPU equals H100. We have a bunch of other types. As I mentioned, we have A100s and T4s and all kinds of other ones. But let's run this on an H100, which is NVIDIA's flagship.</p><p>And we can get access to an H100 in a couple of seconds. This is obviously not using the H100, but we're running it in a container that has access to an H100. So let's say we want to actually access it. Now we need to probably install some software, right?</p><p>So we might want to install Torch in this case. There's a few different ways you can do that in modal. You can give us a Docker file. You can also point to Docker image. But the easiest thing to do that is to basically define the entire compute environment in code.</p><p>So we're going to define the container image using modal's Python SDK. So we're going to say image equals modal.image.debian slim as the base image. And we're going to pip install Torch. And then we're going to use this image on this function. And we're going to import Torch. And just to show that it works, we're going to print Torch.cuda.get device name.</p><p>Hopefully this works when I run this. We'll delete this line. And when I run this thing, hopefully it will print something like we're running on H100. And as you can see, it's still very fast, but slightly slower this time because loading Torch takes a little bit of extra overhead.</p><p>And we'll talk about in a second what we've done to reduce that overhead. But it takes maybe about a second to initialize Torch. Okay, cool. So now we can run stuff on H100s. Let's try to run things on a lot of H100s. And so let's try to scale things out a little bit.</p><p>In modal, any function can, you can map over any function in modal just in code. So instead of calling just a single function invocation, we're going to fan out and do 1,000 or maybe let's do 10,000 function invocation. And you can do this in code by just saying we're going to map over 5,000.</p><p>As I said, 10,000 actually. So let's do that. And we're going to unpack the iterator. And let's print X just to show some progress. And what modal does when you fan out is that it's going to spin up as many containers as possible. And so you can see we're already running five containers, six containers, eight containers.</p><p>It makes it very easy to fan out and start, you know, even hundreds of containers or even thousands of containers running on GPUs. If we keep this running for several minutes, we can easily scale up to a very large number. So this gives you basically the ability to take something like, you know, that needs a lot of compute and, you know, something like a batch job and fan out, spin up thousands of containers, paralyze over it, and get results much faster.</p><p>We're going to take a look at the UI for a second. Modal also has a UI that you can access. If you go to the website, the URL is printed in the console. So let's take a look at that. So we can see the app details in our UI.</p><p>There's all kinds of interesting things here. Modal has a pretty rich UI that lets you see container metrics, logs, lets you set up users and many other things. So if you zoom in, for instance, on the number of containers, we can see here we spun up 18 containers at peak.</p><p>As I mentioned, if we had kept going, we would reach a much larger number, we got 18 containers at this point. We can look at the CPU utilization, GPU, et cetera. We can look at GPU temperature, 33 Celsius, even the watt consumption. So there's a lot of other things here.</p><p>We can look at app logs and many other things. Okay, let's switch back to the terminal for a second and see some other stuff. There's a lot of stuff, so I'm not going to go into every single possibility of how to use Modal. But one thing I didn't show that I think is interesting and very valuable is you can also deploy these things.</p><p>So, so far, we only showed how to run things interactively, which means we run things from our laptop. But if I take this code and deploy this using Modal Deploy, we get this persistent endpoint. And what's nice about that is now we have this thing we can call from any other context in Python.</p><p>And I'm just going to show this using my repl. If we import modal, and if we do lookup like this, we get this handle to this remote function. So let's call this. And the first time we're going to call it, we're going to have a call start. So it's going to take a couple of seconds because the container has to start up.</p><p>And remember, we're importing Torch and we're running this on an H100, so it takes a little bit of extra time. The container keeps running for 60 seconds by default and then it shuts down. So now it's actually idle. So if we call this again, typically it would be a little bit faster.</p><p>And we're obviously wasting an enormous amount of flops using a GPU to calculate the square of a number. But this showcases how you can easily take things and deploy it, even on very powerful hardware and build these serverless endpoints. For instance, doing inference. And modal handles all the scaling.</p><p>So when you invoke this function, multiple times, we'll just scale up using more and more containers and shut down. Many other things you can do with modal. You can set up distributed file systems that you can mount to each container. So you can exchange information using the file system.</p><p>You can set up web endpoints. You can set up cron jobs and many other things. So this hopefully gives you a little bit more of an idea of what modal looks like from an engineering perspective. What does it look like when you're interacting through code with modal? Let's talk a bit about how modal works under the hood.</p><p>And as I mentioned, modal, in order to deliver on this developer experience that I always wanted to have, we had to go down this very deep rabbit hole and build a lot of custom infrastructure ourselves. And that's the only way we felt that we can make it fast enough.</p><p>We couldn't use Kubernetes. We couldn't use Docker. So we had to build a lot of this stuff ourselves. And it should be pointed out. We're standing on the shoulders of giants here. We're using a fantastic container runtime called GVisor that gives us isolation, but we had to build a lot of stuff around it.</p><p>We had to build it on scheduler and many other things, but we're obviously using a lot of the existing things in Linux and other systems. And we're using fantastic cloud tools as well. In order to deliver the developer experience that we wanted to, as I mentioned, and the feedback loops that we wanted to, we had to figure out container cold start.</p><p>And container cold start, starting containers fast in a distributed system is a hard problem. So let's talk about what containers are to start with. Containers are, and this is my super crude, unfair generalization of what a container is, or container image. It's basically two things. It's a root file system, so that's like the slash that you have in Linux that contains all the data on your drive.</p><p>And then it's a bunch of stuff to isolate processes, so they can't tamper with each other. There are many inefficiencies with how container images are stored and how container images are transferred. In particular, one of the issues is that there's a lot of junk. There's a lot of stuff we're never going to read.</p><p>Like many container images has Perl installed by default, man pages, locale information, time zone information for Uzbekistan. You're never going to read this stuff. So we're sending all this data back and forth. And the core thing here is we want to start containers on a remote file, on a remote worker very, very fast.</p><p>We want to minimize the amount of data that has to be transferred. We want to do as little as possible. The other inefficiency is that there's a lot of redundancy in this. A lot of the files that are being transferred back and forth are actually the same files. So if you grab just like three very different container images like I did in this case, and you look at the files, it actually turns out to be mostly the same files to a very large extent.</p><p>So with those two tricks, with those two observations, there's a number of tricks we can do. And so we built what's called a content address storage. And this is not a new invention. This is not something we came up with. But it's rarely used in production systems. Notably, AWS Lambda actually uses the same technique.</p><p>And the idea is that instead of storing the images directly, we store the images, the container images, as just a bunch of metadata that points to blobs. And for each blob, we compute a checksum or a hash value. And then we use that to deduplicate all the blobs because there's an enormous amount of redundancy in these blobs.</p><p>And this means the container images themselves are actually just little pieces of metadata. And in many cases, we can cache a very large percentage of the container images and we can also avoid pulling data that we're not going to need by lazy loading a lot of the data on access.</p><p>This is tricky because container cold start in particular with Python is very latency sensitive because we end up doing a lot of very sequential file accesses. So in many cases, when a container starts up in modal or in Python, in any case, it requires reading every single module, every single Python module, which is many, many cases, it ends up being several thousand Python modules.</p><p>Each one of them requires accessing the file system and so what we can't allow is that to take several milliseconds, because if you're doing something that takes several milliseconds and you're doing it a thousand times, it ends up taking several seconds and we want to avoid that. So there's a lot of tricks that we have to do in order to basically get this down below a second.</p><p>We do a lot of prefetching, we do a lot of task tracing, we look at, you know, historical runs and see what types of files was accessed last time it ran. And then building these containers is obviously also another whole challenge. We basically built our own container image builders.</p><p>Another technique that we're also more recently started leveraging is we can snapshot the CPU memory. So we talked about how we snapshot the container images and we cache a lot of the data, which means like when you're loading it, you don't have to fetch a lot of data. But what if we can avoid loading the data in the first place?</p><p>What if we can just like revert to the memory state, the CPU memory, the RAM of a container? And as it turns out, GeVisor actually supports this. And that's another way that arguably supersedes a lot of the previous stuff. In practice, they end up kind of both reinforcing this container cold start.</p><p>But this lets us cut down even more dramatically. Things like stable diffusion, we can now start in a couple of seconds, even though it involves loading very, very large model weights, like, you know, five or 10 gigabytes. We're also looking at GPU snapshotting, which will make things even faster, which is very exciting.</p><p>And so doing all these things, you know, owning the entire stack, owning the file system, you know, building a storage system. I didn't talk about the storage system. We basically use R2 and we run in many different regions. And so we use both the CDN and the R2. And so all these optimizations together means we kind of solve the problem of container cold start.</p><p>And let's remember, why did we originally set out to start this thing? It's because we want to deliver good developer experience. As it turns out, it's good for other things, too. So container cold start is also good because it enables serverless. So what does serverless mean? It means a lot of different things.</p><p>I think part of why sometimes I avoid the term serverless is that it has so many different definitions. But the promise of serverless was always don't provision more than you actually need. Just, you know, only pay for capacity you're actually using. And so, especially with GPUs, which are very expensive, as it turns out, you can pack, take a lot of different users, pull them together, and give people dynamically the resources they need and get dramatically better utilization.</p><p>And so that, in turn, means we can get lower cost. It means there's no capacity planning. It also, because we can pull a lot of these users, the variance, the total variance goes down, the relative variance, which means we can run a much more predictable set of resource pools, the total capacity that we run.</p><p>Which is another problem, by the way. So we need to run thousands of GPUs. We use a lot of different cloud vendors. We use a lot of different regions. We scale up and down continuously. In fact, we actually end up solving a mixed-energy programming problem to do this, minimizing the total cost spend.</p><p>And this is some of the stuff we have to do for our customers so they don't have to think about it. So through model, you can come in and you can request 100 GPUs. Under the hood, there's enormous amount of work that we had to put in in order to get the capacity somewhere in the world, you know, spinning up GPUs if needed.</p><p>But in many cases, it happens instantaneously because we can maintain a buffer that makes it very fast to get access to these compute resources for any customer. This was very technical, but just to kind of go back and look at a high level again, why do people like modal?</p><p>People pick modal because they can run their own code. We're not an AI API, so to speak. You can run almost anything with modal. We make it possible to iterate very quickly. We're fully usage-based. So when you run things in modal, you only pay for the time the containers are actually active.</p><p>You have to never think about capacity. You don't have to, you know, go out and buy, you know, hundreds of GPUs or thousands of GPUs. We can get you that within, you know, seconds or at least minutes. So there's a lot of things, this sort of burden of infrastructure, building your own internal platform, setting up Kubernetes, setting up, you know, Docker and all these things.</p><p>You don't have to think about this with modal. How do you try modal? It's actually very simple. You go to your terminal and you do pip install modal. The Python client automatically, you know, configures itself to connect to modal. And you can immediately start running stuff because we give everyone $30 per month of free credits.</p><p>If you are a startup, we can give you up to $50,000 in credits in order for you to get started. Thank you. And I really hope you enjoy this. And if you have any questions, feel free to reach out at ericmodo.com. You can also follow me on Twitter, Bernhardson, or check out my blog, ericbern.com.</p></div></div></body></html>