<html><head><title>Are scaling laws explained by memorization and not intelligence? – Francois Chollet</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Are scaling laws explained by memorization and not intelligence? – Francois Chollet</h2><a href="https://www.youtube.com/watch?v=rl7B-LHiaNo" target="_blank"><img src="https://i.ytimg.com/vi_webp/rl7B-LHiaNo/maxresdefault.webp" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>general intelligence is not task-specific skills scaled up to many skills, because there is an infinite space of possible skills. General intelligence is the ability to approach any problem, any skill, and very quickly master it using valid data. Because this is what makes you able to face anything you might ever encounter.</p><p>This is what makes, this is the definition of generality. Like generality is not specificity scaled up. It is the ability to apply your mind to anything at all, to arbitrary things. And this requires, fundamentally, this requires the ability to adapt, to learn on the fly efficiently. The scale maximalist argument, really, it boils down to these people, they refer to scaling laws, which is this empirical relationship that you can draw between how much compute you spend on training a model and the performance you're getting on benchmarks, right?</p><p>And the key question here, of course, is, well, how do you measure performance? What it is that you're actually improving by adding more compute and more data? And well, it's benchmark performance, right? And the thing is, the way you measure performance is not a technical detail. It's not an afterthought, because it's going to narrow down the set of questions that you're asking.</p><p>And so accordingly, it's going to narrow down the set of answers that you're looking for. If you look at the benchmarks we're using for LLMs, they're all memorization-based benchmarks. Like sometimes they're literally just knowledge-based, like a school test. And even if you look at the ones that are, you know, explicitly about reasoning, you realize, if you look closely, that in order to solve them, it's enough to memorize a finite set of reasoning patterns.</p><p>And then you just reapply them. They're like static programs. LLMs are very good at memorizing static programs, small static programs. And they've got this sort of like bank of solution programs. And when you give them a new puzzle, they can just fetch the appropriate program, apply it, and it's looking like it's reasoning, but really it's not doing any sort of on-the-fly program synthesis.</p><p>All it's doing is program fetching. So you can actually solve all these benchmarks with memorization. And so what you're scaling up here, like if you look at the models, they are big parametric curves fitted to a data distribution, which I can't understand. So they're basically these big interpolative databases, interpolative memories.</p><p>And of course, if you scale up the size of your database and you cram into it more knowledge, more patterns, and so on, you are going to be increasing its performance as measured by a memorization benchmark. That's kind of obvious. But as you're doing this, you are not increasing the intelligence of the system one bit.</p><p>You are increasing the skill of the system. You are increasing its usefulness, its scope of applicability, but not its intelligence because skill is not intelligence. And that's the fundamental confusion that people run into is that they're confusing skill and intelligence. As far as the interpolation goes, so okay, let's look at one of the benchmarks here.</p><p>There's one benchmark that does great school math, and these are problems that like a smart high schooler would be able to solve. It's called GSM 8K, and these models get 95% on these. Like basically, they always nail it. That's the memorization benchmark. Okay, let's talk about what that means.</p><p>So here's one question from that benchmark. So 30 students are in a class, 1/5 of them are 12-year-olds, 1/3 are 13-year-old, 1/10 are 11-year-olds. How many of them are not 11, 12, or 13 years old? So I agree, this is not rocket science, right? You can write down on paper how you go through this problem, and a high school kid, at least a smart high school kid, should be able to solve it.</p><p>Now, when you say memorization, it still has to reason through how to think about fractions, and what is the context of the whole problem, and then combining the different calculations it's doing. It depends how you want to define reasoning, but there are two definitions you can use. So one is, I have available a set of program templates.</p><p>It's like the structure of the puzzle, which can also generate its solution. And I'm just going to identify the right template, which is in my memory. I'm going to input the new values into the template, run the program, get the solution. And you could say this is reasoning. And I say, yeah, sure, okay.</p><p>But another definition you can use is reasoning is the ability to, when you're faced with a puzzle, given that you don't have already a program in memory to solve it, you must synthesize on the fly a new program based on bits of pieces of existing programs that you have.</p><p>You have to do on the fly program synthesis. And it's actually dramatically harder than just fetching the right memorized program and replying it. I think maybe we are overestimating the extent to which humans are so sample efficient, they also don't need training in this way where they have to drill in these kinds of pathways of reasoning through certain kinds of problems.</p><p>So let's take math, for example. It's not like you can just show a baby the axioms of set theory, and now they know math, right? So when they're growing up, you had to do years of teaching them pre-algebra, then you got to do a year of teaching them doing drills and going through the same kind of problem in algebra, then geometry, pre-calculus, calculus.</p><p>Absolutely. So training... Yeah, but isn't that like the same kind of thing where you can't just see one example and now you have the program or whatever. You actually had to drill it. These models also had to drill with a bunch of returning data. Sure. I mean, in order to do on the fly program synthesis, you actually need building blocks to work from.</p><p>So knowledge and memory are actually tremendously important in the process. I'm not saying it's memory versus reasoning. In order to do effective reasoning, you need memory. Yeah.</p></div></div></body></html>