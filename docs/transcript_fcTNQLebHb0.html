<html><head><title>Muon and Kimi K-2 MoonShot</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Muon and Kimi K-2 MoonShot</h2><a href="https://www.youtube.com/watch?v=fcTNQLebHb0" target="_blank"><img src="https://i.ytimg.com/vi/fcTNQLebHb0/sddefault.jpg" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>Very well, also, so I, and I think, um. You went over the, like this plot last time, or was it 2 weeks ago? I can't remember where, you know, like, basically summarize this kind of summarize what you just said, which is that, like, they're really just. Um, really doing better than the competition for the number of flops that you spend and like, you know, this is another way of saying that with this, um, scaling curve.</p><p>Um, so. So, then, um, why the question, of course, is why does it. Do so much better and this technical report is about how they accomplish this and a little bit about why I, I found that, um. I think there's a lot of implicit knowledge for people who, um, like follow optimization, um, that I didn't have.</p><p>So I kind of dug in a little bit deep on some of the, uh, some of the details here. Um, um, I, the questions that I had, maybe not the same questions that other people have. So I, I want to make sure that, um, I'm answering other people's questions.</p><p>So, um, I'm not keeping an eye I'm not keeping an eye on the chat, but if you please, like, interrupt and whatever. If you, um, if you, if you have other questions or I explain something poorly or I get something wrong, they definitely could, because this material is not super familiar to me, so I may have misunderstood something or get a detail wrong or whatever.</p><p>Um. Um, okay. So without further ado. Um, so the point of this page, so there were some early results with one that were really promising, but that the performance of it, the optimization um, diminished, um, as, um, as the models scaled. And so this was this technical report was okay, but we can do some tweaks and, um, and actually scale to large models.</p><p>Um, and so, um, but I think I think a lot of the meat is actually in understanding what's going on here is actually in just understanding the one, um, itself. Um. Which I think was, I don't know that there's actually a paper on it. I think there's a blog post on it.</p><p>Um, and it's a, you know, a sort of evolution of optimization technique called shampoo, um, which I have not studied. And then Adam, uh, is also, um, you know, one of the dominant, uh, optimizers. And so, like, and if, in case you're like really new, um, these are all optimizers that, so you're doing, um, back propagation to train your neural network.</p><p>And, um, when you do, every time you do a forward pass, then you have some, some loss, meaning the error between what you predicted with the neural network predicted and what it should be. And then that loss is used to, to calculate a gradient on the parameters of the neural network so that I know, okay, in order to get closer to where I'm supposed to be, then what's the difference between what I, what the parameter values that I have set currently and what they should have been to do better.</p><p>And, and so I do this a whole bunch of times with different data, um, chunks of my data, different batches of data. And then eventually like that sort of causes what's called the scope stochastic gradient descent towards the, you know, sort of optimal setting of those parameters. And of course, this is like not the convex problem.</p><p>So meaning that, that like when I'm doing gradient descent, when I'm going down the hill, um, I might get in like a little local valley and get stuck there. But, um, so some of, some of the techniques that we'll talk about are to avoid that. Um, uh, so, okay.</p><p>That's my like really high level introduction, uh, sort of what this algorithm does in terms of the sort of ecosystem of, uh, neural network stuff. Um, okay. So, um, um, so quick, quick, quick, quick note. So I'm God has joined your second cohost. He's enjoying, sorry. I had trouble giving him zoom link.</p><p>Um, so he'll, he'll help with presentation, I guess on the background of optimizer. So like you mentioned, there was regular gradient descent, which is you do all parameters kind of what's the change and update in general. Then the kind of iteration loop for people that haven't really followed is like from there, we went to adaptive per parameter.</p><p>So like at a grad RSM prop where like, okay, for specific parameters, maybe we change them differently than the whole network. Then Adam had this, like the Adam optimizer was pretty big in like 2014. That was like, okay, let's, let's have this concept of momentum, right? If we're moving in the right direction, it's like gradually increase and have adaptive scaling.</p><p>Adam w was like, okay, we like momentum, but let's separate weight decay. Cause we, we want weight decay from gradient step to be separate. Uh, then from there is, you know, where we have stuff like this and this stuff, like no one has really scaled it, but that's like the little bit of middle ground.</p><p>Yeah. Okay. Yeah. Good. Thank you for that. Um, uh, okay. So, um, let's see. So the, the, um, so this, you know, like Vivo was just saying, you know, weight decay here, um, you know, you know, is important, but, um, uh, they, they, you know, sort of created a technique to set that.</p><p>The weight decay relevant parameter, um, automatically. And so that, so that's one of the things here. Um, um, um, um, they talk about like a distributed version that works. Oops. Sorry. Uh, let me undo that. Um, um, that, that works with, with zero, meaning the, um, zero is what is zero stand for again?</p><p>Uh, uh, uh, Vivo, you help me? Um, it's, so zero is like, you know, sort of like fully, uh, parallelized across multiple dimension. Um, training, um, multi GPU and stuff. Yeah. Zero zero one, two, three, different, different levels of distributed training. Right. Right. So it's a efficiency, right? So instead of like having all weights on all GPUs, there's different degrees at which you can do zero optimization.</p><p>Yeah. And this is compatible with zero. Yeah. So they're, they're previously, um, had some problems distributing. And so that this, this is how do we do that? So this is basically essential for actually scaling to a large model. Um, and then they look at the scaling laws and compare to Adam baseline.</p><p>And, and it's, you know, I sort of like way better. So, uh, right there. Okay. So, um, so, okay, so I, I, so the thing that I actually got out of the paper was more just move on and not the, these three points here, which I think are cut to me are kind of like more engineering.</p><p>And, um, so like definitely other people will have different interests here, but I thought the thing that I can do is really understand, uh, what's going on here and as best I can, and try to explain it to you guys. So, um, so like, this is the sort of like core algorithm, right?</p><p>Where you, so you have this momentum, this M here, and, um, and the momentum is just at every time it starts at zero, all zero. And then the, so like, if this is M, if we're at MT minus before step one, I have, you know, I'm forming my first one, then it's just going to be the loss.</p><p>Um, the gradient of the loss function on the weights. Okay. And then every time, and then I, every time I'm taking like a trade off between this, so this, this new parameter kind of trades off between the momentum and the loss. And so this determines how much do I pay attention to the past versus the current gradient.</p><p>Okay. And then, and then this, or, so this O step is kind of the core of what, what this algorithm is doing. And this is what they call orthogonalizing the, the matrix. And so I actually didn't understand what they meant by that because, uh, like, if you think about, if I don't, you know, and again, I will.</p><p>I'll try to like play a middle ground between people who understand linear algebra well, and those who don't, um, I'm, I'm somewhere in the middle. And so I'm, I'm, I'm, I'm not a great linear algebra, but I have a reasonable understanding. So like, if you look at singular value decomposition, which is how you would calculate an exact, I can decomposition or singular value decomposition of a matrix.</p><p>Um, you would, um, uh, that that's like a expensive, very expensive, uh, thing to do. And so this Newton Schultz algorithm is just a way to, is, is sort of like a way to approximate that. But it's not quite because, um, you, when you do a singular value decomposition, you're getting like this, these specific set of outputs.</p><p>That is like the eigen eigen, uh, values, which is like the sort of amount that I'm moving in that my, um, transformation scales things in different directions. And then it's, and then like the eigen vectors, which point in which directions. And so I was a little confused about what they mean by an orthogonalizing a matrix.</p><p>So, um, the way, so I, I kind of like had to do the, you know, sort of little diagram here. So sorry if it's a little bit, um, scratchy, but you can think about, so let's just look at this. Um, and by the matrix here and you have, so I just picked arbitrary values.</p><p>And so D like in, in our case, just to keep things concrete to what we're talking about here. So D is like the, pretty much the hidden dimension of the neural net or of a given matrix. So this is done per weight matrix, not for the whole weight matrix.</p><p>So you, it's basically the hidden dimension. Like it could be, depending on which one, it could be like some multiple of the hidden dimension or whatever, but it's kind of generally that order of magnitude. And so we're talking like 4096 or something like that. And then, um, the end here is the batch size times the sequence length.</p><p>So batch size is, I don't know what, like, uh, somewhere between like 256, probably to, I don't know, a couple of thousand. And then the sequence length is what we all talk about the context window length. Right. So that could be, I think they've mentioned in the paper for the, the trainings that they did.</p><p>They were at 4,000 and 8,000. So these are like in the millions basically. Um, so like much higher dimension. So my N is more than my D. Right. And so that what the key observation, one of the observations here is that this is low that like a reduced rank makes matrix.</p><p>Meaning I'm on a subspace of the total number of dimensions. So for example, um, and if, and in this case is three dimensions. So I have these three blue lines that kind of sort of try to draw this three dimensional space. And then I have these two black lines, which try to draw.</p><p>There's a plane that are defined by these, um, two vectors, right? These two, three dimensional vectors. There's they, those, those two define a plane. And then what I'm doing by orthogonalizing is I'm just finding. Two, um, two unit one, uh, unit length vectors that are on that plane. Um, that are, or are orthogonal to each other.</p><p>They're perpendicular to each other. And so, and so that, um, and it, like, you'll notice there are infinite number of these. So it's not a unique solution, but that, um, I'm just, and okay. So we'll talk about why, but that's what's going on here is that that's what this, uh, Newton Schultz thing does.</p><p>And this is in the, this is actually not in the weights. This is in the, uh, gradients of the weights, right? Um, so what, what's going on here? And the, they talk about the intuition and I'll give it a little bit right now. Is it, there's this momentum term and the momentum is like, I'm, I'm sort of keeping track of how, where I was going before and making sure that I can continue in that direction, sort of.</p><p>Um, and I'm doing that so that like, if I have a, like a little valley, if you can imagine yourself being a ball rolling down a hill and you get into a little valley, then maybe you don't have enough. Um, then, then you end up like, you know, stuck in that valley.</p><p>But if you, if your ball is heavy enough, then maybe it'll roll up the other side and keep going down. Right. So that's sort of the intuition, why they call it momentum. And, and so what this is doing is saying rather than like a lot of my momentum going in this one direction and only a little in this direction.</p><p>I'm saying my momentum, I'm stretching that matrix and changing that so that it can kind of go in. The momentum can kind of go in equally in all these different directions that are defined by the data. Okay, that's very vague. I know, but like that's the intuition. Yeah, maybe I should stop here because that's like, I just said a lot.</p><p>Um, what do you, do you guys, um, is there, are there any questions in the chat or anyone wanna? Like sort of ask about this. Um, uh, okay. If not, I will continue. Um, so I, I'm actually gonna skip back and forth here. Cause I think that the, um, sort of, I will talk about that a little more.</p><p>So they actually have a, an interesting section here. Where is it? Um, where they validate this concept. So, um, so what, so this dynamics of singular spectrum. Okay. So, um, what they did was they, they, um, looked at, uh, so, okay. So there's a concept of entropy again. If you're not familiar with the math, um, that's fine.</p><p>What the entropy measures is the sort of like the amount of, of like variation. It's not quite variant. It's not variance, but it's the amount of, I mean, technically it's the amount of information. It's the amount of information in a distribution. But, um, if you can imagine, uh, you know, like a probability distribution, you have, uh, you could have like a really, really sharp distribution and it always picks one value.</p><p>And that would be very little information, right? Cause I always pick that value. So I know I can't express anything really with that. I can't even express a single bit of information. If I pick one of two values and I can express, you know, some more. And if I have a uniform distribution, then I can express lots of different values.</p><p>So those are, that's like higher entropy. So it's like a measure of the amount of information you can express and the sort of randomness of a data set. And so they, what they did was they sort of abused this, um, this, um, based on another paper, which I didn't read.</p><p>Um, but so you get this like entropy equation. And if you've seen entropy before, you'll recognize that this is basically just, this is my distribution. So I'm, I'm, uh, you know, sort of taking my eigenvalues. I'm, I'm squaring them and taking the, the sum of them so that it becomes a probability.</p><p>And then I take the log. And so it becomes an entropy, right? And so multiply by the log and it becomes an entropy. So what they're doing here is they're saying, you know, like sort of, if I have, um, uh, a lot of, uh, if my weight matrices have a lot of, um, you know, sort of like are, are pretty, um, spread out and flat.</p><p>Um, you know, if I'm tending to cause my weight matrices to be like sort of, um, quote unquote orthogonal so that I like have lots of different directions in them. Um, then, um, in the, in sort of like my rank is high then, uh, or, you know, sort of like the dimensionality of the embedding space, maybe is a better way to put that.</p><p>Um, then, um, then, you know, like I get a high entropy here. And so what they found was that compared to Adam, they do a lot. Um, they have like, where is it? Um, you know, uh, this right here. Um, so that basically there's, this is like empirical. They, so they had higher entropy in the, um, in the weight matrices than the, the equivalent models, uh, trained by Adam.</p><p>Um, and so what they're saying is that we were able to explore dimensions more effectively is sort of kind of sort of what, and so this is kind of the why, and this is like really fascinating to me. Um, is that like, and so that they talk about this a little bit more.</p><p>Um, let me find it. Um, let me find it. Right. Uh, right. Yeah. So, um, uh, sorry. Uh, um, they, they talk about this, you know, sort of like viewing, um, new on versus Adam is using different norm constraints, meaning they're sort of basically. Um, regularizing in a different way.</p><p>Um, and so, um, they're saying, whereas Adam is sort of, and so like, let me, and I think I have this right. So, you know, somebody knows better, please correct me. But what, what Adam kind of sorted is doing is I'm saying, I'm looking at these, these vectors. Kind of, or these dimensions that I'm taking the maximum, uh, size of that.</p><p>And I'm, I'm constraining my, my momentum by that. Whereas, uh, the, um, the muon optimizer is instead looking at the largest eigen value and constraining by that. Okay. So th that's sort of the fundamental difference. And, um, that makes sense because, um, it's not like, because things are happening in this eigen space, not in, in these like sort of dimensions, right?</p><p>Because they, you can rotate things around, um, in the embedding space. And so that it doesn't make sense to, um, constrain your optimization direction. Um, because you might have one direction that is really large because of all these different directions that are summing up. Okay. So that's a really mumbo jumbo explanation.</p><p>I can go into more. Um, uh, I can go into more, but I think I've probably talked about this much. Does anyone want to ask a question or should I move on? Okay. Um, okay. So I'm gonna, I wanna make sure that the other speakers have some time. So I'm gonna like sort of like brush over all this stuff and then we can, we can go into, uh, any detail either at the end or, uh, as you can interrupt me.</p><p>And I'm happy to, uh, I'm happy to, um, I'm going to details about these things. So, but like, okay, so what are the key things from this paper now that I've like made a half, half effective, maybe attempt to, uh, explain like the core concept here. So the, um, so I think that, yeah, good question.</p><p>The yikes, yikes has said in the chat, if you can repeat what Adam looks like versus this looking at the eigenvalue, like in the math, your interpretation of the math. Us comparing these. Oh, okay. So let's see. You, yikes, you wanted like this kind of explanation again. Sorry. Okay.</p><p>Yeah. So, so basically like, um, so my, and, uh, again, that, you know, some, some, hopefully somebody, um, who, who's, who's more knowledgeable can correct me if I'm misunderstanding. I, what it basically like each one of these vectors has a size, right? And if you look in, I'm not going to go into the math of why, but, um, effectively that the norm, the, the, the sort of constraint that Adam is using in effect is that the biggest one of these vectors, you're normalizing by this, the length of that vector.</p><p>Right. So you have a whole bunch of, you know, this D is in reality, like, you know, big. And so you have all these vectors and you're kind of normalizing by the biggest one of those. And so the problem with that is that it, you might have a, a direction in like, like you could rotate.</p><p>Um, so that you're, you're squishing in some direction that, uh, is a, you know, sort of combination of these different vectors. And that's, that would be like the, you know, the largest eigenvalue. Right. So, um, and, and so that what effectively you're doing with one is you're in this spectral, um, in spectrum space, which is like the eigen decomposition space.</p><p>You're, you're, you're, you're constraining the, the, the, the size of the jumps, the steps, the, the sort of strength of the momentum by the largest direction in eigen space instead. Right. So you've, you know, you sort of like, look at what are the principal components of this, um, of this, this, or the, sorry, the, the eigenvectors and looking at the size of those and looking at what is the largest eigenvalue and dividing by that basically kind of sort of normalizing via that.</p><p>Does that, does that make any sense? Okay. Um, I'm happy to like discuss this and I, you know, I think I have a reasonable grasp on it, but I may not. And so like happy to be corrected and happy to discuss this. And it's super fascinating to me and happy to discuss it in great detail.</p><p>Um, let me, let me just touch on all these other points and then we can talk about Kimi. I think that I don't want to take up all the time. Um, so like this weight decay, actually, I think I kind of, the way I kind of read it was.</p><p>So if you look at the difference between this weight update here and this one here, they're just, um, they're just adding this, um, Lambda W T minus one. And so that what they're saying is that, uh, I'm, I'm, uh, I can, I have a controllable parameter that allows me to subtract off some fraction of the weights every step.</p><p>So that my, um, so that like I tend to favor smaller weights, basically the same reason we do weight decay and all other algorithms. And it doesn't look any difference different there. And so that they have this algorithm and then, um, this is basically should be familiar if you've ever looked at, at weight decay before.</p><p>Um, and then, and then what, what they're saying here is that, um, the, the RMS norm that they use. And, um, is actually doesn't that you use in Adam doesn't work well for, um, one. And I think this is one of their primary contributions here. Was it in this paper?</p><p>Is it that, that, um, it's actually the, it depends on the shape of the matrix that you're. Um, what you're, um, you're, uh, um, you're normalizing around. So. Be so that this a B it's the max. So the, the, um, RMS is, is the max of these two things, or you can maybe I.</p><p>High rate, I highlighted the wrong place so that like when it's large, then you're dividing by a, you know, like the large dimension. And when it's small, then you're not, you're not normalizing enough. And so that you either get, you know, sort of like gradient, um, you know, you get explosions or, or, or, or, um, or your great vanishing gradients.</p><p>Um, if you're not careful. And I think that they hypothesize that this is one of the primary reasons why larger models were running into trouble. So, um, because of that, they, um, they had a few different mechanisms for, um, for updating. And, and they, they, they talked, they did some oblations down here, but, um, but I think they, they came up with just multiplying out like this.</p><p>Right. Right. So that, um, so now this one, this equation here has changed to this. So they're just adding, and they have this point to, to match what Adam does. Um, and then they, um, and I, you know, that's like a minor detail that probably don't care about, but, um, they, they, you know, so they do this normalization so that they can.</p><p>Um, so do regard it's they're now, uh, independent of the size of the matrix that they're doing the update on. And so this is one of the key things that allows them to be stable with larger training runs. Um, okay. And then what are, what are the other things?</p><p>So then they also like, and we kind of touched on this, the zero, um, and, um, you know, sort of. Um, you know, sort of Megatron LM, which is, uh, you know, like even more complicated, uh, parallel strategies. So they basically have a, an algorithm here that they describe.</p><p>I, I don't think that there's, um, a whole lot here. Um, but, you know, like you can go through it. It's just like, they just gather some more. They, they, you know, they've kind of changed how you do the updates to gather. Um, information. The one thing that I found was interesting was this line.</p><p>So they, they actually discard. They, they, so I think what they're saying is that on each node, they're actually calculating the, and they have to do like the entire. Uh, they have to calculate the entire momentum matrix and then only apply it to the parameters that they care about.</p><p>So this is a little bit, um, inefficient, but they, you know, they, they talk about how the, despite that inefficiency, they, um, because they're only using one momentum buffer instead of two that like, okay. From a space standpoint, that doesn't matter too much. The communication overhead, um, is like slightly higher, but, um, because like, as you scale, it matters less and less.</p><p>And then sort of like that they found that in practice that, um, you know, the sort of, uh, the end to end latency increase was pretty negligible. So, um, so like, and then finally, this was like evaluation of some different, um, strategies for doing consistent, um, update, um, in the weights or sorry, in the, uh, momentum term.</p><p>Um, they, like I said, they landed on this one. Um, you can read more detail if, if that's interesting. And then they, um, you know, they had some interesting, um, scaling laws here. You can see that. Um, you know, like sort of Adam does not surprise, or sorry, moon, not surprisingly does better.</p><p>And they fit. I didn't find their curve very convincing that this is actually the, the, um, the right fit, but, um, but, you know, I didn't. Whatever. It's clearly much better than Adam. So I'm willing to take it. Um, and then let's see what else. I'm sorry. This is so rush.</p><p>I really didn't have a time to prepare super well. Um, but, uh, oh yeah, this, this section. Um, I thought was really interesting as well. So this, I talked about the entropy measure that, um, is right here. I talked about that previously. Um, I think that this, um, this is a really interesting set of plots where, um, the, uh, um, the weight matrices, um, have, you know, throughout the, you know.</p><p>So we, if you look at Adam is red. Um, so this is Adam. And then one is the blue one. And, um, these are, uh, different parts of the, these, these here are different parts of the model. And different training iterations that like the entropy in the weight matrices is, you know, tends to be much higher, meaning that they're the weight matrices are expressing different.</p><p>Um, different things more effectively, um, than when you're trained by Adam different. So they're using the dimensionality of the weight matrices more effectively is I think the, the summary of that. Um, and one, so I'll, I'll, I'll conclude now. I think, but one like interesting thing that they, um, so they found.</p><p>So I found these two sections together quite interesting. Whoops. These two sections together quite interesting. So if you pre-train using Mulan, then like, like everything's better, basically. Kind of sort of. Um, and they talk about like different, like for, um, um, you know, sort of like pre-training plus fine tuning.</p><p>Oh, sorry. If you pre-train and fine tune using Mulan, they do better. Um, however, they found that if we take public models and we, they're obviously already pre-trained on whatever optimizer. They, um, do the fine tuning using, um, Adam, oops, sorry. Adam versus Adam versus Mulan. Adam does better.</p><p>Right. Consistently. And so, um, so that, that is one of the, um, that is one of the primary questions that they had. It was, why does it happen? So, and I don't think they had a, they don't really think they had a good explanation for that at all. Um, okay, so, um, yeah, so I, I think that's probably enough.</p><p>I want to make sure that other people have time to spend, but I, well, maybe we should, if there are any more questions, I'd be happy to answer those. And then I'll hand over the, the reins. Any, any questions? I know this was like really rushed and maybe not super intuitive.</p><p>Um, I apologize for that. Not at all. Like this is, uh, as, uh, as good as we can hope for, for, uh, explaining like this kind of optimize your work. Um, I, I, I think, um, I'm gotten had some commentary. Uh, Eugene has actually used more, um, either of them.</p><p>Um, it looks like I'm glad it's coming. Yes. Uh, can you hear me? Yeah. Okay. Cool. Yeah. I, I, I did, uh, some remarks about how the even scaled moment further in their training of gaming K2. I, I can share like the notes and kind of quickly go over them.</p><p>If there are no other questions. Yeah. This is the clip stuff. Yeah. Uh, yeah, I think, uh, RJ, you're gonna have to stop the share so that I'm going to do it or whatever. However, this works. Yeah. Okay. One. Give me one second. Let me figure that out. Uh, here we go.</p><p>Uh, yeah. Zach's is Matthew and Dan says, so I need to attend this. Um, I actually like thinking about like use this in terms of theory of learning. Um, so I think there's a lot of ways in which you can apply the algorithms to your own personal learning as well.</p><p>Um, so like the constant momentum to me is something that I tell people about a lot when you are wrong. And you are wrong. You should not only update to what you were wrong on, but also have momentum on further updating. Um, uh, I'm glad are you sharing your screen?</p><p>Um, I'm about to, uh, should be, should be visible now. Yeah. Cool. Yep. Yep. Yep. All visible. Uh, I'm, I'm glad. I don't know if you're speaking. He is not speaking. He has killed his voice. Okay. Someone else explain his. Okay. Okay. Is the screen visible now? Yeah. Yeah.</p><p>Yeah. Yeah. Yeah. Yeah. You're good. You're good. Yeah. You can go. Okay. Cool. Okay. Cool. Okay. Cool. Cool. So hi everyone. My name is Amgad. I'll, I'll be sharing some of the notes I took, uh, when researching the K2 model. Uh, most of this comes from the blog posts they published.</p><p>They said they will be, uh, sharing a very detailed technical report, but, you know, uh, we can never know. So I'll just go ahead and share whatever I know right now. So let's, let's start with this. Yeah. Yeah. So let's, let's start with the architecture. Uh, basically how they designed the model.</p><p>Uh, they had a few principles, uh, they needed to follow. Uh, and they did a lot of scaling experiments before the training even started. So there are a lot of scaling experiments, uh, a lot of the details that you can do, or a lot of the changes you can do to the architecture.</p><p>And they found out that every single detail, uh, every single change they made, it didn't improve the model at all. And sometimes it was just worse. So basically they decided to stick with deep seek v3 architecture instead of just changing for the sake of change. And I think this is a very good, uh, approach that we don't see a lot.</p><p>Like people want to try different stuff because they're just different without having any, uh, uh, justification for using them. So yeah, their, their answer was no, we should just use deep seek v3. And then maybe you can make some even further scaling on top of it rather than, uh, making new changes to the architecture because they already have a significant change, which is the optimizer.</p><p>They are now using Moan instead of Adam W, which is the industry standard. Uh, so they had a few constraints when, when, when trying to scale this up. Uh, the first constraint is it should be as close as possible to deep seek v3. The second constraint is the cost ceiling.</p><p>They are a small company and they don't have a lot of money. So they want to keep training and inference costs as low as possible. So, uh, they did a lot, they did a lot of experiments and they found that deep seek v3 is at the upper limit of what they can afford.</p><p>So K2 must be similar to deep seek v3 in terms of cost. Uh, so with these token constraints, they, they actually, uh, arrived at a conclusion that they should use the deep seek v3 skeleton and then find parameters that keep the training and inference, inference cost at the same, but this, uh, but while like reducing the loss significantly.</p><p>Um, so they made a few changes. We can go in over them now. The first change comes from something called the sparsity scaling law. This is a, an internal experiment or like an internal series of experiments that was done by their pre-training team. They found out that with fixed activate activate activated parameters.</p><p>If you increase the total, uh, parameters of a mixture of expert, it still obeys the scaling. Well, uh, there is no overfitting and the loss keeps going down. And this is internal research research that has not been published yet. So we just will take the words for it now for now.</p><p>So based on these observations, they decided to take an action to increase the total number of experts to 384 compared to, uh, what deep seek v3 is using, which is 256. The main issue with going with increasing the total model size is assuming that you have a fixed a fixed number of notes, a fixed number of GPUs.</p><p>Now each, each GPU, uh, is consuming more and more memory because you are having more, uh, total experts. So in the new k2, you have three experts per node. Plus the one shared expert, which consumes about 10 gigabyte compared to deep seek v3, which used two routed experts and one shared one and used, uh, 7.5 gigabytes.</p><p>So right now the, the model is consuming more memory. I think it's almost, uh, they say it's 50% more. Uh, I didn't double check the mess. So, so we can just take this for granted, but they are saying that now we have more memory consumed. We want to claw back this memory because memory is valuable and compute and bandwidth are like, uh, limited resources for them.</p><p>So they, they made the second change, which is reducing the number of attention heads. Uh, the deep seek v3 initially doubled the number of attention heads and they justified this because they said this maximizes the bandwidth utilization. Uh, so this is something that is a bit more specific to that deep, deep seek v3 infrastructure.</p><p>So the Kimi K2 authors, uh, decided to reduce the number of attention heads to 64. And this results in two main points. The first one we're cutting the head in half. So this meant, this means we're getting like huge wins for long context. And this is important for K2 because it's going to be used for agents and vibe coding and, and consuming tens of thousands of dollars.</p><p>Uh, to do vibe coding stuff. So this is quite important already. The second, uh, result is that the, the query and the key and the value on the output projection, but these parameters are reduced in half because we're using half the heads. So this goes down from 10 billion parameters to 5 billion.</p><p>So we are cutting the flops used, uh, in a significant portion again, and they have done a lot of ablations internally that show that the negative impact. impact on the loss by reducing the number of heads is quite minimal. And again, we will have to take them for, for granted on this.</p><p>The third change they made in the architecture is the, are no longer using expert grouping. Uh, so grouping helps when you have more than one expert on a GPU, uh, because this tends to balance the work at the device level. Uh, they said that they have a certain requirement for scaling and that they are actually using one expert or even less than one expert on each GPU, because the need to serve.</p><p>Many, many numbers of concurrent requests. So at the current scale, if you are having one expert per GPU, you don't need to group the experts because, uh, you're just routing to each node. So, uh, they said that we no longer need any expert, expert grouping. We can just use the, uh, router and give it more freedom.</p><p>And this allows them, allows them to explore more of the combinatorial space and, uh, arguably have better model quality. So these are like the main changes in architecture compared to deep seek V3. Uh, the summary is it is a sparse mixture of expert model. It has 1 trillion total, uh, parameters, sorry, not tokens, but only 32 of which are activated in each forward pass.</p><p>Uh, it is quite similar to the deep seek V3 on R1 architecture because it's basically an evolution of it. It it's using less attention heads, but has more total experts, uh, and it has a bigger vocabulary size. It's now using 160,000 tokens instead of 129,000, uh, tokens in the vocabulary.</p><p>And this is a nice, uh, graph comparing the two architectures by Sebastian Rojka. So please go, go and check this. I'll be sharing the notes, uh, and the dashboard server after the meeting. So this is regarding the architecture. Any questions before we cover, uh, some of the, uh, training approaches and, and other, uh, contributions?</p><p>Uh, can you guys even hear me? Can just, can just someone confirm that we're all good. Yeah, we can hear, we can hear. Uh, I do see one question in chat. Uh, I'm not able to digest how to find the best momentum and weight decay of the muon optimizer among different attention heads among all the Emily.</p><p>Um, maybe I can, I, I, if I understand that question correctly. Um, the momentum term is per the, the, the momentum matrix is there's a different momentum term per parameter kind of sorta. So you like each attention head and each expert will matrix will have its own momentum direction.</p><p>Does that make sense? So they like you, they're all calculated separately is kind of another way to put it. Is that answer the question? I'm not sure if it does or not. That was from Osama, I guess. Okay. Good. Awesome. Yeah. Sorry. I disconnected, uh, for a while. Um, no worries before disconnect.</p><p>Yeah. I answered the question anyway. Perfect. Okay. I was asking if like, there are any questions regarding the, uh, architecture, but I think we have no questions for no further questions. Right. Um, I actually do. Uh, I, I heard that it was, it was 1 trillion tokens and not 1 trillion parameters.</p><p>Um, okay. Oh, is it, so it's 1 trillion. Is it? Yeah. What, uh, how many tokens and how many parameters? Yeah. Uh, so the total number of parameters, though, their size, let me just correct this quickly. Uh, uh, the total number of parameters is 1 trillion, but only 32 are active.</p><p>And this is compared to deep seek V3, which has, I think 670 ish total, uh, parameters, but only 36 ish are active. Okay. So yeah, this is regarding the total size. So if you were to download this model on desk and assuming two bytes per, uh, token, you're gonna need like two, uh, terabytes.</p><p>I think of, of, of, of memory to just download it. Yeah. Yeah. I was, I was mostly wondering about the distinction between, between, uh, parameters and tokens, but it sounds like 15 trillion total tokens that it was trained on. And then one trillion parameters, uh, is what I'm, what I'm hearing.</p><p>Exactly. Yeah. All right. Cool. Sweet. Yes. Yeah. So yeah, this was regarding the architecture. Uh, we can now go into details about some of the motivations and the principles behind their approach to train this model. So they, they have two big, uh, principles. The first one is the agentic intelligence.</p><p>Uh, they believe that LLMs should be agentic and they should be intelligent. They should be able to use tools and intelligent way, uh, tools to write down summaries and, and like, uh, insert new information into memory and access MCP tools and all of this amazing agenting capabilities. And they also think that the model should be intelligent to know which tool to use and how to use the tool.</p><p>Uh, basically this principle comes from reinforcement learning and that to do a really good job at reinforcement learning, you need three components. You know, the, the algorithm, uh, and the environment and the priors. Uh, the main point is without good priors, the agent is just going to randomly guess what action to take, uh, when interacting with the environment.</p><p>And this was going to result in a low reward, uh, because you're just randomly guessing, uh, which, which tool should I use or which, which action should I dig. And you're not getting, gaining a lot of rewards and you're not improving. This is going to make the, uh, training, the, the training process of RL is going to be very, very hard.</p><p>It's going to take a lot of time because you're getting a very little or like very weak feedback signal. But in the last two years, the pre-training of large language models has made them, uh, almost universal models. They have, uh, great oral knowledge. They know a lot of stuff, a lot of, uh, about a lot of domains.</p><p>So the pre-training of modern LLMs is the crucial foundation for establishing the priors, uh, that are needed to develop strong RL models. Uh, we have one caveat though, is that the human data is a finite fossil fuel. Uh, this is a saying by Elia and that the data is, is, is like not catching up the, to the progress of computer.</p><p>We're getting more and more powerful GPUs every year, but the data is limited, at least the natural human data. So this means we need to be talking efficient and talking efficiency means given a fixed size dataset. How can we learn more, more, how can we develop more, uh, agenting model and like smarter models and, and more intelligent models given a fixed amount of data.</p><p>And we're going to give it like a quick hint that we should maybe look into better optimizers. Uh, so optimizers that can achieve a lower loss given a fixed size dataset. And obviously the, the ended up using monoclip, uh, that RJ, uh, explained in, in, uh, in a good way.</p><p>The second motivation or principle is the post training. So, uh, we're basically in the, what, what people call the era of experience. LLMs are increasingly learning from their own self generated interactions. They're not just relying on the data that we create, the instructions that we write for them on how to solve the problem.</p><p>They're actually learning from their attempted solutions at the problem. Uh, and there are like two examples of this. The first one is alpha proof. So this model was initially trained on like around a hundred thousand, uh, proofs written by human experts. But then it went on to generate around a hundred million more by interaction with the, or the environment and receiving rewards using a formal proving system.</p><p>This allowed the model to basically improve significantly and become way more capable compared to previous models. The second one is the tried and tested deep seek R1. It uses verifiable problems like coding and math. Uh, basically we give the model the problem and it makes a lot of attempts to solve the problem.</p><p>And we just judge or, uh, grade their solution. We can say, okay, you're getting close. You're getting not close. You're doing good. You're doing bad. And this allows the model to learn from its own solution without having to write detailed instructions of how to solve the problem. Actually. So given these two principles, they made a few contributions to achieve these goals.</p><p>The first one is demo on clip optimizer. Uh, basically how can we become more token efficient during training? Uh, so as, as RJ explained, Adam W has been the dominant optimization algorithm since 2014, 2015. And since then people have been trying nonstop to improve upon it. But, uh, I think it was only recently that we, uh, that like a more prominent approach was discovered by color Jordan.</p><p>Uh, basically demo on approach to train nano GPT to a SOTA level. Uh, so just want to give a quick overview of, of how one, uh, went on to one clip. So basically before even K2, the Moonshot team was working on something called moonlight, which was an attempt to scale more into an actual LLM.</p><p>A modern LLM because nano GPT was, I think a hundred million parameters. So they wanted to scale this to something that is 3 billion parameters or even more. And they successfully successfully demonstrated that you can actually scale the Moonshot optimizer into a modern LLM. And they train what they call moonlight, which is the model, uh, trained by the Moonshot optimizer.</p><p>Now they wanted to scale the, this algorithm even further into something the size of deep seek V3 or even more. Now we want to train our trillion parameter model. This is quite huge. So when, when the, when the, we're trying to train this new model with the algorithm, they ran into a few issues and they came up with clever solutions for it.</p><p>Uh, so they decided to reduce the number of heads for, for long context efficiency. I think increased the sparsity, but they encountered that. a lot of training instability due to mainly exploding attention logits. And this, uh, occurred more frequently with Moons than the Adam W. So, uh, this is a big problem.</p><p>They tried it. They tried some of the existing solutions like, uh, soft capping the logits and normalizing the query key parameters, but they didn't, uh, help a lot. So they, they offered a clever way to rescale the query and, and, uh, key parameters. They call it the QK clip technique.</p><p>Basically it tries to stabilize the training by rescaling the weight metric, uh, matrices of the query and the key projection after the updates. We can take a look at the math here. So after we have the inputs and multiply them by the weight metrics, we scale it by a certain factor for the query.</p><p>And we also scale it by a similar factor for the key. Uh, if you multiply these both together, you're going to get, uh, the query multiplied by the key and both of them are now scaled by a factor. And they, they, this scaling factor, uh, it's called an adaptive factor.</p><p>I think this, this simple is, is eta. Uh, basically it has a, a way to calculate it by using the maximum attention logit in the previous step. I'm not going to go into details about the math. Uh, you can take a look at the equations and try to understand the intuition by a bit, but basically they're trying to have a soft capping on the.</p><p>uh, values of the query multiplied by the key. And they obviously did a lot of training and, uh, training experiments. And they showed that one clip can effectively prevent the explosions while maintaining the, uh, downstream task performance. And this is, I think the highlight of the Kimi Q2 model.</p><p>They show us the loss curve while training the model. So this very big model was trained on 15 trillion tokens. So this is a massive training run. And they use long clip. And they say that the didn't encounter any, any training spike. And this demonstrates that one clip can be stable and robust for training state of the art, uh, large language models.</p><p>And even more, you can notice a second dip in, in loss at around 11 trillion tokens. And this is quite awesome. Um, so yeah, the first, uh, contribution by the team is scaling more one by developing more on clip and training the model on 15 trillion tokens in a stable and robust way.</p><p>Uh, I had a question, um, with regards to the, um, uh, the soft cap logits, uh, technique that they addressed. Is that, uh, what's the relationship to that with soft max or are they the, essentially the same thing? Are they describing the same operation? I don't, no, I don't think it's related to soft max.</p><p>I think they're just trying to, uh, put a limit on, on the value of the query. And key because they noticed that during the training, the, the, the value of multiplying query and key kept going up and up and up. And this exceeded the, the range that can be represented by BF 16, uh, values.</p><p>I don't think it's related to soft max. It's just like a way for them to, uh, control the values without explosion. I think. Okay, cool. Yeah. Good. Thank you. Okay. Okay. So yeah, this was their first contribution, the mon clip, uh, which allowed them to do a very successful pre-training run.</p><p>The other contributions are related to the RL side of things. And they did two contributions. The first one is they generated a large scale agentic data, agentic synthetic data set. So basically how do we teach the model sophisticated tool, tool use capabilities? And they, their approach was to develop a very comprehensive pipeline that generates synthetic data to train the model.</p><p>So they start by, uh, evolving hundreds of domains with thousands of tools and evolving here comes, I think from the evolve instruct algorithm by the wizard LMT. So you're trying to create more and more domains and trying to make them more complex, uh, starting with a, I think fixed seed of domains.</p><p>And then once you have these domains, you can generate hundreds of agents with diverse tool sets, and then you can create a simulated environment and user agents to interact with these agents. And I, I think user agents mean here means just an agent that acts as a user. So submitting queries and questions.</p><p>And then they use tasks that are rubric based, basically tasks that are easy to gauge or easy to judge. And they use this to, uh, basically judge and evaluate the generated data set. And then they start the simulations. They run multi turn toolier scenarios with their agents, uh, interacting with the environment and the user agents.</p><p>And then they use LLM as a judge to evaluate the results and then use this, uh, judgment by the LLM to filter for high quality training data. Uh, this is on Instagram from their blog posts as well. So basically you start with a list of domains that have been evolved.</p><p>You evolve the domains to generate tools, and then maybe use some MCP tools and then give these tools to agents, which interacts with, uh, user agents. And the environment. And then you have these tasks that you can evaluate easily, uh, and then use the LLM as a judge to filter and continue the generation and evolve more and more.</p><p>So this is quite an, uh, highly attractive loop that allows you to generate high quality data. So basically eval driven training, I think, or I should say eval driven, uh, synthetic data generation. Uh, so this is the first approach regarding reinforcement learning. The second one is general reinforcement learning.</p><p>The second one is general reinforcement learning. So we already have RL for, for verifiable tasks. Uh, thanks to deep seek R1. They basically trained the model on code and math where the model, uh, generates a solution. And then they, uh, run unit tests or, uh, evaluate the math solution and use this as a signal to the model.</p><p>Now the key challenge is how can we expand RL into other types of tasks? Uh, especially the ones that are not easily verifiable. Examples of verifiable tasks are like math and competition coding. While writing a research board or a summarization is viewed as a non-verifiable. So they created a general RL system using a self judge mechanism.</p><p>Basically they use the model to act as its own critic, uh, providing scalable rubric based feedback for non-verifiable tasks. And one cool, uh, detail here is that they use the on policy rollout, uh, with verifiable rewards to continuously update the critic. So basically we have some tasks that are verifiable.</p><p>They can use. You can track the performance of the model on these verifiable rewards and see if you're actually, if the model is still going better and better. And this makes sure that the critic model keeps improving, uh, its evaluation accuracy. So this can be viewed as a way of using verifiable rewards to improve the estimation of non-verifiable rewards.</p><p>And these are like the three main contributions by the team. Uh, the first one is the mon clip optimizer to allow them to train up to 15 trillion tokens and achieve, uh, lower loss while having the training being stable and robust. And the second one is synthetic data generation for tool use.</p><p>And the third one is to generalize the RL into non-verifiable rewards. Uh, so I think that's, that's all I have to share. Uh, this is all the information extracted from the blog post. Just one fun fact here regarding the mon optimizer. Uh, this is Keller Jordan, the main author behind the optimizer.</p><p>And he said, when he was interviewing with open AI and XI, the XAI team told him that they don't think the idea of developing Moan is going to work. Uh, so I think, yeah, sometimes you, you're like, you get rejected until you can prove that the algorithm scales. Um, these are like some references.</p><p>I used the blog post and the tweet of Sebastian Ruschka and the translation of one of the engineers about the reasoning for developing for modifying the architecture of the model. So, yeah, that's, that's all I have to share with you guys. If, if anyone has any questions, please go ahead.</p><p>Um, yeah, I asked it in chat, but, uh, they mentioned that they have the, the, the sort of, uh, self-judging RL framework. Did they, did they like release the code for that anywhere or, um, uh, was it just like something you found in a blog? Uh, I don't think they shared anything besides the weights and the inference code, uh, unfortunately.</p><p>So yeah, this is just inferred from the blog. Sure. I think we had, that's it for time. Amazing. We actually covered Kimmy. I didn't, I just put it in there because I was like, maybe there's not enough on, on just move on. Um, fun facts. Kimmy is now powering all the LLM responses inside of the discord.</p><p>And so whenever you enter, you see a summary from, um, yikes is bought it's, it's Kimmy. Cause Gemini is. Yeah. He's on free tier on open router. So figure we give her a shot. Yeah. Yeah. Yeah. Yeah. I think we have a thread on the discord server about which providers are, are serving Kimmy key to.</p><p>Yeah. I mean, you know, it's given that it's free tier, so we're not using any tokens. We might as well just like enable that bot to chat more. Um, cause right now it only summarizes links, but, uh, it's pretty useful. Yeah. You can add her like she'll, she'll talk.</p><p>I'll see. I'll double check. See if she's got, um, I don't know if she's got, I think I should be able to, I'll double, I'll double check her chat model, but yeah, you can add her and she'll chat. Yeah. Cool. All right. Okay. Uh, lots of people need to go.</p><p>I need to go. Uh, thank you everyone. Thanks. I'm glad. Um, yeah. People want your, uh, your write up. Yeah. I'll share it in the discord server. I mean, like a few minutes. Okay. Bye everyone. Thank you so much. Thanks RJ. Okay.</p></div></div></body></html>