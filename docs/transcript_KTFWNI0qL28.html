<html><head><title>6 of Python's Newest and Best Features (3.7-3.9)</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 80%;
        margin: auto;
        overflow: hidden;
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>6 of Python's Newest and Best Features (3.7-3.9)</h2><a href="https://www.youtube.com/watch?v=KTFWNI0qL28" target="_blank"><img src="https://i.ytimg.com/vi/KTFWNI0qL28/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=KTFWNI0qL28&t=0 target="_blank"">0:0</a> Intro<br><a href="https://www.youtube.com/watch?v=KTFWNI0qL28&t=35 target="_blank"">0:35</a> Breakpoint<br><a href="https://www.youtube.com/watch?v=KTFWNI0qL28&t=117 target="_blank"">1:57</a> Walrus Operator<br><a href="https://www.youtube.com/watch?v=KTFWNI0qL28&t=388 target="_blank"">6:28</a> Sign specifier<br><a href="https://www.youtube.com/watch?v=KTFWNI0qL28&t=463 target="_blank"">7:43</a> Positional parameters<br><a href="https://www.youtube.com/watch?v=KTFWNI0qL28&t=656 target="_blank"">10:56</a> Type hinting<br><a href="https://www.youtube.com/watch?v=KTFWNI0qL28&t=986 target="_blank"">16:26</a> Dictionary unions<br><h3>Transcript</h3><div class='max-width'><p>Hi and welcome to this video, we're going to go through and take a look at some of the coolest, more interesting features that have been added into Python in the past few years. So we'll just go straight into it and code a few examples as well. Okay so the first one and the only example we're going to look at from Python 3.7 is the addition of breakpoints. So obviously a breakpoint is where we typically click on the left side of our editor to add in the little red circle, which means we want the code to break at this point. What the breakpoint function allows us to do is actually use Python debuggers within our code. So the function uses the bdb debugger by default but we can also use other alternatives as well. So for example if we had a list of functions here, a list of print statements. Okay so they just print out "hello". If we for whatever reason wanted to put in a breakpoint to try and figure out what was going wrong, say this code was probably a little more complicated, we could add in this. Okay and then we go straight into the Python bdb debugger at the bottom here and this is essentially like a interactive shell where we can just write Python and figure out what is going on. So obviously there's not really much for us to figure out in this case but when you're actually writing more complex functions or classes or modules in your code this can be really really useful. So here we can print or do anything. It's simply an interactive Python debugger window. So the second of our new features actually comes from Python 3.8. Now this is the walrus operator which was the go-to for the majority of 2019 for anyone covering what is new in Python 3.8. So it's a new operator added to Python. It's genuinely very useful. It essentially allows us to assign a value to a variable on the fly. So it looks like this which looks like a walrus hence the name and we can use it to write more compact code. So say we have a list here and we want to assign the length of this list to a variable which we'll call t_length and then we want to write an if statement checking if t_length is greater than 3. And if so we want to print out the length t_length and a little statement saying that this is greater than 3. That's great. With the walrus operator we can actually make this more compact and include our variable assignment within the if statement. So we put this within a bracket and then we change our equal sign here to a walrus operator and we can run that again and now we have four is greater than three. So then we've shortened our code made it more compact. Obviously you know whether this is useful and more readable is completely up to who is writing the code. Nonetheless it's a very useful operator to understand and use. So a more realistic use case for this could be if we are writing a regex statement. So I'll just write out a sentence here quickly. Okay so we want this sentence to go through and use regex to find a currency followed by a few numbers. So I'll just switch this to dollars here. So we're going to go through each of these sentences and only print out the ones that contain a currency. We also need to import re for regex. Now for those of you that use regex a fair bit before you'll know that when we use a regex search it will return either none or return a set of groups which contain our matches and typically what we'd have to do is we'd have to write amount equals re.search and then we would have our regex in here. So here I'm just going to do a lookup. So this is just checking for a dollar symbol before a set of digits and this will return just digits not the dollar symbol. Okay and usually you would have to do this and then we would have to write if amount or just if amount is true and then print out the amount and the group which would be zero and then we would get our results. This should be sentences. Okay so we get 100 but what we can do instead is use our walrus operator. If amount and now we've shortened our code. So that's more probably a more useful example of using the walrus operator. Another really cool feature that was added in 3.8 is the fstring equal sign specifier. So I'll give a quick example. So we have these two variables it's just two numbers and maybe we are trying to figure out maybe we're doing something wrong and we want to see where our values are going and what variables are being assigned to and what we might typically do is this. We might write x equals x and y equals y. Okay and this is probably what a lot of us would do but rather than doing this we can actually just write x equals like this and this will print out the same thing. So it shows the variable name and the value within it. So it's a smaller but I think very useful addition to Python. Okay so the final feature from Python 3.8 is the inclusion of syntax to specify the input parameters the functions that cannot be called by name but instead by the position. So what I mean by that is if we have this function here we can either write this which is using the position of the parameters in order to fill in those variables or we can also do this and we'll get the exact same output. Now this is great but when you're writing code that other people are using and relying on and maybe that code isn't completely finished yet you may find that you are not entirely sure if you'll keep this variable or input parameter as op or this is x or this is y you might change these around and if people are using your code like this that will cause problems when you do change your code to use different variable names. So maybe at a later point you decide you would change your code to use method instead of op. If we took that and then tried to use this function again we'd get this type error. Obviously we don't want that so what we can do instead is define method as a positional only parameter and we do that by adding this slash. So now if we try to run this but with operator again we see okay we have a type error count got some positional only arguments passes keyword arguments. So although we haven't changed operator to method yet we are preventing the user from using op here. So that forces the user to use this instead. Now the user can still define these using their names that's completely fine but they cannot use anything that comes before this slash. So if we do rewrite our function to use method instead of op and the user runs their code that they've been using before we won't get any errors because we've prevented the user from being able to use this keyword parameter. Okay so that's everything for Python 3.8 and we're going to move on to Python 3.9. Now the main one of those is the addition of more type hinting. So type hinting is something that has been around for a while and it seems to be a recurring theme with every Python update that we will get some new type hinting functionality. For Python 3.9 they've essentially merged all the different type hinting features that they've been adding over time and brought them into the core Python functionality. So there's no more importing typing modules or annotation modules just works as it is for the most part. So for those of you that don't know what typing is in Python say we have this function here it's quite clear that this function add_int shouldn't be used with strings. Okay but it can be used because we're just using a plus here so it's essentially telling Python to concatenate these two strings but our intention is actually to only allow integers. So what we can do is add a type annotation or a type hint and that's what this is here. So we add this colon followed by the data type that we intend this value to be. Then we return a plus vowel. Now when you are writing this code out in your editor and you have your Python linter so pylint for example it will come up with an error if you write something like this later on. And this isn't an error that will stop your code. We can still run it. It is just a hint, it is a warning. Okay you can't see it here because we're in Jupyter but in a normal editor with pylint installed you will see this bit here get highlighted with a note saying we expected type type int got string instead. Okay so that's the warning that will pop up. Now this is just very useful for complex code bases where you're not entirely sure what values are supposed to be going in and out of different functions and classes. Just makes things a lot easier to follow. Another syntax addition in terms of the type hinting that was added is the ability to define the type that should be coming out of a function not just into a function. Say here we want to sum up all the values within a dictionary. We want to input a dictionary and what we would expect to get out of this which is defined by this little arrow syntax here as an integer. Then we just return the sum of the values within our dictionary. Then we define our dictionary here and we can also add the type here as well. Then we call our function and we should get a integer out of that as expected. Now if we change this and these were the other way around and we had strings instead of numbers here we would obviously get a full-blown error but before we even ran that we would see a type hint come up saying okay we are expecting a integer here not a string. So it can be very useful and just in terms of readability it can depending on how you do this be very very useful. If you look into complex libraries like you have the TensorFlow library or Transformers library those libraries with type hints can make things a lot easier. In fact some of the more recently written code in the Transformers library has been using type hinting and it makes it so much easier to read. So it's a very good addition to Python in my opinion. Now something that is very useful if we take this function again we can actually use more complex types. So we know that we want a dictionary but maybe you want to define what is within that dictionary as well. So we can actually do that like this. So now we know that our dictionary should be built of string keys and integer values and this is just an extra layer of detail so we can be more specific. There we go. Now the final feature in Python 3.9 that we'll go over is dictionary unions operators. There's quite an interesting addition to the syntax and it gives us two new operators. One is called the merge operator and the other is the update operator. So the merge operator looks like this and we use it to merge two dictionaries. So let's write out two dictionaries quickly. Okay so we have these two dictionaries and we can merge them using our merge operator. Okay and now we can see that those two dictionaries are now one within our new variable C. The update operator is slightly different in that it allows us to do the merge in place. So what that means is rather than adding this to a new variable C, we actually assign it to the variable on the left of the statement and this here is the update operator. Now if we print A we see that we get the same function. Okay so that's it for this video covering some of the biggest changes and upgrades to Python that we actually see and use on a daily basis. But that's it for this video, I hope you've enjoyed and as always thank you for watching, bye!</p></div></div></body></html>