<html><head><title>Bjarne Stroustrup: Learn More than One Programming Language</title></head><body><a href="index.html">back to index</a><h2>Bjarne Stroustrup: Learn More than One Programming Language</h2><a href="https://www.youtube.com/watch?v=5An1sNznblQ"><img src="https://i.ytimg.com/vi_webp/5An1sNznblQ/maxresdefault.webp" style="width:50%;"></a><div><br></div><div style="text-align: left;"><a href="./5An1sNznblQ.html">Whisper Transcript</a> | <a href="./transcript_5An1sNznblQ.html">Transcript Only Page</a></div><br><h3>Transcript</h3><div style="max-width: 600px;"><p>You've said that it's good for any professional programmer to know at least five languages, speaking about a variety of languages that you've taken inspiration from. And you've listed yours as being, at least at the time, C++, obviously, Java, Python, Ruby, and JavaScript. Can you, first of all, update that list, modify it? You don't have to be constrained to just five, but can you describe what you picked up also from each of these languages? How you see them as inspirations for even you working with C++? This is a very hard question to answer. So about languages, you should know languages. I reckon I knew about 25 or thereabouts when I did C++. It was easier in those days because the languages were smaller and you didn't have to learn a whole programming environment and such to do it. You could learn the language quite easily. And it's good to learn so many languages. I imagine just like with natural language for communication, there's different paradigms that emerge in all of them. That there's commonalities and so on. So I picked five out of a hat. You picked five out of a hat. Obviously. The important thing that the number is not one. That's right. It's like, I don't like, I mean, if you're a monoglot, you are likely to think that your own culture is the only ones, periods, for everybody else's. A good learning of a foreign language and a foreign culture is important. It helps you think and be a better person. With programming languages, you become a better programmer, better designer with the second language. Now, once you've got two, the way to five is not that long. It's the second one that's most important. And then when I had to pick five, I sort of thinking what kinds of languages are there. Well, there's a really low level stuff. It's good. It's actually good to know machine code. Even still, sorry to interrupt. Even today. Even today. The C++ optimizers write better machine code than I do. Yes. But I don't think I could appreciate them if I actually didn't understand machine code and machine architecture. At least in my position, I have to understand a bit of it because you mess up the cache and you're off in performance by a factor of 100. Right? It shouldn't be that if you are interested in either performance or the size of the computer you have to deploy. So I would go as a simpler. I used to mention C, but these days going low level is not actually what gives you the performance. It is to express your ideas so cleanly that you can think about it and the optimizer can understand what you're up to. My favorite way of optimizing these days is throw out the clever bits and see if it still runs fast. And sometimes it runs faster. So I need the abstraction mechanisms or something like C++ to write compact high performance code. There was a beautiful keynote by Jason Turner at the CPP Con a couple of years ago where he decided he was going to program Pong on Motorola 6800 I think it was. And he says, well, this is relevant because it looks like a microcontroller. It has specialized hardware. It has not very much memory and it's relatively slow. And so he shows in real time how he writes Pong starting with fairly straightforward low level stuff, improving his abstractions. And what he's doing, he's writing C++ and it translates into 86 assembler, which you can do with Clang and you can see it in real time. It's the compiler explorer, which you can use on the web. And then he wrote a little program that translated 86 assembler into Motorola assembler. And so he types and you can see this thing in real time. You can see it in real time. And even if you can't read the assembly code, you can just see it. His code gets better. The code, the assembler gets smaller. He increases the abstraction level, uses C++ 11 as it were better. His code gets cleaner, it gets easier to maintain, the code shrinks and it keeps shrinking. And I could not in any reasonable amount of time, write that assembler as good as the compiler generated from really quite nice modern C++. And I'll go as far as to say that the thing that looked like C was significantly uglier and smaller when it became and larger when it became machine code. So the abstractions that can be optimized are important. I would love to see that kind of visualization in larger code bases. Yeah. That might be beautiful. But you can't show a larger code base in a one hour talk and have it fit on screen. Right. So that's C and C++. So my two languages would be machine code and C++. And then I think you can learn a lot from the functional languages. So PIC has GloyML. I don't care which. I think actually you learn the same lessons of expressing especially mathematical notions really clearly and having a type system that's really strict. And then you should probably have a language for sort of quickly churning out something. You could pick JavaScript. You could pick Python. You could pick Ruby.</p></div></body></html>