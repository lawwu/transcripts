<html><head><title>Stanford CS25: V5 I The Advent of AGI, Div Garg</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>Stanford CS25: V5 I The Advent of AGI, Div Garg</h2><a href="https://www.youtube.com/watch?v=nEHNwdrbfGA" target="_blank"><img src="https://i.ytimg.com/vi/nEHNwdrbfGA/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>Today we have our co-instructor, Div, talking about human-inspired approaches to agents and how the path to AGI requires a rethinking of how we design, evaluate, and deploy intelligence. Div Garg is the founder and CEO of AGI Inc., a new applied AI lab redefining AI-human interaction with the mission to bring AGI into everyday life.</p><p>Div previously founded Multion, the first AI agent startup, developing agents that can interact with computers and assist with everyday tasks, funded by top Silicon Valley VCs. Div has spent his career at the intersection of AI, research, and startups, and was previously a CS PhD student here at Stanford, focused on RL.</p><p>His work spans across various high-impact areas, ranging from self-driving cars, robotics, computer control, and Minecraft AI agents. With that, I'll hand it to him to take it away. Yes, excited to be here. Great. So, yeah, excited to be here. And the topic for this lecture is we wanted to talk about a lot of new things that are happening in the AI world right now.</p><p>So, there's been a lot of developments with agents and all the new models that are coming out. And it seems like you have, like, some sort of superintelligence when it comes to, like, chat and reasoning already there, compared to, like, average humans. And it's going to be very interesting, like, over the next few years as we figure out what does intelligence look like?</p><p>What is the, like, what is, like, something like AGI? And what's the form factor? How can this be something that's useful? And, like, how will this be applied in society? Cool. So, let's say the first thing, like, we want to touch on. Like, what does AGI look like? It's, like, AGI is such an abstract concept right now.</p><p>It's, like, no one has, like, visualized it or given it a meaning. It's, like, is it some sort of supercomputer? Is it just, like, chat CPT but just, like, 10x better? Is it something that's more of a personal companion? Is it something that's embedded in your life? And, like, that's not clear yet.</p><p>And, like, those are, like, kind of the questions I think we really need to go and figure out. This is one diagram on how AI agents work. So, this is architecture from an open AI researcher, Lillian Wang. She recently left and joined a new company. So, this is showing how you can think about agents and, like, how they can be broken down into, like, different, like, subparts.</p><p>And there's a lot of different things that you require to make these agents work. So, the first layer is memory. You need to have, like, some sort of short-term memory. You want to have some sort of long-term memory. And this is, like, you have some sort of short-term presentation that's maybe, like, a chat window, if you're using something like chat GPT.</p><p>And you might also have, like, a personal history of the user. Where, like, okay, this is maybe, like, what the user likes. This is what they don't like. The second thing that you need is tools. Like, you want this kind of agent to be able to use tools like how humans use tools.</p><p>So, you want them to be able to use calculators. You want them to be able to use, like, calendars, web search, coding, and so on. The third part over here is, like, you want to have advanced planning. And that means, like, you want to, the agents to be able to, like, use reflection where, like, if something goes wrong, they can, like, have failover mechanisms, error correct, and, like, recover, you want, like, self-criticism, and you want, like, decomposition where, like, you have, like, chains of thoughts so that agent can do, like, their own reasoning loops.</p><p>They can also break down a complex task into sub-goals. And the final, fourth ingredient is actions, where, like, you want these agents to go to act on your behalf and, like, go do things. And this is kind of, like, high-level encapsulates, like, how agents look like fundamentally. And this is maybe, like, what will, like, as this system's become more powerful over time, will eventually lead to something that's like AGI.</p><p>This is one thing that we're also building. So I recently started this new AI lab called AGI Inc. And we're looking a lot into, like, what does AGI look like for everyday purposes and, like, how can this be applied to daily life? This is one of the demos of some technologies we built in the past.</p><p>This shows how an AI agent can be applied in the real world. So this is a bit old. And this shows, like, how an AI agent can be applied to pass a real driving test in California. And so this is, like, an actual DMV test that the agent took.</p><p>And then let me share the screen and talk about the setup. So in this screen, what's happening is there's someone attempting the DMV online test. And there's a human who has their hands over the keyboard. They're not actually touching the screen. And it's the agent that's going and taking all the exams.</p><p>And there's, like, 40 questions in this test. And the agent's really good. So it can go and, like, pass the whole thing. And we did this live. So the DMV was actually, like, screen recording what we were doing. They were also, like, watching, like, the person on camera. But even then, like, the agent was successfully able to evade, like, the whole setup and, like, pass the exam.</p><p>So this was really fun. We did this as a teching attempt. So we informed the DMV afterwards that we did this. Funnily enough, they actually sent us a driving license afterwards. So that was really fun, actually. So at the end, the agent's able to pass and get a pass, get a full score on this test here.</p><p>And so, yeah. So this is, like, a very fun experiment showing, like, how agents can be applied in the real world. And, like, there's so many things that are possible. In this vein, like, how can we make agents more useful, apply them in real life? We've been, like, working on a lot of, like, different efforts along with a lot of, like, the AI community.</p><p>One of those things is, like, agent evaluations. How can we evaluate this kind of agents in the real world? And make sure, like, we have standards and benchmarks that allows us to know, okay, like, how well are these agents working on, like, different websites or different use cases? How can we trust them?</p><p>How can we know, okay, like, where to deploy them and how to use them? Another thing we have been doing is agent training. Can we train agents to be able to do advanced planning, self-correction, and improve themselves? And this uses the combination of, like, reinforcement learning and a bunch of other advanced techniques.</p><p>And, finally, we have also been looking a lot into, like, agent communication. Like, how can you have agent communicate with other agents? And there's been a lot of, like, new breakthroughs in this area recently. So if you've looked at model context protocol, MCP, that's a very new thing that has been coming out.</p><p>Similarly, like, there's a lot of work around, like, A2A, that's, like, Google's agent-to-agent communication protocol that recently came out. We also have been working on some, like, open source projects called agent protocol, where you also, we have been allowing other different kind of agents to communicate to each other.</p><p>So you can have a coding agent that can talk to, like, a web agent that can talk to, like, an API-based agent and so on. And that allows you to, like, do, like, much, much more complex things than what's possible with just a single agent. Cool. So before we dive more deeper into, like, how a lot of these things works, I want to bring out, like, why do we need agents?</p><p>Like, why are they useful? Why do we actually want to go and build them? And there's a lot of things we need to think about here. And I will touch on a lot of different topics in the introduction, going from, like, the architectures, building, like, more, like, human-like agents, using computer interactions, maybe, like, memory, communication, and, like, what are the future actions?</p><p>So, like, when you think about building agents, there's a lot of things, or questions you have to answer. The first one is, okay, like, why is this useful? How can you actually build them? What are the different building blocks? And finally, what can you do with them? And to first answer the why question, we have this key thesis that agents will be more efficient in interfacing with computers in the digital world compared to humans.</p><p>And that's the reason that we want to go and apply agents to be able to, like, do things for us. So, you can imagine you have an army of virtual assistants that are, like, fully digital that can go and, like, do whatever you want on your behalf. And you can just talk to them using a human interface.</p><p>And that's kind of the vision we have been, like, moving towards. I also have a blog post about this called SoftFit 3.0 that you can check out, which touches on some of the ideas. Cool. So, if you want to go and build agents, because usually, like, large language models are not good enough.</p><p>And we want, like, action capabilities that allows us to unlock more productivity and go do things. And this also allows us to build more complex systems. There's a lot of techniques involved in actually building this, such as, like, chaining different models together, reflection, and a bunch of other mechanisms.</p><p>And, as I showed before, in the architecture, on slide two, there's a lot of, like, different components, like memory, actions, personalization, access to the internet, and so on. And finally, the question becomes, like, what are the different applications you can apply them to? There's also a question of why do we want to build human-like agents?</p><p>Like, why can't we just have API agents? Or why can't we have a bunch of, like, other kind of agents you can imagine, which are not mimicking human interactions? And one reason we want to push towards more human-like agents is these agents can operate interfaces, like how we do.</p><p>And usually, the internet and the web and computers are designed for humans. So, they're designed for, like, keyboard and mouse interactions, so that we can go and, like, navigate interfaces. We can, like, use our keyboards. And if agents are able to, like, use interfaces like we do, that allows them to, like, directly communicate and, like, do a lot of things without changing how current software programs work.</p><p>And that becomes very, very effective because that allows you to, like, work on the 100% of the internet without any sort of bottlenecks. If you think about APIs, there's only, like, 5% of APIs on the internet are public that are accessible. And it's very hard to build agents that are fully reliable over APIs.</p><p>And so, there's, like, a lot of contention between, like, human-like agents versus API agents. And that's, like, an ongoing battle that's happening right now. Second thing is, you can imagine a lot of human-like agents as becoming a digital extension of you. So, they can learn about you. They can have a context about you.</p><p>They can do tasks, like, how you will do it. They also have less restrictive boundaries. This kind of human-like agents can handle logins. They can handle payments. And they're able to interact with any of the services without restrictions on terms of API access. So, you don't need to pay for, like, using an API, or you don't need to, like, go to, like, a service provider and ask them for, like, can you give me access to this API?</p><p>You can just go and use an interface, how, like, you normally do. And the final thing is, like, there's a very simple action space. These agents only need to learn how to click and type. And if they're able to do that very effectively, they can generalize to any sort of interface.</p><p>And they can also improve over time. So, the more you teach them, the more data you can give them. They can learn from, like, user recordings, feedback, and become better and better over time. And so, when it comes to this API versus more direct computer-controlled agents, this is kind of, like, how we think about, like, the pros and cons.</p><p>Like, API agents are usually easier to build. They are more controllable. They are more safer. But APIs are more, have a higher variability. So, you have to build, like, different agents for each API. And then, APIs can keep changing. You never have, like, a full guarantee that this agent will always work 100%.</p><p>When it comes to this more direct interaction computer-controlled agents, they are, it's easier to take actions in this case. It's also more free-form interactions. Because you're not restricted by the API boundaries. But it's also hard to provide guarantees. Because you don't know what the agent will do. So, if anyone here has played with, like, agents like operator, it's a work in progress.</p><p>It's not, like, clearly there. There's a lot of, like, issues that it turns into. And that's kind of the boundaries where, like, agents are right now. There's also, like, different levels of autonomy when you think about agents. This usually goes from level 1 to level 5. So, level 1 to level 2 is when a human is in control.</p><p>And the agent is acting like a copilot. So, it's helping the human. So, this is something, like, if you're using, like, a code editor, like cursor. That's a L2 agent where you have partial automation where the human is in control. The human is directing the code. But the agent is helping them.</p><p>When it comes to, like, something like L3, this is where there's still a human fallback mechanism. But the agent is in control. So, this is, like, if you use, like, cursor composer or windsurf or any of the newer code editors that are more agentic. The agent is directing most of the code.</p><p>But a human is monitoring, giving it feedback. Okay, this went wrong. Can you correct that for me? Can you fix this issue? And that is, like, more of a L3 system. And then you have more advanced systems, which are, like, L4 and L5. In L4 systems, you don't have a human in the loop.</p><p>So, it's the agent that's going and doing everything. You might still have some sort of, like, automated fallback layers. So, if you look at Waymo in SF, that's an L4 system because the self-driving car is driving itself. But there's, like, human operators that are remotely monitoring it, making sure, like, nothing goes wrong.</p><p>And when you have an L5 system, in that case, there's no humans in the loop. There's no monitoring. And the AI agent is able to operate itself autonomously, fully, fully independently. So, when we are building these agents, one hard thing is trust. How do we trust these agents are actually going to go do what we want them to do?</p><p>How can we go and deploy them in the real world? To solve these issues, one effort that we have been building is a miniature version of the internet, where we have cloned, like, the top 20 websites on the internet. And we are benchmarking, like, how do agents go and perform on all these interfaces.</p><p>This is actually live, so you can go check it out on reallywells.xyc. And what we have done is we have built, like, digital clones of websites like Airbnb and Amazon and DoorDash and LinkedIn. And the agents can go and navigate these interfaces on predefined tasks, and you can get a final score.</p><p>This is showing the evaluation results for GPT-4.0. We find that GPT-4.0 actually is not very good when it comes to being agentic. And it only reaches 14% successful accuracy, in this case. We tried this on, like, 11 different environments that we are showing on the right. And that's, we have our different environments.</p><p>We have DashDash, which is our DoorDash clone, and OmniZone, and so on. So you can actually go and check this environment out. We also compare a lot of, like, open source frameworks out there. Some of them are, like, the open AI computer use model that's powering operator. We actually find it's not very good when it comes to these tasks.</p><p>So it's only able to reach maximum 20% accuracy on some of the environments, like our email environment or our calendar environments. But on a lot of the other environments, it's not able to actually go and do really well. We also tried a bunch of other frameworks out there. StageHand, if you've seen that, it's an open source framework for automating web agents, browser use, and one of our own custom agents, which we are calling Agent0.</p><p>And we find, like, agents are still, like, early when it comes to, like, actually automating a lot of these interfaces. And we are able to reach, maybe, like, I would say, like, up to 50% success rate. But a lot of the agents are actually failing when you are applying them in a lot of these real-world websites.</p><p>Similarly, we benchmark all the different models that are available, including all the closed source APIs and all the open source models. And we find, again, on AT&T tasks, most models are doing, like, decently well, but no one is, like, really, really good right now. The maximum success we have seen is with, like, GLOD 3.7, where it can reach around 40% accuracy.</p><p>Gemini 2.5 and O3 follow very closely with it. The other models, like, tend to taper off. And so the interesting learning has been for us is that a lot of these models are not fully ready to be deployed in the real world. Because if you have, say, like, an agent that's powered by GLOD and then you're applying that, you can only expect a 41% success rate that this will actually go and do what you want it to do.</p><p>And that's not good enough. And this brings the question, okay, like, what is it that is required to make this agency even better? How can they, like, improve and how can they be applied for your actual practical use cases? And so this brings us to our next topic for the lecture, which is, like, how can we train AI agentic models?</p><p>So how can we have models that are more custom-fine-tuned and are better on this agentic tasks? This is one of our past works called Agent Q, which is a self-improving agent system. So how can we train AI agent? This is a self-improving agent. This is a self-improving agent. This is a self-improving agent.</p><p>This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent.</p><p>This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent.</p><p>This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. This is a self-improving agent. So, this is agent queue. That's a system that can self-improving.</p><p>It can learn by corrections and planning. How the system works is it's able to go and self-correct itself. So, whenever it makes a mistake, it can save that mistake in its past memory, and it's able to use that to do a lot of like trial and error learning similar to humans.</p><p>So, suppose the first time you learn how to ride a bike, you make a lot of mistakes, you fall over a lot of times, but over time you're able to improve your policy and go and do that really well. We apply similar mechanisms to make this agents actually work really, really well in the real world.</p><p>So, what's happening in the system is the agent can explore the space of interfaces and see, look like what are the things that it did that went wrong? What are the things that went right? And it's able to use reinforcement learning to self-improve and become better and better. So, agent queue combines a lot of different techniques.</p><p>The first method is Monte Carlo research. This is borrowed from other RL techniques like AlphaGo, that allow you to plan over search space of tasks, and unlock advanced reasoning. A second thing that we do is self-critic mechanisms. So, the agent can self-verify and get feedback whenever it makes a mistake and it's able to learn from that feedback.</p><p>And finally, we use RL AIF techniques like DPO, direct preference optimization to be able to improve the agent using RL. and by combining all these three techniques together, we are able to build some very powerful systems. Agent queue is also available on archive as a research paper, so you can go and check it out.</p><p>So, for the sake of time, I will skip some of the lectures here. But how agent queue normally works is we have this Monte Carlo tree search, where the agent is exploring the different states. It's estimating like rewards on, okay, if we were to visit like this state, what's the expected value of the future predicted reward.</p><p>And based on that, it's able to improve its prediction model, like should we go take this path or a different path in the tree? And then over time, the agent can become very good at exploring the right states, and figuring out what are the right paths in the state space and what are the wrong ones.</p><p>we also do like self-critic magnetism. In this case, what happens is if you have a particular task in this case, where like say a user says like book me a reservation for a restaurant, for the chow on open table for two people on August 14, 2024 at 7:00 PM.</p><p>And like this is the current like state of the screen where you can see the screenshot. Then the agent can go and propose a bunch of different actions. So you can choose to go and select the date and time. It can choose to also like select the number of people and then open the date selector.</p><p>It can instead search for Terra Italy, Silicon Valley restaurant and type that in the search bar. or it can maybe like decide to go to the open table homepage. And how the self-critic mechanism works is like all these proposed actions are passed to a critic network. And the critic LLM is able to go and predict like, okay, what's the best action to take?</p><p>And it's able to give a ranking order. Okay, like this is the best action that we should go and use. So this is like rank one, this is rank two, and it's rank three. And based on that, we can go and optimize the system to take the correct actions and improve over time.</p><p>And finally, we use like reinforcement learning from human feedback, where we used methods like GRPO and TPO, which are different RL algorithms, to be able to like use all the failures and like successful trajectories you've collected so far, and improve the agent over them. And so DPO is a special technique based on RLHF, where you can train LLM using preference data sort of like failures and successes, and use that to improve the model overall.</p><p>And so this is how Agent Q works, where we create this Monte Carlo tree search to create like trajectories of successes and failures. We can then use self-critic mechanisms to identify what are the proposed actions that actually succeeded and failed. And then we are able to pass them through DPO to actually go and optimize the network.</p><p>we can then use that to help. And then we can do that for example. So this is an example of how this works. So the agent starts in like the first state and the task in this case is we want to go and book a restaurant reservation on OpenTable.</p><p>So first, it makes a mistake and goes to the homepage. Then it recognizes that we made a mistake and can backtrack. So the blue arrow here shows that it's going and backtracking. Then it can go and navigate to the restaurant. In this case, if the agent accidentally makes a mistake and choose the incorrect date, then it can again backtrack, recover back, open the date selector, choose the right date.</p><p>Open the seat selection, and then finally come to the reservation. And so this is kind of how the system is learning over time. It's making a lot of mistakes, but it's saving the mistakes and over time improving on them. So we tried Agent Q in a lot of real-world scenarios, including like OpenTable actual reservations.</p><p>So we actually spun up thousands of, or I would say like more like hundred thousands of bots that ran on OpenTable and like used our method to like create agents that are able to book restaurants and like make reservations and do a bunch of other things. And we tried this with a lot of different methods and models out there.</p><p>So we tried GPT-40 and then we found like on this OpenTable reservation tasks. We are only able to reach around 62.6 percent accuracies. When it comes to something like DPO, the accuracies actually go to something like 71 percent. When we try Agent Q, we are able to like make this work much, much better.</p><p>So we are able to reach 81 percent accuracy without any MCTS as part of the method. And when we apply the whole technique with MCTS and DPO and like the self-critic mechanisms, we are actually able to reach close to 95.4 percent accuracies. And this is using a lot like self-learning for the agent to improve itself.</p><p>This takes usually less than one day of training for the agent to go from, I would say here, like 20 percent accuracy. That's 18.6, that's roughly 20 percent, all the way to 95.4. So that's a 4X improvement in like agent performance in less than one day. Cool. As the next topic, I'll touch on memory and personalization.</p><p>So one way to think about AI agents is that they are taking information, processing them, and I think, and- So imagine like you have an AI model. What an AI model is doing, it's taking some like prompts. So it's taking some like language tokens and outputting like some new language tokens.</p><p>And so this is acting like similar to a processor, where you, if you have a CPU, what happens is you have some instructions, which are usually binary encoded, that go into the CPU. And then you have some like instructions that come out, which are also binary encoded. And then you do a loop over them again and again.</p><p>And that's how like normal computers work. You can do a very similar thing and have this abstraction of AI model as acting similar to a computer, where you have language tokens that are going in, that are encoded in the prompt. And you have like language tokens coming out. And this allows you to think about like an AI model as being a processor that's operating over natural language.</p><p>So this is something that you can think about GPT-4, for example, going and doing this. This is similar to some of the older processor like MIPS 32 that use 32-bit instructions. Right now if you look at GPT-4, we are able to reach like very big context lens. So that's very interesting.</p><p>And when like GPT-4 initially came out, it was constrained to like 8K tokens. Now we have 32K tokens and 128K tokens and like 1 million tokens. So the context length of this model is just increasing and increasing over time. And as the context length increases, that also allows us to have...</p><p>A question from online. Can you speak to the compute budget for the day long run? Like was it H100s or like a cluster? The results? Yes, yes, yes, yes. So that was all H100s actually. We trained the whole models on 50 H100s in less than one day. Gotcha. And then one question from before.</p><p>As AI agents increasingly emulate human behavior, what protocols do you foresee being implemented to help users distinguish between AI and humans in conversation? Yeah, that's very interesting. I think that becomes a question of security, of how can we identify whether it's a human or an agent. It's actually a very hard question right now because you actually have voice agents that are effectively able to mimic humans and are able to pass as humans.</p><p>And that's actually happening in the real world right now. Over time we will need like human proof of identity. So this could be like biometrics. This could also be a combination of maybe like some sort of like personal data or like some sort of like password or secrets that only you know.</p><p>And you can use that to authenticate that you're talking to an actual human and not an agent. Cool. Any more questions? Yeah. So, you know Berkeley just published a paper by professors, students written a paper saying, "Why do multi-agent systems fail?" Right. So, they did some comprehensive study. First of all, they said MIS has been there for more than 20 years, right?</p><p>You have distributed systems, the transition processing. So, we are just having AI covered by the same name. And so, so far I really haven't seen anything new except for you have an agent which instead of just having API people coding all the logic in the program, you have an agent will be able to do something.</p><p>Mm-hmm. You're given a prompt and will give you some results, right? How can, you just putting all agents together, the intelligence suddenly elevate it? So, communicating between agents, my point is just for communication between agents is exactly the same as MIS before, 20 years ago. I think collaboration between agents is only being equal to any of the intelligence.</p><p>But I'm missing that part today in the lecture. All right. This is actually something that's coming next. But just to answer your question, the biggest issue is just to elaborate. And what happens is when all these agents are communicating using natural language, that causes a lot of miscommunication. Where like, okay, maybe your agent got the wrong instruction or failed to understand what's happening.</p><p>And the more agents you add, the more communication overhead is there. So, you can imagine if you have an agentic system with n different agents, then there's n squared communication groups. And so, like, the amount of error in that system increases, like, as quadratic. And that makes, that allows for, like, a lot of different mistakes that can happen.</p><p>I think I'm suggesting you to do a textbook called MACI, M-A-C-I. They've all, pretty much all the problems solved. 15 chapters of the book. Great. Yeah, totally. Yeah, that could be very interesting also for the audience here. So, let's come back to this. So, one way to think about agents is when you have this transform model.</p><p>The transform model is acting as this processor. So, it's taking in this input prompts, and it's giving out the output prompts. And what you want to do is you want to be able to, like, have a memory system. So, you want to have something like a file disk called RAM, where you are saving what's happening.</p><p>And being able to process that over time. And being able to process that over time. So, you want to have repeated operations. So, you do the first pass over a model. You get some output tokens. You can save them in a RAM-like system. And then you have, like, some, like, new instructions that come out.</p><p>Okay, like, now, here's step two of the plan. Go execute that. Here's step three of the plan. Here's step four of the plan. And that looping behavior, this is what's, in a sense, giving rise to, like, agents. You can imagine this is, the transformer is the processor. The memory system and the instructions and the planning are acting similar to the file system and the RAM.</p><p>And so, they are overall, like, giving rise to this computer architecture. Where you have the agent acting as, like, a computer system. With the memory processors, which is the compute. And then, being able to use, like, browsers and actions and multi-modality. Which can be, like, inputs like audio and voice and so on.</p><p>Okay. When we think about long-term memory, there's, based on the analogy before. You can think of this as similar to a disk. Where you want a user memory that's long-lived and persistent. And so, that you can, like, save context about the user. You can, like, load that on the fly whenever you want to.</p><p>There's different mechanisms for long-term memories. The prevalent one is embeddings. So, you have retrieval models that can go and fetch the right user embeddings on the fly. So, if I have a question, like, okay, like, does this person, Joe, is he allergic to peanuts? Then, can the system go and find out?</p><p>And if we have a lot of user data about the user, then we can use a retrieval model to do, like, embedding lookup. Find out, okay, like, if this is something that we already know about the user or not. And based on that, make a right judgment. And this is something that is very important.</p><p>And you are able to see early traces of this in systems like chat GPT right now. There's still a lot of open questions when it comes to long-term memory. The first one is hierarchy. How do we decompose memory into, like, more graphical structures where you can have temporal persistence.</p><p>You can have more structures. And you might also want to think about memory as something that is adaptable. Because human memory is usually not static. It's changing over time. And so, you also want to think about when you have agent memory. How can it change? How can it be dynamic?</p><p>How can it self-adjust? Because the systems are also learning. They're improving. And what does this dynamic memory systems look like? Cool. And with memory, like, leads to personalization. Where the goal with having long-term memory is that you can personalize these agents to the user. And they're able to understand what you like, what you don't like.</p><p>And they're aligned with their preferences. So, if you have this case of, like, maybe someone is allergic to peanuts. And you want to have an agent that's ordering food on DoorDash. Then you want it to be personalized. So, it doesn't accidentally order something that you're allergic to. And how can you go and build that?</p><p>And everyone has different preferences, likes and dislikes. So, when you're designing agents, it's very important to actually make sure that you can account for this. So, there might be a lot of explicit personalization information that you can collect. Like, what is the user like? Are they allergic to something?</p><p>What are their favorite dishes? What seat preferences they have, if they're flying, and so on. There's also a lot of implicit preferences. So, there's a lot of things around, like, which brand do you like? Do you like Adidas versus Nike? If there were, like, ten items on a list, like, suppose you're looking for, like, a housing.</p><p>Which one do you prefer and why? And those things are very implicit. So, they're not explicitly known. And then, there are mechanisms where you can collect a lot of this implicit preferences. And then, personalize over time. There's a lot of challenges when you're building these personalization systems. The first one is just user privacy and trust.</p><p>How do you actually go and actively collect this information? And how do you get people to give that to you? There's different methods you can go and use to actually collect this information. So, one is just actively active learning. But you're explicitly asking the user for their preferences. You're asking them, okay, like, are you allergic to something?</p><p>Or do you have the seat preference? And so on. And there might also be, like, passive learning. Where the, if you can, like, record the users and see what they're doing. Then you're able to passively learn from their preferences. Maybe this person likes Nike shoes. Because, like, that's where, what we have seen them do on the computer.</p><p>And the agent is learning from your behavior and become better and better. And you can learn to personalize by supervised fine tuning. Where you are collecting a lot of interactions. This can also be through human feedback. Where you can get thumbs up or thumbs down. And use that to, like, improve.</p><p>Okay, like, this agent go and do the right thing. And this is something similar to ChatJPT. Where if you like the chat outputs, then you can give it a thumbs up. If you don't like it, you give it a thumbs down. And then this can be used to, like, personalize the system over time.</p><p>Okay, so now I'm going to agent to agent communication. One question online. How do you do evaluations on the performance of agents that collaborate with humans? And is it a moving target? At what point is human performance redundant? And agents can be fully autonomous? I would say it's a hard question.</p><p>You just have to go and build benchmarks. Because it's very hard to know what's going to happen in the real world. Right now, I would say, like, based on, like, a lot of, like, current state of evaluations. And, like, what I showed before. Like, agents are not fully there.</p><p>The most successful agents we have seen so far are coding agents. So, if you have your, whatever, like, intelligent code editor. And you can already see the traces. Like, they are automating a lot of engineering for you already. That you don't have to go and write a lot of boilerplate code.</p><p>Or you don't have to, like, spend a lot of your own time fixing bugs. So, at some point, we'll see this thing where, like, humans become more, like, managers. And we are giving them feedback. We are giving them direction. Okay, like, we want this, like, suppose you have, like, systems of different agents.</p><p>So, giving them, okay, like, I want agent one to go and do this, agent to go and do this. So, on. See what the final output is. And over using that, improve the overall, like, the generation process that you are going towards. And so, this is likely what's going to happen is, like, the agentic systems will become better and better executors.</p><p>Where, like, the humans become the managers for the systems of agents. Okay. Cool. So, when it comes to agent to agent communication, we think about, like, multi-agent architectures and multi-agent systems. Where you have all this, like, cute little, like, digital robots that can go and talk to each other, communicate, and, like, go do your work in a very coordinated and streamlined manner.</p><p>There's reasons that you want to go and build multi-agent systems. The first one is parallelization. By dividing a task into smaller chunks and having, like, multiple agents, like, if you have any agents instead of one agent, you can improve the overall, like, speeds and efficiencies. The second thing is specialization.</p><p>If you have, like, different specialized agents. So, you have maybe, like, a spreadsheet agent, and you have a Slack agent, and you have a web browser agent. Then you can also route different tasks to different agents. Each agent can become really, really good at their tasks. And this is similar to, like, having, like, a degree in a specific major or having an occupation, especially in that occupation.</p><p>There's a lot of challenges when it comes to agent-agent communication. The biggest one is that this kind of communication is lossy. When you have one agent communicating to another agent, it's possible that it might make mistakes. So, like, it's, like, this is similar to what happens in human organizations.</p><p>Maybe your manager will ask you to go do something, but you maybe misunderstood them, and, like, did something different, or they were, like, oh, like, what does happen? And similarly, like, agent-to-agent communication is also fundamentally lossy, where, like, whenever you are communicating information from one agent to another, you're losing some percentage of that information.</p><p>And that allows for mistakes to, like, propagate in that system and become, like, increasingly more prevalent. Yeah. And there's different mechanisms for multi-agent system. This is a very novel field right now. Like, people are still trying to figure this out. No one has actually cracked this right now. What you want to do is you want to, like, build the right system of hierarchies, where, like, you might have manager agents that are working with, like, worker agents.</p><p>You might have managers of manager agents, and you might have, like, maybe, like, flat agent organizations where, like, maybe, like, one manager is managing hundreds of agents. Or it could be, like, a big, like, vertical tree where you have, like, maybe, like, ten different hierarchies of agents that are managing each other.</p><p>And so, a lot of these systems are possible. And this just depends on the task of what you're going and specializing on. And the biggest challenge with this kind of systems is, like, how do you exchange communication effectively without losing that information? How do you build syncing primitives? Like, how can communication from one agent that's very far away from the, maybe, like, another agent in the hierarchy come go and, like, be communicated very, very effectively across the chain?</p><p>There's a couple of frameworks out there that are looking to solve these problems on how do we make this communication protocols robust? And how can we add mechanisms to reduce this miscommunication? A big one in this part is MCP, which is model context protocol. This is a protocol that came from Anthropic that a lot of people are using right now.</p><p>It's a simple wrapper on APIs. So, what it does is it gives you, like, a streamlined standard format around each API. And by creating an MCP wrapper around your service. So, this could maybe, like, you have a file server service that's, like, exposed as an API. You can create, like, an MCP wrapper for your file server or maybe for your email client or for your maybe a Slack client or something running on your computer.</p><p>Then all these MCP-connected servers can go and communicate with each other and, like, do things for you. And so, this allows for very effective communication where you are able to control the routing and, like, make decisions modular. So, you're able to plug in, like, new services as you want to.</p><p>Similarly, another framework in this space is agent-to-agent protocol. So, this is a new protocol that came from Google very recently. That's aligned for agents to also communicate with other agents and add a lot of reliability and fallback mechanisms. And I'm not sure how many people here in the room have used MCPs.</p><p>Okay. Yeah, not many. Okay. Okay. Cool. So, MCPs are actually very cool. Like, what they are doing is they are abstracting your APIs and making them, like, very, very modular, so that you can go and plug your API into an MCP protocol. And once it's wrapped around that, then you can go and, like, interconnect it to any other service that's supported by MCPs.</p><p>So, it's kind of becomes, in a sense, like, having a center interface for communication for your different services or applications you have, and exposing them and, like, letting them connect and talk to each other. So, similar to, like, how you have something like HTTPS for communication on the normal internet, MCP becomes, like, an interesting protocol for communication to happen over different agents.</p><p>And, yeah. So, if you have, like, a client, like, cloud or replet or some other model, you can connect that to servers that are supporting the MCP protocol. You can have, like, a bunch of, like, different services. Each services could be, like, some sort of data tool, like a database, API, or pretty much else.</p><p>And they can all interconnect and, like, do, like, modular things for you. And because MCPs are not dependent on the spec of your API, they can allow you to absorb a lot of changes and add this level of modularity and abstraction by standardizing the whole interface. You can also have, like, dynamic tool discovery because you can find different MCP servers that are exposed in some sort of directories.</p><p>And then you can also, like, plug in MCP servers that you like and, like, connect to them. So, you can plug in new tools, let them out. And you can route information based on, like, what you want to do. Okay. Finally, like, touching on, like, some of the issues when it comes to agent systems.</p><p>So, so far we have seen a lot of different things. Okay, like, how can these agents work? How can we evaluate them? How can we train them? How can we think about communicating with different agent systems? And even though a lot of these things are very interesting, a lot of these things are taking off, there remains a lot of, like, key problems in the space that you still have to solve for this agency to be practical, for them to be applied in everyday life, and for them to become useful for you.</p><p>The biggest one is just reliability, that the systems have to become very, very reliable. Like, they need to be close to 99.9% reliable if you're giving them access to your payments and your bank details, for example, or maybe they're connected to your emails, calendars, and whatever services. And then you want to really trust them, that you don't want the systems to go rogue and maybe, like, post something wrong for you on socials, on your Twitter, or your LinkedIn, or you don't want them to go and create an havoc or make a wrong transaction on your behalf.</p><p>And so that becomes, like, how can you trust an agentic system that's operating autonomously? And that's where, like, reliability becomes a big thing. Second issue with autonomous agents is looping. Like, this agent can go do something wrong. So they can get stuck in a loop, and they might just go and repeat that process again and again.</p><p>So if you give them a task, and, like, maybe, like, if you remember, like, the restaurant booking task that I showed before, and, like, maybe, like, the agent went to the wrong restaurant, and got stuck, and maybe just trying to do the same thing again and again, and doesn't know what to do.</p><p>And that kind of issues can happen a lot of the agents where you might end up wasting a lot of money in compute. And it's very important to be able to, like, figure that out and correct that. And that leads to a lot of use cases around, like, how can we test agents?</p><p>How can we properly benchmark them in the real world on a lot of, like, different use cases and make sure, like, we are learning from that? And how can we also, once we deploy the systems, be able to, like, observe them? And that becomes, like, how can we know what is happening?</p><p>Can we monitor them online? Can we have some sort of, like, safety, which could be based on audit trails that we can audit all the operations that this agent has done so far? And we can maybe also have human overrides. But if something goes wrong, we have some sort of human fallback where maybe, like, a remote operator can take control of the agent and correct it and fix it.</p><p>Or maybe you are able to go and, like, actually take control and fix it. This is similar to, like, autopilot in Tesla. So, when you're driving autopilot, maybe, like, you see, like, something, maybe it's going to go do something wrong and you can take control and override the system.</p><p>And that becomes very interesting when you're thinking about real world deployment of agents. Cool. Okay. So, that was, yeah. So, that was the whole lecture on agents. Sorry, there was, like, some things that were a bit messy. Yeah, we had to put together some, like, final slides. So, happy to take questions.</p><p>And, yeah, go on. So, when you see, like, an accuracy, say, like, here. So, this is one. Yeah. So, when you see an accuracy of, say, like, 40% or something on a task over the course of a day, do you think that there is a plan to get to, you know, like, P9 or F9.99?</p><p>And do you have a thought of just, is that just iterations on research? Or is there actually a lot of things that you need to try? So, I would say, like, this is definitely possible, especially with, like, reinforcement learning and, like, like, I showed the agent queue method before.</p><p>So, right now, a lot of these models, like, even if you have, like, Claude Sonnet or GPT-40, GPT-40 or Gemini, they're not trained on this agentic interfaces tasks. So, that's why, like, they're kind of, they're working zero short. So, they're not, never trained in their distribution training set on actually going and optimizing these problems.</p><p>And so, when they encounter this, like, new interfaces or this kind of new tasks in the real world, they often fail. But if you're able to, like, train the systems directly to work on this task using reinforcement learning and, like, corrections and, like, self-improvement, then you can actually reach, like, very, very high accuracies.</p><p>So, in the open table task with agent queue, we reach, like, 95% accuracies. And if you keep going and training the systems, you can, like, fully saturate them, like, reach close to, like, 99.9%. The hard thing becomes is there's a diversity of tasks. So, I can imagine there's, like, millions of websites.</p><p>And if you want to train an agent that's usually 99.9% on each website. That's a hard challenge. And that's something that's very interesting. Like, how can you build a generalized agent that can work on the whole internet that can generalize to everything? Maybe in the future, you will have agents that can do, like, automate all of voice calling, all of, like, computer control.</p><p>Maybe, like, they can also use all of the APIs and everything. And something like that is possible theoretically. It's just, like, very hard to build up. Do you know whether AI agents are able to solve CAPTCHAs? They can. What do you think the implications of that are for, like, how the internet's going to work in the next 10 years?</p><p>It's definitely very interesting. I would say it's a cat and mouse game. So, if you have seen, like, the new generation of CAPTCHAs, they're becoming harder and harder to solve. And I think, like, it's very hard to beat this because, like, if a human can do it theoretically, like, an agent can also go and do the same thing.</p><p>So, over time, I think we'll have to just figure out, like, a better method. of identity. Biometrics can be a big part of that. Like, if you are able to use fingerprints or some sort of 2FA mechanisms, then we know, like, this is an actual human, not an agent.</p><p>So, in the -- there's this article called AI 2027 that you've probably heard of that, you know, outlined, you know, like, where AI research is going to go and what might happen. And in 2027, after 27, when, you know, AI, we automate programming and then we automate AI research.</p><p>And, you know, after your lecture, I was wondering, do you think we could automate the process of creating AI agents? Because, from what I understand, the main bottleneck is how am I going to access UIs, APIs? How am I going to be able to access data that is enclosed in those, like, I guess, complex and somewhat dynamic systems?</p><p>So, what if, very simply, someone designed an agent that could -- that was optimized to vectorize APIs and UIs, and then you designed an agent that was optimized to train agents on different vectorized data sets? Because they're, like, specific architectures that you can use to train agents, whatever. Do you think we will see in the future people automating, with confidence, our process of creating AI agents, making all these niche-specific AI agents that we're seeing on the market obsolete?</p><p>Yeah, absolutely. I absolutely think so. So, this is going to happen. And I think it's already happening in the bigger labs. So, if you have, like, labs like OpenAI, they have a lot of research agents. There's also, like, papers from, like, if you've seen from Sakana AI, people are working on, like, AI research agents that can go and write research papers and, like, train models and do a bunch of things.</p><p>So, it's certainly possible for agents to go and self-improve and, like, build other agents and, like, you can have a whole process on, like, how that can happen. And definitely, like, it's possible to, like, train on a lot of these, like, data sources and APIs and find ways to, like, represent them and, like, collect the right sets of data and improve that.</p><p>I do think that seems to be the future of a lot of, like, maybe hard research, especially around, like, protein designs and, like, a lot of, like, hard sciences. So, we'll definitely see a lot of that happen. Hi, Garg. Nice to meet you again. Just to give you context, we're building, like, the Slack for AI agents.</p><p>Basically, it's, like, Uber for AI agents. So, I've been working for agents for a long time. The biggest problem with agents has been, as you said, reliability and hallucination. The first thing is, the first thing we try to work on is how do we prevent agent prevention from hallucinating?</p><p>The next thing is, what models we're best at executing actions? So, for my research, we realized that Claude is great. Right. Better still, we have GPT at the end. So, we have, like, just like Slack, so we have, like, a team of agents doing work. And then, the one that does the action seems to be GPT agent because we struggle with some agents doing, as you said, GPT 4.0 is great at, you know, taking action.</p><p>And other models of GPT seem to not work well and Claude and other stuff. So, I think the biggest challenge with building agents is also the third one is the fact that end users can't take one hit. So, my wife here doesn't give, like, if I give out to Tel's the product and it makes one mistake, there's no space for reinforcement learning.</p><p>In the sense that, if I say, book my flight, like I told Manos to do yesterday, and I made one mistake, I lost trust. So, the problem is, to work in the real world, our agents should prevent making mistakes in the real world. So, that brings us to Sandbox, which I love what you're doing with Sandbox and doing clones of this website.</p><p>The challenge with Sandbox is you can't clone all the websites on the internet. And where human excel is, the fact that, if given a new task, they figure their way around. So, these are challenges that we have with agents, and I'm happy if we can talk more about it or we can talk about it later.</p><p>Totally, totally. Just to get a gist of it, what's the exact question there? So, I think the question is, how do we make them ready for the real world? We have a body, which does a good job with calling, but makes mistakes. We have an email agent, my own, that got stopped in a loop and sent an email five times to an investor.</p><p>We have a coding agent that wiped up 3,000 lines of code from me yesterday. I had to redo it. So, we have these challenges in the real world, and people like my wife are not going to take one shot and they will just stop using it. So, I think the question is, how do we prevent agent from hallucinating?</p><p>Right. Yeah, so it's definitely a hard problem where you can go and keep improving these agents. Even if you look at maybe a lot of the initial models that came out, like when you had the first versions of GPT-3 and so on, they hallucinate a lot. But as you have bigger models that are more parameter size and they train on more data, they start hallucinating less.</p><p>So, if you see the new generation models, GPT-4 and Claude, I think over time, I think as you figure out how to make better foundation models, a lot of these errors in the systems go down, especially hallucinations and other things that can happen. You just require a lot of monitoring and evaluations and a lot of testing.</p><p>And this also becomes very domain-specific. So, if you're working on something that's a domain-specific problem, and you're like, okay, you want an agent that can work 99.9% on this domain, then what you want to do is you want to get the right test cases. You can be like, okay, here's 1,000 scenarios that we really need to go and care about.</p><p>Can we go and test these agents on these 1,000 scenarios all the time, which could be in production when you're actually running this with your users? Or this could be some sort of offline simulation where you're daily testing, is there any regressions in the system? What happens if you change a prompt?</p><p>What will this look like? And if you're able to build a lot of very robust testing, then you can also verify, okay, your accuracies are going up. And then it kind of becomes like, can you fine-tune these agents to become better and better for your use cases? So, I think I would say the correct answer is a combination of models will become better and better over time.</p><p>So, you can just implicitly trust them more as the new model comes out. And the second thing becomes is just you want to have very domain-specific testing and evaluation. So, for your own use case, can you go and have some sort of ways to rank which model is doing what?</p><p>How good is it? And make the right judgment and be able to fine-tune and use reinforcement learning and other techniques to make them better over time. What do you think about smaller language model? Right. Right. Smaller model? Right. Thank you. I think the problem is large language models. I don't think we need bigger brains.</p><p>We just need smaller. So, playing the way more smaller language models. Yeah, so that's an interesting question. Also, we are already seeing some hints of this. So, if you look at a lot of the newer models, they're trained on reasoning traces. And we have found like you can actually train smaller models on reasoning traces and have like better accuracies.</p><p>things. So, a lot of the newer like GPT-4 models like all the GPT-4-0 and like all the new series of like O3 mini and so on. They're actually distilled small models. But they're just like fine-tuned and using reinforcement learning other techniques to be very good at reasoning. And so, we are already seeing that with all the new generation of like all the thinking models that are coming out and all the O1 and O3 series.</p><p>So, that's showing this that smaller models with better reasoning, better processing is actually the right answer. It will be interesting to see like how far can you push the limits? And like what will this look like? It's like maybe like over this year, what are the best accuracies we can expect from this kind of reasoning things?</p><p>Can we actually go and be like PhD level at mathematics and like even like super intelligence on a lot of these specific domains? Okay. I think the lead process is reward. And my approach architecture which I think may work is the manager, you know, manager agent could be large language model.</p><p>Then the worker agent could be small language models. Because I think there's distillation happening when you're collaborating in like a team. Yeah. Yeah. What the last question is regarding memory. What would the analogy give with respect to a computer? We have random access memory. We have the room and then we have the, you know, hard drive, right?</p><p>With AI agents right now, I just think they have random access memory. And with map zero, we are just giving it room. I don't think they have the hard drive on this, the consciousness, right? Why they are working. I think that's a challenge. I would like to know how do we implement that kind of system to make it sort of like a computer?</p><p>Yeah. That's an interesting question. Like I'll be curious if you actually try and experiment and like see how that works. Like I'll say there's no straight answer to this. It just depends on what you're building, what your applications are. And then just depending on what you're doing, like there can be different size of models that might work better.</p><p>If you're doing a coding task, you might want like a more of a coding model versus like if you're doing something more chat based or actions and so on. And I think you just have to like find the right ingredients in a sense like the right components for your application and then go and build that.</p><p>Yeah, so there's no right answer to it in a sense. Yeah. Thank you.</p></div></div></body></html>