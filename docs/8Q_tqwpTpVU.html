<html><head><title>Mamba and S4 Explained: Architecture, Parallel Scan, Kernel Fusion, Recurrent, Convolution, Math</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">back to index</a><h2>Mamba and S4 Explained: Architecture, Parallel Scan, Kernel Fusion, Recurrent, Convolution, Math</h2><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU"><img src="https://i.ytimg.com/vi/8Q_tqwpTpVU/maxresdefault.jpg" style="width:50%;"></a><div><br></div><h3>Chapters</h3><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=0">0:0</a> Introduction<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=106">1:46</a> Sequence modeling<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=432">7:12</a> Differential equations (basics)<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=698">11:38</a> State Space Models<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=833">13:53</a> Discretization<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1388">23:8</a> Recurrent computation<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1592">26:32</a> Convolutional computation<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2058">34:18</a> Skip connection term<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2121">35:21</a> Multidimentional SSM<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2264">37:44</a> The HIPPO theory<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2610">43:30</a> The motivation behind Mamba<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2816">46:56</a> Selective Scan algorithm<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3094">51:34</a> The Scan operation<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3264">54:24</a> Parallel Scan<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3440">57:20</a> Innovations in Selective Scan<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3480">58:0</a> GPU Memory Hierarchy<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3683">61:23</a> Kernel Fusion<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3708">61:48</a> Activations recomputation<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4008">66:48</a> Mamba architecture<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4218">70:18</a> Performance considerations<br><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4374">72:54</a> Conclusion<br><br><div style="text-align: left;"><a href="./8Q_tqwpTpVU.html">Whisper Transcript</a> | <a href="./transcript_8Q_tqwpTpVU.html">Transcript Only Page</a></div><br><div style="max-width: 800px;"><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=0" target="_blank">00:00:00.000</a></span> | <span class="t">Hello guys, welcome back to my channel. Today we are going to talk about Mamba</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3" target="_blank">00:00:03.840</a></span> | <span class="t">So Mamba is a new model for sequence modeling that came out just one month ago in a paper called Mamba linear time sequence modeling</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=11" target="_blank">00:00:11.040</a></span> | <span class="t">With selective state spaces. Let's review the topics of today. In the first part of the video</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=16" target="_blank">00:00:16.140</a></span> | <span class="t">I will be introducing what are sequence models and what kind of sequence modeling we can do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=20" target="_blank">00:00:20.560</a></span> | <span class="t">The second part of the video I will be talking about state space models</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=25" target="_blank">00:00:25.820</a></span> | <span class="t">But to fully understand the state space models, we need to have a little background on differential equation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=31" target="_blank">00:00:31.340</a></span> | <span class="t">I of course don't expect you to have this background because in some</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=35" target="_blank">00:00:35.200</a></span> | <span class="t">Bachelor degree or some master degree it is taught but in some most of the cases</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=40" target="_blank">00:00:40.220</a></span> | <span class="t">It's not taught</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=42" target="_blank">00:00:42.360</a></span> | <span class="t">So I will give you the necessary background to understand differential equations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=46" target="_blank">00:00:46.040</a></span> | <span class="t">and later we will talk about state space models and we will derive the formula for the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=51" target="_blank">00:00:51.040</a></span> | <span class="t">Magnetization and we will also derive the formula for the convolutional computation and the recurrent computation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=55" target="_blank">00:00:55.980</a></span> | <span class="t">I will show you what do we mean by the hippo matrix and the importance of the A matrix in state space models</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=62" target="_blank">00:01:02.280</a></span> | <span class="t">In the second the third part of the video we will be talking about Mamba</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=66" target="_blank">00:01:06.220</a></span> | <span class="t">So what was the motivation that led to the to Mamba and what is the innovation of Mamba, which is the selective scan algorithm?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=72" target="_blank">00:01:12.860</a></span> | <span class="t">So first of all, what do we mean by scan operation and we will see what that this scan operation can be parallelized</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=80" target="_blank">00:01:20.080</a></span> | <span class="t">With the parallel scan we will see what is kernel fusion the recomputation of the activations and finally</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=86" target="_blank">00:01:26.080</a></span> | <span class="t">We will explore the architecture of Mamba and some performance consideration with respect to the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=91" target="_blank">00:01:31.860</a></span> | <span class="t">So as a prerequisite, I just hope that you have a basic basics of calculus</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=96" target="_blank">00:01:36.700</a></span> | <span class="t">I think a high school mathematics will be more than enough and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=99" target="_blank">00:01:39.640</a></span> | <span class="t">You have a basic understanding of the transformer model and neural networks in general. So let's start our journey</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=107" target="_blank">00:01:47.460</a></span> | <span class="t">The goal of a sequence model is to map an input sequence to an output sequence</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=111" target="_blank">00:01:51.940</a></span> | <span class="t">The input sequence can be a continuous signal in that case</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=115" target="_blank">00:01:55.100</a></span> | <span class="t">We want to map it to an output continuous signal or it can be a discrete input signal and we want to map it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=121" target="_blank">00:02:01.360</a></span> | <span class="t">into a discrete output signal for example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=124" target="_blank">00:02:04.040</a></span> | <span class="t">Continuous signal could be audio and a discrete signal could be text for example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=128" target="_blank">00:02:08.600</a></span> | <span class="t">actually most of the time we work with the discrete signals even with the case of audio because we sample the audio file over time and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=136" target="_blank">00:02:16.700</a></span> | <span class="t">if we talk about language modeling, we are talking about a discrete input because we have a finite number of tokens and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=142" target="_blank">00:02:22.620</a></span> | <span class="t">We want to map it to an output sequence of tokens</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=146" target="_blank">00:02:26.740</a></span> | <span class="t">We can choose among many models to do sequence modeling let's review them</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=152" target="_blank">00:02:32.900</a></span> | <span class="t">The first model that comes to mind to do sequence modeling is the recurrent neural network</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=159" target="_blank">00:02:39.140</a></span> | <span class="t">Which is a network in which we have a hidden state and we compute the output as follows</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=165" target="_blank">00:02:45.220</a></span> | <span class="t">So we have for example our input sequence made up of x1 x2 and x3</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=171" target="_blank">00:02:51.140</a></span> | <span class="t">What we do is the first time the hidden sequence we initialize the hidden state is initialized with zeros</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=177" target="_blank">00:02:57.720</a></span> | <span class="t">So we feed to the network the hidden state the first hidden state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=181" target="_blank">00:03:01.760</a></span> | <span class="t">So zeros along with the first input and it will produce the first output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=185" target="_blank">00:03:05.940</a></span> | <span class="t">Then we use the previously produced the hidden state. So the output of the previous step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=194" target="_blank">00:03:14.540</a></span> | <span class="t">It will produce a new hidden state and the new output token for a new</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=199" target="_blank">00:03:19.520</a></span> | <span class="t">Input token and this will be the y2 so the output number two</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=203" target="_blank">00:03:23.720</a></span> | <span class="t">So we use the previously generated hidden state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=206" target="_blank">00:03:26.500</a></span> | <span class="t">Along with a new input token to produce a new output token and a new hidden state that will be used for the next</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=212" target="_blank">00:03:32.860</a></span> | <span class="t">Token as you can see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=215" target="_blank">00:03:35.100</a></span> | <span class="t">This is sequential generation of output is not parallelizable because to generate the nth token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=220" target="_blank">00:03:40.380</a></span> | <span class="t">We need the n-1th token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=224" target="_blank">00:03:44.020</a></span> | <span class="t">So the training of this kind of model cannot be parallelizable. And this is one of the reason the transformer has been so successful</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=230" target="_blank">00:03:50.100</a></span> | <span class="t">However, the inference time is a constant for each token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=234" target="_blank">00:03:54.880</a></span> | <span class="t">Which means that the number of the effort</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=236" target="_blank">00:03:56.680</a></span> | <span class="t">from a computational point of view and also from a memory point of view that we need to put in order to produce one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=242" target="_blank">00:04:02.180</a></span> | <span class="t">token of the output is the same doesn't matter if it's the first token or the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=246" target="_blank">00:04:06.980</a></span> | <span class="t">100th token the effort with that we are doing so the number of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=250" target="_blank">00:04:10.740</a></span> | <span class="t">Operations and computations that we are doing is always the same. We are taking the previous state and the current input to produce one output token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=258" target="_blank">00:04:18.420</a></span> | <span class="t">Theoretically, this one has infinite context length because we can continue with this sequence sequence of forever</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=265" target="_blank">00:04:25.200</a></span> | <span class="t">But practically we cannot because it suffers from a vanishing and exploding gradient</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=270" target="_blank">00:04:30.000</a></span> | <span class="t">Another model that we can use to do sequence modeling, but it's not very used recent</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=276" target="_blank">00:04:36.620</a></span> | <span class="t">It's not very used. It's the convolutional neural network, which is mostly used for computer vision tasks</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=282" target="_blank">00:04:42.340</a></span> | <span class="t">It has a finite context window and it needs to build a kernel that is run</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=288" target="_blank">00:04:48.040</a></span> | <span class="t">So this is the kernel that is run through the input to produce output features. So this is the output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=293" target="_blank">00:04:53.380</a></span> | <span class="t">It is easily parallelizable because each output uses the same kernel</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=298" target="_blank">00:04:58.780</a></span> | <span class="t">So we can run the kernel in parallel on all the possible input windows to produce the output features</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=305" target="_blank">00:05:05.860</a></span> | <span class="t">The last model that we will see is the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=308" target="_blank">00:05:08.480</a></span> | <span class="t">The transformer is easily parallelizable when it comes to training because we have this self-attention mechanism</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=315" target="_blank">00:05:15.060</a></span> | <span class="t">that computes many dot products and since it's a matrix multiplication we can parallelize the operation and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=321" target="_blank">00:05:21.140</a></span> | <span class="t">it has a finite context window defined by the sequence the input sequence and the attention mask and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=330" target="_blank">00:05:30.220</a></span> | <span class="t">The inference of this kind of model, however is not constant for each token. So in the transformer model if we are</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=336" target="_blank">00:05:36.540</a></span> | <span class="t">Producing what the first token of the output we will do one dot product</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=340" target="_blank">00:05:40.740</a></span> | <span class="t">By using the KVCache if we are using the we are producing the 10th output token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=347" target="_blank">00:05:47.620</a></span> | <span class="t">We will need to do 10 dot products to produce it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=350" target="_blank">00:05:50.540</a></span> | <span class="t">And if you are producing the 100th output token, we will need to do 100 dot products</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=356" target="_blank">00:05:56.740</a></span> | <span class="t">So the effort that we put to produce the first token is not the same as the effort that we need to produce the 10th</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=363" target="_blank">00:06:03.340</a></span> | <span class="t">token and this is not good because</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=365" target="_blank">00:06:05.780</a></span> | <span class="t">This doesn't allow us to scale to very long inputs also for the training because the training as you can see that scales</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=374" target="_blank">00:06:14.720</a></span> | <span class="t">Quadratically with the input sequence length, which means that if we double the sequence length</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=379" target="_blank">00:06:19.860</a></span> | <span class="t">We need to do four times more computation to train this model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=383" target="_blank">00:06:23.300</a></span> | <span class="t">But it's easily parallelizable</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=386" target="_blank">00:06:26.340</a></span> | <span class="t">So and in an ideal world that we would like the model for which we can</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=391" target="_blank">00:06:31.140</a></span> | <span class="t">Parallelize the training just like the transformer because we can exploit our GPU very well and it can scale linearly to long sequences</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=399" target="_blank">00:06:39.300</a></span> | <span class="t">Just like the RNN because it scales linearly with the input sequence length</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=404" target="_blank">00:06:44.460</a></span> | <span class="t">And in an ideal world, we also would like to inference each token with a constant memory and the computation cost</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=411" target="_blank">00:06:51.940</a></span> | <span class="t">Which means that the effort we need to put to produce the first token should be the same as the effort that we put to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=417" target="_blank">00:06:57.900</a></span> | <span class="t">Produce the 10th token or the 100th token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=420" target="_blank">00:07:00.580</a></span> | <span class="t">Now let's explore state space models and how they can help us solve the problems of the recurrent neural networks and the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=429" target="_blank">00:07:09.060</a></span> | <span class="t">But first we need to review some maths</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=431" target="_blank">00:07:11.340</a></span> | <span class="t">Let me give you a very simple introduction to differential equation with a very simple example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=438" target="_blank">00:07:18.580</a></span> | <span class="t">Imagine you have some bunnies and the population of these bunnies grows at a constant rate of lambda</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=443" target="_blank">00:07:23.900</a></span> | <span class="t">Proportional to the number of bunnies that you have which means that every bunny will give birth to lambda baby bunnies</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=450" target="_blank">00:07:30.220</a></span> | <span class="t">Now also suppose that the lambda is equal to 2. So let's write lambda equal to 2</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=455" target="_blank">00:07:35.300</a></span> | <span class="t">So we can see that the rate of change of the population</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=459" target="_blank">00:07:39.500</a></span> | <span class="t">Which means the number of babies that are born is equal to lambda</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=464" target="_blank">00:07:44.140</a></span> | <span class="t">Multiplied by the number of bunnies that you have at a particular time step t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=468" target="_blank">00:07:48.340</a></span> | <span class="t">So which means also that the rate of change of this population because the number of babies that these bunnies produce is also the rate</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=475" target="_blank">00:07:55.060</a></span> | <span class="t">Of change of this population</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=476" target="_blank">00:07:56.540</a></span> | <span class="t">So how much the population is growing is equal to lambda multiplied by the number of bunnies that you have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=480" target="_blank">00:08:00.860</a></span> | <span class="t">But if you remember from high school, what is the rate of change of a particular function?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=485" target="_blank">00:08:05.900</a></span> | <span class="t">It is the variable is the derivative of this function</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=489" target="_blank">00:08:09.380</a></span> | <span class="t">so we can also say that the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=492" target="_blank">00:08:12.460</a></span> | <span class="t">derivative of the function that describes the number of bunnies in time is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=497" target="_blank">00:08:17.060</a></span> | <span class="t">Equal to lambda multiplied by the number of bunnies that you have at a particular time step t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=501" target="_blank">00:08:21.980</a></span> | <span class="t">How can we find the population at time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=508" target="_blank">00:08:28.140</a></span> | <span class="t">100 knowing that the population is made up of five bunnies at time equal to 0</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=514" target="_blank">00:08:34.180</a></span> | <span class="t">We need to find a function B of t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=517" target="_blank">00:08:37.460</a></span> | <span class="t">So we need to find a function B of t that describes the population of our bunnies over time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=523" target="_blank">00:08:43.820</a></span> | <span class="t">So the evolution of our population over time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=526" target="_blank">00:08:46.220</a></span> | <span class="t">Solving a differential equation means to find a function in this case B of t that makes the expression</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=533" target="_blank">00:08:53.700</a></span> | <span class="t">above so this expression here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=536" target="_blank">00:08:56.420</a></span> | <span class="t">true</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=538" target="_blank">00:08:58.700</a></span> | <span class="t">For all t so we need to find a function t that when replaced in this expression makes the left hand side equal to the right</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=545" target="_blank">00:09:05.980</a></span> | <span class="t">hand side and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=547" target="_blank">00:09:07.980</a></span> | <span class="t">This differential equation can be solved using a very simple method called the method of separation of variables</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=554" target="_blank">00:09:14.160</a></span> | <span class="t">So I will not show you here, but we can clearly see that a solution to this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=558" target="_blank">00:09:18.300</a></span> | <span class="t">Differential equation is this function here B of t is equal to K multiplied by</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=563" target="_blank">00:09:23.580</a></span> | <span class="t">Exponential of lambda by t where K is equal to the initial population of bunnies</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=570" target="_blank">00:09:30.540</a></span> | <span class="t">How can we verify that this is actually the solution of this differential equation because if we replace this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=576" target="_blank">00:09:36.260</a></span> | <span class="t">Function here inside this expression it will make the left hand side equal to the right hand side</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=581" target="_blank">00:09:41.380</a></span> | <span class="t">This is how we verify the solution of it equation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=583" target="_blank">00:09:43.900</a></span> | <span class="t">So let's try to replace it first of all in the left hand side</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=587" target="_blank">00:09:47.580</a></span> | <span class="t">We have the derivative of this function with respect to t so let's calculate the derivative of this function with respect to t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=593" target="_blank">00:09:53.260</a></span> | <span class="t">Which is equal to K</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=596" target="_blank">00:09:56.060</a></span> | <span class="t">Multiplied by lambda multiplied by A to the power of lambda t and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=601" target="_blank">00:10:01.780</a></span> | <span class="t">This is equal to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=604" target="_blank">00:10:04.380</a></span> | <span class="t">Lambda multiplied by the function itself, which is K</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=608" target="_blank">00:10:08.220</a></span> | <span class="t">multiplied by e to the power of lambda t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=611" target="_blank">00:10:11.860</a></span> | <span class="t">You can see that these two expressions are the same so this function here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=617" target="_blank">00:10:17.820</a></span> | <span class="t">So this function here is a solution to our differential equation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=622" target="_blank">00:10:22.820</a></span> | <span class="t">So when you have a differential equation the solution of a differential equation is not a number</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=627" target="_blank">00:10:27.620</a></span> | <span class="t">When we like when we solve a quadratic equation so when you solve for example the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=631" target="_blank">00:10:31.900</a></span> | <span class="t">Equation X to the power of 2 is equal to 4 you get some values of X that make the left-hand side</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=638" target="_blank">00:10:38.660</a></span> | <span class="t">Equal to the right-hand side in the case of a differential equation you find a function</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=643" target="_blank">00:10:43.900</a></span> | <span class="t">That makes the left-hand side equal to the right-hand side and usually we represent the differential equation by omitting the variable t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=652" target="_blank">00:10:52.180</a></span> | <span class="t">And writing it as follows so B t so B dot is equal to lambda</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=657" target="_blank">00:10:57.940</a></span> | <span class="t">Multiplied by B. This dot indicates that it's derivative of this function with respect to a certain variable, which is implied</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=665" target="_blank">00:11:05.620</a></span> | <span class="t">and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=668" target="_blank">00:11:08.180</a></span> | <span class="t">basically the result of this differential equation will</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=671" target="_blank">00:11:11.420</a></span> | <span class="t">Will describe the evolution of our bunnies so this function here that we have found B of t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=677" target="_blank">00:11:17.980</a></span> | <span class="t">Will describe how the population of our bunnies will grow</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=682" target="_blank">00:11:22.020</a></span> | <span class="t">and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=683" target="_blank">00:11:23.260</a></span> | <span class="t">We usually use the differential equations to model the state of a system over time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=688" target="_blank">00:11:28.100</a></span> | <span class="t">With the goal of finding a function that gives us the state of the system at any time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=694" target="_blank">00:11:34.340</a></span> | <span class="t">Given the initial state of the system, and this is what we do with state space models</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=699" target="_blank">00:11:39.380</a></span> | <span class="t">A state space model allow us to map an input signal X of t to an output signal Y of t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=705" target="_blank">00:11:45.980</a></span> | <span class="t">By means of a state representation H of t as follows</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=710" target="_blank">00:11:50.740</a></span> | <span class="t">So H prime of t which means the derivative of this function H of t with respect to time is equal to a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=718" target="_blank">00:11:58.140</a></span> | <span class="t">number A or a matrix A multiplied by H of t plus B</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=722" target="_blank">00:12:02.820</a></span> | <span class="t">Multiplied by X of t and then the output of the system is computed as follows</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=728" target="_blank">00:12:08.260</a></span> | <span class="t">This state space model is linear and time invariant</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=732" target="_blank">00:12:12.860</a></span> | <span class="t">It's linear because the relationships in the expressions above are linear and the time invariant because the parameter matrices</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=740" target="_blank">00:12:20.020</a></span> | <span class="t">A, B, C and D do not vary over time because you can see they do not depend on the time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=746" target="_blank">00:12:26.100</a></span> | <span class="t">They are always fixed for each time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=748" target="_blank">00:12:28.100</a></span> | <span class="t">So for now for simplicity, we will consider that all these parameters</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=753" target="_blank">00:12:33.980</a></span> | <span class="t">So A, B, C and D, but also the input the output and the H of t are numbers not vectors</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=759" target="_blank">00:12:39.500</a></span> | <span class="t">Later, we will expand our analysis to vectors</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=761" target="_blank">00:12:41.980</a></span> | <span class="t">Now you may be wondering</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=764" target="_blank">00:12:44.500</a></span> | <span class="t">Okay, we have these expressions, but how can I compute the output of this model given the input X of t?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=771" target="_blank">00:12:51.940</a></span> | <span class="t">As you can see in the first expression, we have a differential equation and to compute the output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=777" target="_blank">00:12:57.780</a></span> | <span class="t">Like this we need to have a function H of t that describes the state of our system at every time step t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=785" target="_blank">00:13:05.700</a></span> | <span class="t">So to find the output Y of t of this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=789" target="_blank">00:13:09.740</a></span> | <span class="t">This model we need to find first of all, we need to solve this differential equation here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=794" target="_blank">00:13:14.300</a></span> | <span class="t">So it means to find a function H of t that describes the state of the system for all time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=800" target="_blank">00:13:20.260</a></span> | <span class="t">but solving this differential equation can be hard analytically and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=804" target="_blank">00:13:24.860</a></span> | <span class="t">Usually also we do not work with the continuous signals</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=808" target="_blank">00:13:28.740</a></span> | <span class="t">So we do our input X of t usually is not continuous because when we do work with computer or any digital device</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=815" target="_blank">00:13:35.060</a></span> | <span class="t">We always work with discrete systems</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=817" target="_blank">00:13:37.740</a></span> | <span class="t">So one way is to actually discretize this system such that we can calculate an approximate</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=823" target="_blank">00:13:43.020</a></span> | <span class="t">Solution of this H of t in a discretized way. So not in a continuous way</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=828" target="_blank">00:13:48.220</a></span> | <span class="t">Let's see how we can discretize our system to compute then the output of the system itself</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=833" target="_blank">00:13:53.460</a></span> | <span class="t">To solve a differential equation we need to find the function H of t so in our case this function here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=841" target="_blank">00:14:01.460</a></span> | <span class="t">So let me change to the pointer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=843" target="_blank">00:14:03.940</a></span> | <span class="t">so this function a function H of t that when replaced here will make the left-hand side equal to the right-hand side and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=850" target="_blank">00:14:10.740</a></span> | <span class="t">But solving this finding this function H of t in the continuous domain</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=856" target="_blank">00:14:16.460</a></span> | <span class="t">It can be very hard analytically and also because we work with the discrete input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=861" target="_blank">00:14:21.460</a></span> | <span class="t">We can discretize this system, which means that we can approximate the solution of this differential equation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=867" target="_blank">00:14:27.420</a></span> | <span class="t">So instead of finding H of t for all the time step we can find H of t for certain time steps</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=873" target="_blank">00:14:33.880</a></span> | <span class="t">Instead so for example, we may want to find H of t for H of 0, H of 1, H of 2, H of 3, etc</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=881" target="_blank">00:14:41.140</a></span> | <span class="t">In this case, we have chosen a step size the step size in my case</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=886" target="_blank">00:14:46.040</a></span> | <span class="t">I have chosen 1 because I'm evaluating the function H of t only in certain time steps</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=891" target="_blank">00:14:51.300</a></span> | <span class="t">that are separated by a step size of 1 so I go from 0 to 1 from 1 to 2 from 2 to 3 and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=897" target="_blank">00:14:57.700</a></span> | <span class="t">This is will be our Delta</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=899" target="_blank">00:14:59.780</a></span> | <span class="t">so</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=901" target="_blank">00:15:01.620</a></span> | <span class="t">Remember the bunnies problem. Let's try to find the approximate solution of this bunny problem using the Euler's method</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=907" target="_blank">00:15:07.900</a></span> | <span class="t">So before I give you the result of this bunnies problem using the analytical solution, which was very easy to compute</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=914" target="_blank">00:15:14.860</a></span> | <span class="t">But let's try to build the same solution</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=918" target="_blank">00:15:18.100</a></span> | <span class="t">But using the Euler's method or actually not the same, but it's the approximated solution using the Euler's method</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=924" target="_blank">00:15:24.100</a></span> | <span class="t">So first of all, let's rewrite the our bunny population model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=928" target="_blank">00:15:28.180</a></span> | <span class="t">Which is the derivative of the function that describes the bunny population</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=933" target="_blank">00:15:33.220</a></span> | <span class="t">With respect to the variable time is equal to lambda multiplied by the function itself</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=939" target="_blank">00:15:39.180</a></span> | <span class="t">If you remember from high school</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=942" target="_blank">00:15:42.340</a></span> | <span class="t">What is the definition of the derivative the derivative is equal to the limit of a step?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=947" target="_blank">00:15:47.860</a></span> | <span class="t">Going to 0 of the function evaluated at t plus the step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=953" target="_blank">00:15:53.540</a></span> | <span class="t">Minus the function at time step t divided by the step size. This is the definition of derivative. So there is nothing new here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=960" target="_blank">00:16:00.820</a></span> | <span class="t">now</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=963" target="_blank">00:16:03.060</a></span> | <span class="t">This this is the the left-hand side is equal to the right-hand side when the Delta so the step size that we are using</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=970" target="_blank">00:16:10.260</a></span> | <span class="t">It's very very very very very small. So suppose that we choose a very very very small step size</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=975" target="_blank">00:16:15.980</a></span> | <span class="t">So then we can get rid of this equality and change it to an approximate approximation so we can see that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=982" target="_blank">00:16:22.980</a></span> | <span class="t">Okay, what if I choose a very small step size, then the left-hand side will be more or less equal to the right-hand side</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=990" target="_blank">00:16:30.700</a></span> | <span class="t">Now by multiplying with the Delta on both sides and then bringing this term to the right-hand side</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=998" target="_blank">00:16:38.260</a></span> | <span class="t">We can write the following formula here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1001" target="_blank">00:16:41.160</a></span> | <span class="t">Which allow us to compute the value of the function B at the time step t plus Delta. So one step forward</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1008" target="_blank">00:16:48.600</a></span> | <span class="t">As the derivative of the function at time step t multiplied by Delta plus the function at time step t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1016" target="_blank">00:16:56.540</a></span> | <span class="t">But what is the derivative of the function here?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1022" target="_blank">00:17:02.700</a></span> | <span class="t">We know that the derivative of the function that we are trying to approximate is equal to the Lambda multiplied by the function itself</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1030" target="_blank">00:17:10.380</a></span> | <span class="t">So we can replace</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1032" target="_blank">00:17:12.820</a></span> | <span class="t">here in this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1035" target="_blank">00:17:15.100</a></span> | <span class="t">Expression here we can replace our population model and we obtain the following</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1040" target="_blank">00:17:20.060</a></span> | <span class="t">Expression and this allow us to compute the bunnies population at time step t plus Delta</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1046" target="_blank">00:17:26.260</a></span> | <span class="t">So at the next time step given the bunnies population at the previous time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1051" target="_blank">00:17:31.540</a></span> | <span class="t">Multiplied by a Delta and the Lambda. So we obtained a recurrent formulation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1057" target="_blank">00:17:37.540</a></span> | <span class="t">Wonderful now that we have our recurrent formulation to approximate the state of the bunny population over time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1065" target="_blank">00:17:45.640</a></span> | <span class="t">Suppose we set Lambda equal to 2 which means that every bunny will make two children and Delta is equal to 1</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1072" target="_blank">00:17:52.980</a></span> | <span class="t">So we want to go forward by one by one step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1075" target="_blank">00:17:55.980</a></span> | <span class="t">So t is equal to 0 then t equal to 1, t equal to 2, etc, etc</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1079" target="_blank">00:17:59.380</a></span> | <span class="t">For example, if we started with a population of 5 bunnies at time step 0</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1084" target="_blank">00:18:04.380</a></span> | <span class="t">We can calculate the evolution of the population as follows</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1088" target="_blank">00:18:08.040</a></span> | <span class="t">Knowing that the population at time step 0 we can calculate the population at time step 1 using the formula that we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1094" target="_blank">00:18:14.620</a></span> | <span class="t">So B of 1 is equal to Lambda</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1097" target="_blank">00:18:17.660</a></span> | <span class="t">Delta multiplied by Lambda multiplied by the population at the previous time step. So just like this formula here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1104" target="_blank">00:18:24.660</a></span> | <span class="t">Plus the population at the previous time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1106" target="_blank">00:18:26.540</a></span> | <span class="t">So this gives us a 15 and it makes sense why because we started with 5 bunnies. Each bunny has 2 children</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1112" target="_blank">00:18:32.900</a></span> | <span class="t">So they have 10 babies and the initial population, which is 5 plus 10 babies gives us a population of 15</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1120" target="_blank">00:18:40.140</a></span> | <span class="t">Now that we have the population at time step 1 we can calculate the population at the time step 2 which is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1126" target="_blank">00:18:46.520</a></span> | <span class="t">45 because we had 15 bunnies each one makes 2 children. So we have 30 children</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1133" target="_blank">00:18:53.360</a></span> | <span class="t">So 15 plus 30 is equal to 45</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1136" target="_blank">00:18:56.500</a></span> | <span class="t">Now that we have the population at time step 2 we can calculate the population at time step 3 and it's</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1141" target="_blank">00:19:01.860</a></span> | <span class="t">135 because we have a 45 bunnies each one of them makes 2 children. So we have 90 children plus 45, which is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1149" target="_blank">00:19:09.900</a></span> | <span class="t">135 and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1152" target="_blank">00:19:12.500</a></span> | <span class="t">If you compare the solution that we are obtaining for this time step with the analytical solution that we found before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1159" target="_blank">00:19:19.820</a></span> | <span class="t">That I didn't show you how to find it, but it can be easily found using a method called the separation of variables</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1165" target="_blank">00:19:25.880</a></span> | <span class="t">If you compare the plot of these two functions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1169" target="_blank">00:19:29.920</a></span> | <span class="t">You will see that the analytical function grows very fast while the approximated solution grows very slow</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1175" target="_blank">00:19:35.340</a></span> | <span class="t">and this is actually and the two are similar in how they</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1179" target="_blank">00:19:39.440</a></span> | <span class="t">Change but they will not overlap</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1183" target="_blank">00:19:43.320</a></span> | <span class="t">Because the step size that we have chosen is very big</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1186" target="_blank">00:19:46.520</a></span> | <span class="t">I mean we chose lambda equal to delta equal to 1 to make a better approximation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1191" target="_blank">00:19:51.520</a></span> | <span class="t">We need to use a delta very very small and actually the Euler method does not give us very good</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1197" target="_blank">00:19:57.440</a></span> | <span class="t">Results very very good approximations of the analytical solution</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1201" target="_blank">00:20:01.980</a></span> | <span class="t">and we use a similar reasoning that we used for the bunny population to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1208" target="_blank">00:20:08.380</a></span> | <span class="t">Discretize the system of the state space model. So how to discretize that system?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1214" target="_blank">00:20:14.160</a></span> | <span class="t">we just as you remember we found using the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1218" target="_blank">00:20:18.320</a></span> | <span class="t">The definition of the derivative we found out that a function evaluated at the time step t plus delta is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1225" target="_blank">00:20:25.760</a></span> | <span class="t">more or less so approximately equal to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1229" target="_blank">00:20:29.240</a></span> | <span class="t">Delta multiplied by the derivative of the function at time step t plus the function at time step t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1236" target="_blank">00:20:36.560</a></span> | <span class="t">But what is the derivative of the function at time step t?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1239" target="_blank">00:20:39.900</a></span> | <span class="t">We know from our state space model that the derivative of this function h prime is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1244" target="_blank">00:20:44.760</a></span> | <span class="t">Equal to a multiplied by h of t plus b multiplied by x of t. So we just replace this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1251" target="_blank">00:20:51.600</a></span> | <span class="t">expression here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1254" target="_blank">00:20:54.080</a></span> | <span class="t">Into this term here and we obtain the following derivation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1258" target="_blank">00:20:58.920</a></span> | <span class="t">So we replace this stuff here with h prime of t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1262" target="_blank">00:21:02.680</a></span> | <span class="t">We multiply it by delta we collect this term h of t and we obtain the following</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1269" target="_blank">00:21:09.560</a></span> | <span class="t">Discretized the parameters of the discretized model. So if we set a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1274" target="_blank">00:21:14.460</a></span> | <span class="t">bar equal to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1277" target="_blank">00:21:17.160</a></span> | <span class="t">the identity matrix plus delta a and b bar equal to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1284" target="_blank">00:21:24.640</a></span> | <span class="t">Delta B. We will obtain a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1288" target="_blank">00:21:28.260</a></span> | <span class="t">Recurrent formula just like with the bunny</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1292" target="_blank">00:21:32.480</a></span> | <span class="t">Problem the bunny population problem that allow us to compute the next state of the model given the previous state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1299" target="_blank">00:21:39.620</a></span> | <span class="t">and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1302" target="_blank">00:21:42.440</a></span> | <span class="t">Actually in the paper this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1305" target="_blank">00:21:45.280</a></span> | <span class="t">So in the paper they show first of all the continuous</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1308" target="_blank">00:21:48.880</a></span> | <span class="t">Formulation of the state space model, which is this one and then they show you the discrete</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1313" target="_blank">00:21:53.880</a></span> | <span class="t">Discretized model that you can see here and they also show you how to obtain this discretized parameter</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1321" target="_blank">00:22:01.360</a></span> | <span class="t">So the parameters of the discretized model, which is this a bar and b bar actually in the paper</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1327" target="_blank">00:22:07.200</a></span> | <span class="t">They do not use the Euler method. So the one that I used here to derive the discretized version</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1332" target="_blank">00:22:12.900</a></span> | <span class="t">They use a method called the zero-order hold and I believe they use this one because it results in a better approximation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1338" target="_blank">00:22:18.960</a></span> | <span class="t">But the idea of the discretization is that instead of calculating the analytical solution of this differential equation here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1347" target="_blank">00:22:27.360</a></span> | <span class="t">We calculate approximately what is the H state of the system at discrete time steps</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1353" target="_blank">00:22:33.680</a></span> | <span class="t">And then we can plug this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1355" target="_blank">00:22:35.680</a></span> | <span class="t">this approximated</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1358" target="_blank">00:22:38.480</a></span> | <span class="t">State value into this second relationship to get the output of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1364" target="_blank">00:22:44.920</a></span> | <span class="t">But in practice as you saw before we had to choose the delta parameter to discretize the system in practice</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1374" target="_blank">00:22:54.320</a></span> | <span class="t">We do not choose the discretization step delta, but we let make it a parameter of the model that we will train with gradient descent</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1381" target="_blank">00:23:01.120</a></span> | <span class="t">So that the model will learn this parameter delta based on the input that it will see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1387" target="_blank">00:23:07.120</a></span> | <span class="t">Okay</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1390" target="_blank">00:23:10.080</a></span> | <span class="t">Now that we have our recurrent formulation to calculate the output of the system sequentially</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1395" target="_blank">00:23:15.780</a></span> | <span class="t">How can we use it to calculate the output of the system for various time steps? Let's do it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1401" target="_blank">00:23:21.600</a></span> | <span class="t">Suppose for simplicity that the initial state of the system is zero</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1405" target="_blank">00:23:25.600</a></span> | <span class="t">So the first state of the system, so suppose we have an input made up of x0, x1, x2, x3, x4</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1413" target="_blank">00:23:33.280</a></span> | <span class="t">So it's a discrete input. That's why we are using the discretized state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1417" target="_blank">00:23:37.360</a></span> | <span class="t">we can compute the first state of the system which is equal to b multiplied by x0 because</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1423" target="_blank">00:23:43.040</a></span> | <span class="t">We are multiplying a by the previous state, but the previous state we say it's zero</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1427" target="_blank">00:23:47.920</a></span> | <span class="t">So this term will not be present and by using this state we can calculate the first output of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1433" target="_blank">00:23:53.920</a></span> | <span class="t">Which is just c multiplied by h0</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1435" target="_blank">00:23:55.920</a></span> | <span class="t">Now we can calculate the next state of the system by using the previous state and the next input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1441" target="_blank">00:24:01.840</a></span> | <span class="t">Just using the formula here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1444" target="_blank">00:24:04.160</a></span> | <span class="t">So a multiplied a bar multiplied by the previous state of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1448" target="_blank">00:24:08.400</a></span> | <span class="t">Which we already computed plus b multiplied by the next input of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1453" target="_blank">00:24:13.040</a></span> | <span class="t">Having the next state we can compute the next output which is y1 is equal to c multiplied by h1</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1459" target="_blank">00:24:19.280</a></span> | <span class="t">Now using the previous state we can compute the next state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1463" target="_blank">00:24:23.120</a></span> | <span class="t">So h2, h2 is equal to a multiplied by the previous state plus b multiplied by the next input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1468" target="_blank">00:24:28.880</a></span> | <span class="t">And using h2 we can compute y2. So the output at the next step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1474" target="_blank">00:24:34.320</a></span> | <span class="t">And this is exactly what we used to do with the recurrent neural networks</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1478" target="_blank">00:24:38.880</a></span> | <span class="t">So that's why they are called the recurrent neural networks because they have this recurrent formulation to go from the previous step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1484" target="_blank">00:24:44.960</a></span> | <span class="t">to the next step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1487" target="_blank">00:24:47.280</a></span> | <span class="t">And as you can see, this is exactly what we did</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1491" target="_blank">00:24:51.040</a></span> | <span class="t">So our initial state is zero</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1493" target="_blank">00:24:53.600</a></span> | <span class="t">And we use our first input and the previous state to calculate the first output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1498" target="_blank">00:24:58.960</a></span> | <span class="t">This will not only produce the first output, but also the next state of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1504" target="_blank">00:25:04.240</a></span> | <span class="t">Then we use the next state of the system plus the next input to produce the next output and the next state of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1510" target="_blank">00:25:10.640</a></span> | <span class="t">Then we use the next state of the system plus the next output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1513" target="_blank">00:25:13.840</a></span> | <span class="t">Input to produce the next output and the next state of the system, etc, etc. Just like we saw before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1519" target="_blank">00:25:19.600</a></span> | <span class="t">The recurrent formulation that we have just seen is great for inference</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1525" target="_blank">00:25:25.200</a></span> | <span class="t">Because we can compute one token at a time with a constant memory and computation requirement because the effort that we are</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1533" target="_blank">00:25:33.440</a></span> | <span class="t">Making to compute this output here is exactly the same as the effort that we take to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1538" target="_blank">00:25:38.480</a></span> | <span class="t">Compute this output here. So the second output token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1542" target="_blank">00:25:42.720</a></span> | <span class="t">And this makes it suitable for inference during a large language model because in large language model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1548" target="_blank">00:25:48.880</a></span> | <span class="t">We generate one token at a time using the previous tokens and the prompt</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1553" target="_blank">00:25:53.120</a></span> | <span class="t">However, the recurrent formulation is not good for training because during training we already have all the tokens</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1560" target="_blank">00:26:00.080</a></span> | <span class="t">We do not need to generate the output of the model one token at a time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1564" target="_blank">00:26:04.560</a></span> | <span class="t">We already have our sequence of input. We already have a sequence that is the target</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1570" target="_blank">00:26:10.000</a></span> | <span class="t">We want to compute the output of the model in parallel without doing this sequential</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1574" target="_blank">00:26:14.660</a></span> | <span class="t">Computation to calculate the loss and train the model and this is exactly what we do with the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1580" target="_blank">00:26:20.960</a></span> | <span class="t">But we cannot do it with this recurrent computation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1585" target="_blank">00:26:25.180</a></span> | <span class="t">Thankfully the state space model also provide a convolutional mode as well, which can be parallelized. Let's see how it works</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1592" target="_blank">00:26:32.060</a></span> | <span class="t">So using just the recurrent formulation that we have seen before let's expand the output at every step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1599" target="_blank">00:26:39.900</a></span> | <span class="t">So as you saw before to compute the first state of the model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1603" target="_blank">00:26:43.500</a></span> | <span class="t">We need to take the initial input multiplied by b because we suppose that the previous state is zero. So there is no a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1609" target="_blank">00:26:49.900</a></span> | <span class="t">This term here disappears in the first state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1614" target="_blank">00:26:54.140</a></span> | <span class="t">We can use to use the first state to compute the first output, which is c multiplied by h zero</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1619" target="_blank">00:26:59.900</a></span> | <span class="t">and this gives us</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1622" target="_blank">00:27:02.460</a></span> | <span class="t">uh</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1623" target="_blank">00:27:03.900</a></span> | <span class="t">We can replace this the h zero with this with with the what what is the with?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1629" target="_blank">00:27:09.980</a></span> | <span class="t">expanded expression b multiplied by x zero</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1633" target="_blank">00:27:13.420</a></span> | <span class="t">We can then use h zero to compute h one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1637" target="_blank">00:27:17.340</a></span> | <span class="t">So h one is equal to a multiplied by h zero plus b multiplied by x one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1642" target="_blank">00:27:22.860</a></span> | <span class="t">But what is h zero h zero is exactly this stuff here. So b multiplied by x zero</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1648" target="_blank">00:27:28.780</a></span> | <span class="t">so we can compute the output the state of the system at the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1652" target="_blank">00:27:32.620</a></span> | <span class="t">time step one using</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1655" target="_blank">00:27:35.420</a></span> | <span class="t">This computation here and the output of the system at time steps one using h1</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1662" target="_blank">00:27:42.060</a></span> | <span class="t">And then we expand the expression of h1 to obtain this expression here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1668" target="_blank">00:27:48.540</a></span> | <span class="t">We can use the similar reasoning to expand also the representation of the h2 space</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1674" target="_blank">00:27:54.780</a></span> | <span class="t">So that it only depends on the input and the parameters of the model and in the same way</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1679" target="_blank">00:27:59.980</a></span> | <span class="t">Also the computation of the output of the model at time step two using only the input and the parameters of the model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1687" target="_blank">00:28:07.020</a></span> | <span class="t">As you can see we see a pattern</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1690" target="_blank">00:28:10.700</a></span> | <span class="t">So that to compute the kth token of the output we need to do the following</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1696" target="_blank">00:28:16.920</a></span> | <span class="t">Summation. So for example to compute y2 as you can see, we are multiplying x2 multiplied by cb</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1703" target="_blank">00:28:23.400</a></span> | <span class="t">So as you can see yk we are multiplying xk multiplied by cb</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1708" target="_blank">00:28:28.120</a></span> | <span class="t">Then the previous token so in here x1. So here xk minus one multiplied by cab</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1715" target="_blank">00:28:35.000</a></span> | <span class="t">cab, etc</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1716" target="_blank">00:28:36.920</a></span> | <span class="t">and then the previous previous token with</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1719" target="_blank">00:28:39.880</a></span> | <span class="t">Ca with an additional with the by increasing the power by which a is elevated multiplied by b</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1727" target="_blank">00:28:47.000</a></span> | <span class="t">and this is exactly what we say here, so the previous token with a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1730" target="_blank">00:28:50.360</a></span> | <span class="t">An increasing power of a and etc, etc until we reach the kth power of a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1735" target="_blank">00:28:55.880</a></span> | <span class="t">By using the formula we derived we note something interesting</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1741" target="_blank">00:29:01.660</a></span> | <span class="t">The output of the system can be calculated using a convolution of a kernel k with the input x</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1749" target="_blank">00:29:09.160</a></span> | <span class="t">So this formulation this formula that we derived here, which basically represents the pattern of all the expanded</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1756" target="_blank">00:29:16.460</a></span> | <span class="t">formulas that we saw before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1759" target="_blank">00:29:19.880</a></span> | <span class="t">Using this this formula here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1762" target="_blank">00:29:22.040</a></span> | <span class="t">We can build a kernel a kernel just like the kernel that we use in convolutional neural networks</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1767" target="_blank">00:29:27.480</a></span> | <span class="t">With the first term of the kernel being cb the second being cab the third being ca to the power of kb</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1774" target="_blank">00:29:34.440</a></span> | <span class="t">Etc, etc until the last item of the kernel and we can convolve this kernel with the input to compute directly the output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1782" target="_blank">00:29:42.120</a></span> | <span class="t">And as you remember the convolution is something that we can parallelize</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1786" target="_blank">00:29:46.700</a></span> | <span class="t">So that's why this is very powerful because if we build this kernel</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1791" target="_blank">00:29:51.240</a></span> | <span class="t">We can convolve it on the input to produce the output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1795" target="_blank">00:29:55.080</a></span> | <span class="t">And I want to prove you that the output computed using the kernel like this is exactly the one we just found</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1802" target="_blank">00:30:02.280</a></span> | <span class="t">By expanding these formulas before so let's do it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1805" target="_blank">00:30:05.720</a></span> | <span class="t">We build a kernel like this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1809" target="_blank">00:30:09.480</a></span> | <span class="t">Cb cab etc, etc up to the ca to the power of kb</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1814" target="_blank">00:30:14.440</a></span> | <span class="t">Depending on what is the length of the sequence that we are producing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1818" target="_blank">00:30:18.300</a></span> | <span class="t">I am just</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1820" target="_blank">00:30:20.760</a></span> | <span class="t">Inverting the kernel. So the first term is not a cb</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1823" target="_blank">00:30:23.560</a></span> | <span class="t">But it's the last term and the second this one here becomes the second last etc because it's easier to visualize</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1830" target="_blank">00:30:30.680</a></span> | <span class="t">Then we have our input which is x0 x1 x2 x3</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1834" target="_blank">00:30:34.840</a></span> | <span class="t">But I add some padding later. I will show you why and then we have our output that will be produced by this convolution</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1840" target="_blank">00:30:40.700</a></span> | <span class="t">So let's run this convolution step by step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1843" target="_blank">00:30:43.480</a></span> | <span class="t">The first output of the convolution is just the kernel</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1848" target="_blank">00:30:48.760</a></span> | <span class="t">Slided over the first four tokens of the input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1854" target="_blank">00:30:54.280</a></span> | <span class="t">And we multiply this term with this one this term of the kernel with the this term of the input this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1861" target="_blank">00:31:01.240</a></span> | <span class="t">Term of the kernel with this term of the input this current term of the kernel with this term of the input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1865" target="_blank">00:31:05.880</a></span> | <span class="t">And then we sum all these results and the sum you can see is equal to y0 x</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1871" target="_blank">00:31:11.080</a></span> | <span class="t">X0 multiplied by cb and this is exactly result from this formula here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1877" target="_blank">00:31:17.000</a></span> | <span class="t">So as you can see if we only have the first token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1880" target="_blank">00:31:20.200</a></span> | <span class="t">It will be only cb multiplied by the token itself because we don't have any preceding token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1885" target="_blank">00:31:25.320</a></span> | <span class="t">Let's go forward then we slide the kernel forward by one step and it will produce the following output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1893" target="_blank">00:31:33.240</a></span> | <span class="t">So we have this item of the kernel multiplied by x1</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1896" target="_blank">00:31:36.760</a></span> | <span class="t">This item of the kernel multiplied by x0 and all the other multiplied by 0 so they will not contribute to the sum</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1902" target="_blank">00:31:42.440</a></span> | <span class="t">So y1 is equal to this here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1905" target="_blank">00:31:45.560</a></span> | <span class="t">So as you can see when y is equal the k is equal to one we have x1 multiplied by cb</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1911" target="_blank">00:31:51.560</a></span> | <span class="t">And then we have the previous term. So x0 multiplied by cab</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1915" target="_blank">00:31:55.900</a></span> | <span class="t">Then we slide our kernel forward</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1918" target="_blank">00:31:58.920</a></span> | <span class="t">And we can see that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1921" target="_blank">00:32:01.480</a></span> | <span class="t">This term is multiplied by this this term is multiplied by this and this term is multiplied by this and the last one is multiplied</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1928" target="_blank">00:32:08.280</a></span> | <span class="t">By zero so it doesn't contribute to the sum</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1930" target="_blank">00:32:10.760</a></span> | <span class="t">So y2 is computed like this and as you can see if you compare it with this formula, you will see that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1937" target="_blank">00:32:17.240</a></span> | <span class="t">yk so when k is equal to 2 it will be cb multiplied by x2 then cab multiplied by x1 and then</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1945" target="_blank">00:32:25.080</a></span> | <span class="t">ca</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1948" target="_blank">00:32:28.120</a></span> | <span class="t">Without a actually ca to the power of 2 multiplied by b multiplied by x0 which is the previous token compared to x minus 1</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1957" target="_blank">00:32:37.080</a></span> | <span class="t">And etc for the step number 4 and this one you can verify by yourself</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1960" target="_blank">00:32:40.700</a></span> | <span class="t">The best thing about the convolution calculation is that it can be parallelized</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1966" target="_blank">00:32:46.220</a></span> | <span class="t">Because the output of yk does not depend on the previous output. So what I mean is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1972" target="_blank">00:32:52.360</a></span> | <span class="t">this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1974" target="_blank">00:32:54.200</a></span> | <span class="t">product that we are doing here can be done on one thread for example or one core of the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1979" target="_blank">00:32:59.960</a></span> | <span class="t">GPU and this one can be done also simultaneously because they do not depend on each other</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1985" target="_blank">00:33:05.800</a></span> | <span class="t">So the convolutional calculation can be parallelized</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1989" target="_blank">00:33:09.580</a></span> | <span class="t">but the problem is that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1992" target="_blank">00:33:12.440</a></span> | <span class="t">The the kernel we need to build the kernel for the convolution and building this kernel can be a little</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=1998" target="_blank">00:33:18.680</a></span> | <span class="t">Expensive from a computational point of view, but also from a memory point of view</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2002" target="_blank">00:33:22.200</a></span> | <span class="t">however</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2003" target="_blank">00:33:23.640</a></span> | <span class="t">We can still use the convolutional computation to perform the training</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2007" target="_blank">00:33:27.160</a></span> | <span class="t">Because we can parallelize the training because we already have the input token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2011" target="_blank">00:33:31.240</a></span> | <span class="t">We already have the target so we can compute the output of the model in parallel for all the input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2016" target="_blank">00:33:36.280</a></span> | <span class="t">tokens, even if it's expensive to do it computationally</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2019" target="_blank">00:33:39.740</a></span> | <span class="t">And then we can use the recurrent formulation to inference from this model one token at a time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2025" target="_blank">00:33:45.800</a></span> | <span class="t">And we also know that by just doing this the computation cost for producing one token will always be the same</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2032" target="_blank">00:33:52.840</a></span> | <span class="t">No matter how which token we are producing if it's the first one or the 100th token or the 1000th token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2040" target="_blank">00:34:00.120</a></span> | <span class="t">And this is different from the transformer in which</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2042" target="_blank">00:34:02.680</a></span> | <span class="t">If we want to generate tokens to produce the first token is less expensive than to produce the 100th token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2049" target="_blank">00:34:09.320</a></span> | <span class="t">Because we need to do much more dot products when we generate the 100th token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2054" target="_blank">00:34:14.680</a></span> | <span class="t">So with the KVCache we would do 100 dot products</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2057" target="_blank">00:34:17.800</a></span> | <span class="t">One thing that is worth mentioning is that in the paper they do not use the term d</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2063" target="_blank">00:34:23.720</a></span> | <span class="t">Here when they compute the output and the reason is that this can be thought of as a skip connection</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2070" target="_blank">00:34:30.060</a></span> | <span class="t">Let me show you why</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2071" target="_blank">00:34:31.740</a></span> | <span class="t">So imagine we have our input x which is the input of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2076" target="_blank">00:34:36.540</a></span> | <span class="t">So suppose we have this x this is sent to some black box that we will call state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2082" target="_blank">00:34:42.860</a></span> | <span class="t">That will do this calculation of the state recurrently. So continuously</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2088" target="_blank">00:34:48.880</a></span> | <span class="t">And it will produce an output y</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2092" target="_blank">00:34:52.220</a></span> | <span class="t">But then we can see that this dx of t basically means that we take our input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2097" target="_blank">00:34:57.900</a></span> | <span class="t">We skip the state space model. We multiply it with some number d and we send it directly to the output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2104" target="_blank">00:35:04.940</a></span> | <span class="t">So we do not need to model this d to model the state space</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2109" target="_blank">00:35:09.980</a></span> | <span class="t">Because it does not depend on the state of the system at any time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2114" target="_blank">00:35:14.140</a></span> | <span class="t">And this is why it can be represented as a skip connection. And this is why in the paper they do not mention it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2120" target="_blank">00:35:20.460</a></span> | <span class="t">The analysis that we have done so far on this state space model as I told you before we will consider</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2127" target="_blank">00:35:27.100</a></span> | <span class="t">We for simplicity we are considering that all the parameters are just the single numbers</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2131" target="_blank">00:35:31.500</a></span> | <span class="t">But usually and the input is just a single number and the output is just a single number</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2137" target="_blank">00:35:37.500</a></span> | <span class="t">But usually when we work with language models, especially our input is not a single number</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2142" target="_blank">00:35:42.700</a></span> | <span class="t">but it's a vector because suppose we have a sequence of tokens each token is represented by a vector of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2148" target="_blank">00:35:48.780</a></span> | <span class="t">512 dimensions in the case of the vanilla transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2153" target="_blank">00:35:53.020</a></span> | <span class="t">And maybe 4096 dimensions in the case of llama, for example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2157" target="_blank">00:35:57.500</a></span> | <span class="t">So how can we work with the state space models, but with a vector input and a vector output?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2164" target="_blank">00:36:04.620</a></span> | <span class="t">The idea is that each dimension of the input vector will be managed by an independent state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2172" target="_blank">00:36:12.940</a></span> | <span class="t">So imagine we have an input made up of a vector of 512 tokens</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2177" target="_blank">00:36:17.100</a></span> | <span class="t">512 dimensions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2179" target="_blank">00:36:19.740</a></span> | <span class="t">Which needs to produce an output token of 512 dimensions. We will create one state space model for each dimension</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2186" target="_blank">00:36:26.620</a></span> | <span class="t">So one for the dimension zero one for the dimension one dimension two, etc, etc for all the dimensions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2192" target="_blank">00:36:32.000</a></span> | <span class="t">And all these state space muscles are independent from each other</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2196" target="_blank">00:36:36.220</a></span> | <span class="t">now this idea may look very strange and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2199" target="_blank">00:36:39.820</a></span> | <span class="t">But it's not so strange if you think about the multi-head attention of the transformer because in the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2205" target="_blank">00:36:45.820</a></span> | <span class="t">We also have an input made up of vectors each one representing an embedding of a token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2211" target="_blank">00:36:51.740</a></span> | <span class="t">Suppose we have 512 dimensions for each embedding</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2215" target="_blank">00:36:55.680</a></span> | <span class="t">Then the multi-head attention one basically groups some dimensions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2220" target="_blank">00:37:00.320</a></span> | <span class="t">Suppose in the vanilla transformer we have eight heads</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2224" target="_blank">00:37:04.540</a></span> | <span class="t">So it means that the 512 is divided by eight which means that every</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2229" target="_blank">00:37:09.500</a></span> | <span class="t">Head is managing 64 dimensions and each head is independent from the others</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2235" target="_blank">00:37:15.820</a></span> | <span class="t">And this is so it's if it works for the transformer. It can also work for the state space model and actually it does</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2242" target="_blank">00:37:22.220</a></span> | <span class="t">so</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2244" target="_blank">00:37:24.700</a></span> | <span class="t">the parameters</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2246" target="_blank">00:37:26.060</a></span> | <span class="t">a b c d</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2248" target="_blank">00:37:28.060</a></span> | <span class="t">The input and the y t have now become vectors and they will have the sequence dimension and also the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2255" target="_blank">00:37:35.260</a></span> | <span class="t">D model dimension, which means that we have an input that is made up of suppose 512 dimensions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2262" target="_blank">00:37:42.000</a></span> | <span class="t">Just like in the transformer model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2265" target="_blank">00:37:45.260</a></span> | <span class="t">Now in the recurrent formulation of the state space model we have this matrix a which is quite important</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2271" target="_blank">00:37:51.900</a></span> | <span class="t">because</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2273" target="_blank">00:37:53.740</a></span> | <span class="t">The a matrix in the state space model can be intuitively thought of as a matrix that captures the information of the past state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2281" target="_blank">00:38:01.660</a></span> | <span class="t">So the h t minus one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2283" target="_blank">00:38:03.820</a></span> | <span class="t">To build the new state the h of t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2286" target="_blank">00:38:06.860</a></span> | <span class="t">It also decides how this information is copied forward in time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2292" target="_blank">00:38:12.060</a></span> | <span class="t">So when we produce the output of a state space model at a particular time step for which means for a particular token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2298" target="_blank">00:38:18.860</a></span> | <span class="t">It depends on the state at that time step, but the state at time step t depends on all the previous states</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2306" target="_blank">00:38:26.540</a></span> | <span class="t">So basically this a matrix tells us how the information of the model is conveyed forward in time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2313" target="_blank">00:38:33.420</a></span> | <span class="t">So this h of t</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2315" target="_blank">00:38:35.420</a></span> | <span class="t">Basically captures all the history of the input of the model so far to build the new token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2322" target="_blank">00:38:42.540</a></span> | <span class="t">This means that we need to be very careful about the structure of this a matrix</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2327" target="_blank">00:38:47.740</a></span> | <span class="t">Otherwise, it may not very well capture the history of all the inputs seen so far</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2332" target="_blank">00:38:52.780</a></span> | <span class="t">Which is needed to produce the next token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2335" target="_blank">00:38:55.100</a></span> | <span class="t">And this is very important for language models because the next token generated by the model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2339" target="_blank">00:38:59.660</a></span> | <span class="t">should depend on all the previous tokens, which are the prompt because when you</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2344" target="_blank">00:39:04.220</a></span> | <span class="t">Send a prompt to a language model, which is a list of tokens. The model should attend should</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2350" target="_blank">00:39:10.460</a></span> | <span class="t">Watch all the previous tokens to produce the new one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2352" target="_blank">00:39:12.940</a></span> | <span class="t">And in the case of the state space model, this is taken care of by the matrix a so the structure of this matrix is very</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2360" target="_blank">00:39:20.140</a></span> | <span class="t">important</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2361" target="_blank">00:39:21.260</a></span> | <span class="t">And if you have some background in controls engineering, you may remember that in a state space model the a matrix</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2368" target="_blank">00:39:28.060</a></span> | <span class="t">Also determines the stability of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2370" target="_blank">00:39:30.940</a></span> | <span class="t">Which means that the output of the system may diverge if the system is not stable</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2376" target="_blank">00:39:36.220</a></span> | <span class="t">But if you don't have a background in controls engineering, it doesn't matter</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2379" target="_blank">00:39:39.740</a></span> | <span class="t">So to make the a matrix behave well, the authors chose to use the hippo theory. Let's see how it works</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2385" target="_blank">00:39:45.980</a></span> | <span class="t">To give you an intuition on what the hippo theory does. I will use borrow some the Fourier transformation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2393" target="_blank">00:39:53.420</a></span> | <span class="t">So as you remember the Fourier transformation allow us to decompose a signal</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2398" target="_blank">00:39:58.220</a></span> | <span class="t">So suppose this is our initial signal into a series of sinusoidal functions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2403" target="_blank">00:40:03.180</a></span> | <span class="t">So this one this one and this one such that when we sum all these functions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2409" target="_blank">00:40:09.500</a></span> | <span class="t">Each one with its respective amplitude value you can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2414" target="_blank">00:40:14.380</a></span> | <span class="t">They will rebuild the original signal</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2417" target="_blank">00:40:17.100</a></span> | <span class="t">And we do something similar also in the state space model with the hippo theory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2422" target="_blank">00:40:22.640</a></span> | <span class="t">But instead of using sinusoidal functions, we use the Legendre polynomials</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2428" target="_blank">00:40:28.540</a></span> | <span class="t">With the hippo theory we build the a matrix in such a way that it approximates all the input signals so far</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2435" target="_blank">00:40:35.980</a></span> | <span class="t">So let me show you here. So imagine this is our input signal and it evolves over time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2442" target="_blank">00:40:42.140</a></span> | <span class="t">So x of t you can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2444" target="_blank">00:40:44.220</a></span> | <span class="t">The goal of the a matrix is to capture information from this input signal and convey it forward for the next</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2452" target="_blank">00:40:52.780</a></span> | <span class="t">State so it captures the history of all these signals</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2456" target="_blank">00:40:56.940</a></span> | <span class="t">Suppose this is our state if we use the state to rebuild the original signal using the hippo theory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2463" target="_blank">00:41:03.340</a></span> | <span class="t">We will have an output. So the rebuild the reconstructed signal that is very good</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2469" target="_blank">00:41:09.580</a></span> | <span class="t">Approximate well approximated for the more recent time steps and not so good</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2475" target="_blank">00:41:15.580</a></span> | <span class="t">Well approximated for the previous time step. So as you can see this approximation here is not very</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2481" target="_blank">00:41:21.180</a></span> | <span class="t">Good, if you compare it with the original signal here, but the more recent is very well reconstructed</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2487" target="_blank">00:41:27.420</a></span> | <span class="t">You can see here and this is what the hippo matrix does it reconstructs build a state space representation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2493" target="_blank">00:41:33.120</a></span> | <span class="t">that captures well the information of recent tokens and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2497" target="_blank">00:41:37.900</a></span> | <span class="t">Decays the information of the past token using some reasoning very similar to the exponentially moving average</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2505" target="_blank">00:41:45.280</a></span> | <span class="t">And this is very important for language modeling because in language models</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2510" target="_blank">00:41:50.300</a></span> | <span class="t">We have a prompt made up of tokens and we need to produce the next token</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2514" target="_blank">00:41:54.460</a></span> | <span class="t">So we need to build a hidden state because the hidden state will determine the output of the system</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2519" target="_blank">00:41:59.660</a></span> | <span class="t">So the next token so we need to build a hidden state that captures very well</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2523" target="_blank">00:42:03.500</a></span> | <span class="t">Information about the local context and it we can afford to lose some information about the global context. So information about</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2530" target="_blank">00:42:10.940</a></span> | <span class="t">Tokens that are very far from the one we are producing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2536" target="_blank">00:42:16.540</a></span> | <span class="t">And in the in a paper called efficiently modeling long sequences with structured state spaces</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2542" target="_blank">00:42:22.460</a></span> | <span class="t">Which is basically the paper of the S4 model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2545" target="_blank">00:42:25.020</a></span> | <span class="t">The author says that just initializing the A matrix with the hippo matrix we can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2551" target="_blank">00:42:31.980</a></span> | <span class="t">so this is how to build the hippo matrix, which is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2554" target="_blank">00:42:34.540</a></span> | <span class="t">basically an n by n matrix in which</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2557" target="_blank">00:42:37.340</a></span> | <span class="t">All the values above the principal diagonal here are zero and other values are computed as follows</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2564" target="_blank">00:42:44.380</a></span> | <span class="t">So for the diagonal they are computed as n plus one which n is the row and the k is the column</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2570" target="_blank">00:42:50.860</a></span> | <span class="t">If we just build the A matrix like this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2575" target="_blank">00:42:55.900</a></span> | <span class="t">It will result in a very big increase in performance of the model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2580" target="_blank">00:43:00.940</a></span> | <span class="t">Why? because the A matrix is the one that is responsible for capturing information about the previous state and carrying it over to the new state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2588" target="_blank">00:43:08.860</a></span> | <span class="t">So we want to carry the information well in the new state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2593" target="_blank">00:43:13.340</a></span> | <span class="t">So that the h of t which will become a vector</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2598" target="_blank">00:43:18.540</a></span> | <span class="t">If we have a multi-dimensional state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2602" target="_blank">00:43:22.540</a></span> | <span class="t">Then this h of t captures very well the information of all the previous inputs so that we can produce the next output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2610" target="_blank">00:43:30.300</a></span> | <span class="t">Okay, now it's time to talk about Mamba and let's talk about the motivation that led to the building of Mamba</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2617" target="_blank">00:43:37.820</a></span> | <span class="t">And in the paper the the authors they describe two tasks on which the vanilla state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2623" target="_blank">00:43:43.340</a></span> | <span class="t">So the state space model that we have described up to now or even the S4 model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2627" target="_blank">00:43:47.820</a></span> | <span class="t">Which is the structured state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2629" target="_blank">00:43:49.740</a></span> | <span class="t">Which is basically just the state space model with a very rigid structure on the A matrix like the one we saw before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2635" target="_blank">00:43:55.820</a></span> | <span class="t">So these two models they do not perform well on two specific tasks</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2639" target="_blank">00:43:59.900</a></span> | <span class="t">One is the selective copying and one is the induction heads</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2643" target="_blank">00:44:03.580</a></span> | <span class="t">So let's introduce these tasks the copying task basically means that we have some input tokens. So this one's here blue</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2651" target="_blank">00:44:11.180</a></span> | <span class="t">orange red and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2653" target="_blank">00:44:13.740</a></span> | <span class="t">Green and the model has to produce the same outputs but time shifted</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2658" target="_blank">00:44:18.480</a></span> | <span class="t">And this actually can be done by the vanilla state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2662" target="_blank">00:44:22.460</a></span> | <span class="t">Because it can be actually done with a simple convolution and the convolution can learn the time shifting that we are doing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2671" target="_blank">00:44:31.420</a></span> | <span class="t">However, the selective copying which means that we have the some input tokens, for example, the blue white white</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2678" target="_blank">00:44:38.300</a></span> | <span class="t">orange red</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2681" target="_blank">00:44:41.180</a></span> | <span class="t">and then green cannot and the model needs to produce only the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2685" target="_blank">00:44:45.820</a></span> | <span class="t">Colored tokens so not the white tokens</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2688" target="_blank">00:44:48.780</a></span> | <span class="t">This one cannot be done by the vanilla state space model because the vanilla spaces model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2694" target="_blank">00:44:54.460</a></span> | <span class="t">That is not content cannot do content aware reasoning because the parameters of the model are the same for every step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2700" target="_blank">00:45:00.940</a></span> | <span class="t">So the same for every token, so it will treat each token equally</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2704" target="_blank">00:45:04.860</a></span> | <span class="t">so it cannot say distinguish between</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2707" target="_blank">00:45:07.500</a></span> | <span class="t">The blue token and the white token and just ignore the white one and keep the blue the the colored one and not the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2714" target="_blank">00:45:14.460</a></span> | <span class="t">the white ones</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2716" target="_blank">00:45:16.540</a></span> | <span class="t">So to give you an intuition of how what this could mean, for example, imagine we are given a twitter</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2722" target="_blank">00:45:22.620</a></span> | <span class="t">Comment on twitter and we want to rewrite this comment by removing all the bad words</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2728" target="_blank">00:45:28.220</a></span> | <span class="t">So all the white tokens you can see here and this one cannot be done by the state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2732" target="_blank">00:45:32.780</a></span> | <span class="t">Because the parameters a b c and d are the same for each input and they cannot do they cannot change for each particular input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2740" target="_blank">00:45:40.380</a></span> | <span class="t">The second task on which the state space model have a difficulty is the induction head which means that the model needs to recall</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2749" target="_blank">00:45:49.340</a></span> | <span class="t">information from the previous</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2751" target="_blank">00:45:51.640</a></span> | <span class="t">Inputs to build the current input and they show for example this example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2756" target="_blank">00:45:56.300</a></span> | <span class="t">so for example, every time the model sees the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2758" target="_blank">00:45:58.380</a></span> | <span class="t">The black token it should output the blue token by recalling what it has seen before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2764" target="_blank">00:46:04.540</a></span> | <span class="t">But because the model cannot use a content aware reasoning it cannot do perform. Well this task</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2770" target="_blank">00:46:10.860</a></span> | <span class="t">and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2773" target="_blank">00:46:13.740</a></span> | <span class="t">This is the motivation that led to the creation of mamba</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2776" target="_blank">00:46:16.780</a></span> | <span class="t">And this is the reference in the paper in which they talk about these two tasks</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2781" target="_blank">00:46:21.020</a></span> | <span class="t">So from the recurrent view the recursive dynamics</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2783" target="_blank">00:46:23.840</a></span> | <span class="t">So the transition in the because of the a and the b matrix cannot let them select the correct information from the current context</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2791" target="_blank">00:46:31.340</a></span> | <span class="t">Because the a and b metrics are the same for each input token and also from the convolutional view</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2797" target="_blank">00:46:37.340</a></span> | <span class="t">It it is known that the model is able to solve the copying task because it can learn the time shift</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2803" target="_blank">00:46:43.660</a></span> | <span class="t">but they have a difficulty with the selective</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2807" target="_blank">00:46:47.020</a></span> | <span class="t">Copying task because the parameters of the model are the same for each input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2811" target="_blank">00:46:51.740</a></span> | <span class="t">So they do not know how to treat differently a particular input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2815" target="_blank">00:46:55.660</a></span> | <span class="t">Now let's talk about the innovation of mamba and how it differs from the state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2823" target="_blank">00:47:03.020</a></span> | <span class="t">Let's first review. What is the algorithm of the state space model?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2826" target="_blank">00:47:06.620</a></span> | <span class="t">So the state space model basically has an input and it has to produce an output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2831" target="_blank">00:47:11.180</a></span> | <span class="t">The input is this one. So it's a tensor of b l and d dimension</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2836" target="_blank">00:47:16.460</a></span> | <span class="t">which is a batch dimension sequence dimension and the d model and this is the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2840" target="_blank">00:47:20.620</a></span> | <span class="t">Exactly the same as the transformer because we have a batch of prompts</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2844" target="_blank">00:47:24.780</a></span> | <span class="t">Each prompt is made up of l tokens</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2847" target="_blank">00:47:27.340</a></span> | <span class="t">Which is our sequence length and each token is made up of a vector of d model dimension</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2851" target="_blank">00:47:31.980</a></span> | <span class="t">Which is our d here and it has to produce an output of the same dimension</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2856" target="_blank">00:47:36.940</a></span> | <span class="t">Just like the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2858" target="_blank">00:47:38.620</a></span> | <span class="t">We have an a matrix which is a matrix of parameters that indicates how to copy the previous state into the new state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2866" target="_blank">00:47:46.060</a></span> | <span class="t">And we we model the state as a vector of n tokens. So this will be a vector</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2872" target="_blank">00:47:52.700</a></span> | <span class="t">of n tokens</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2875" target="_blank">00:47:55.180</a></span> | <span class="t">So the a matrix is d by n which is basically because we have a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2881" target="_blank">00:48:01.100</a></span> | <span class="t">when we have an input vector made up of d dimensions, we have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2885" target="_blank">00:48:05.880</a></span> | <span class="t">d</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2887" target="_blank">00:48:07.880</a></span> | <span class="t">State space models independent from each other one for each dimension just like I saw before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2893" target="_blank">00:48:13.240</a></span> | <span class="t">So we have this parameter matrix is a d by n</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2896" target="_blank">00:48:16.120</a></span> | <span class="t">This b matrix is also d by n. The c matrix is also d by n</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2901" target="_blank">00:48:21.720</a></span> | <span class="t">And the delta is the step size of the discretization which is learned by the model as I showed before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2908" target="_blank">00:48:28.280</a></span> | <span class="t">So we don't decide it. We just let the model learn this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2911" target="_blank">00:48:31.880</a></span> | <span class="t">Step size and because we have a d state space model because our input vector is d dimensional</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2918" target="_blank">00:48:38.200</a></span> | <span class="t">So we have a d number of delta</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2920" target="_blank">00:48:40.760</a></span> | <span class="t">And to discretize we just apply the formula that we saw before so depending which</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2927" target="_blank">00:48:47.160</a></span> | <span class="t">Discretization rule we are using if we use the Euler method or we use the zero order hold in the case of mamba</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2933" target="_blank">00:48:53.400</a></span> | <span class="t">They use the zero order hold method</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2935" target="_blank">00:48:55.800</a></span> | <span class="t">And then we have this discretized parameter</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2938" target="_blank">00:48:58.040</a></span> | <span class="t">So a bar and b bar and we can run the ssm as a recurrence or a convolution depending if we are</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2944" target="_blank">00:49:04.840</a></span> | <span class="t">Training it or inferencing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2947" target="_blank">00:49:07.240</a></span> | <span class="t">So when we are training it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2948" target="_blank">00:49:08.280</a></span> | <span class="t">We run it as a convolution using building the kernel like I showed you before and running it on the input like I showed before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2954" target="_blank">00:49:14.120</a></span> | <span class="t">Or as a recurrence using the formula we can see here. So this formulation here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2959" target="_blank">00:49:19.000</a></span> | <span class="t">So we compute the next step the next state using the previous state and then we use each state to build the output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2965" target="_blank">00:49:25.400</a></span> | <span class="t">In the case of mamba they make the state space model selective which means that the parameters of the model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2973" target="_blank">00:49:33.720</a></span> | <span class="t">Are changed for each input token. Let's see. The input is still bld. So we have a sequence of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2982" target="_blank">00:49:42.680</a></span> | <span class="t">Batch of prompts each prompt is made of l tokens. Each token is made up of d dimensions and the output has the same shape</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2989" target="_blank">00:49:49.960</a></span> | <span class="t">Then we have the a matrix which is d by n</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2993" target="_blank">00:49:53.560</a></span> | <span class="t">The b matrix basically is modified</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=2996" target="_blank">00:49:56.680</a></span> | <span class="t">By a linear layer this sb and this sb will project the d dimension into the n dimension. You can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3004" target="_blank">00:50:04.600</a></span> | <span class="t">This means that basically now the b matrix is not the same for all input tokens because now we have this l dimension here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3012" target="_blank">00:50:12.360</a></span> | <span class="t">Which means that for every input token of the each batch</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3016" target="_blank">00:50:16.040</a></span> | <span class="t">We will have a different b matrix</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3018" target="_blank">00:50:18.520</a></span> | <span class="t">And the same goes for the c matrix you can see here and the same goes for the delta you can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3025" target="_blank">00:50:25.240</a></span> | <span class="t">For each input token, we will have a different delta</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3028" target="_blank">00:50:28.920</a></span> | <span class="t">And the discretized</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3032" target="_blank">00:50:32.280</a></span> | <span class="t">Matrices have this dimension. So bld n</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3035" target="_blank">00:50:35.240</a></span> | <span class="t">And we can run the state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3038" target="_blank">00:50:38.920</a></span> | <span class="t">However, because now the model is not a time invariant anymore because the parameters of the model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3045" target="_blank">00:50:45.800</a></span> | <span class="t">Change for each input. So for each token for each step for each time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3051" target="_blank">00:50:51.640</a></span> | <span class="t">We can only run it as a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3054" target="_blank">00:50:54.120</a></span> | <span class="t">Recurrence so we can only apply this formulation here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3057" target="_blank">00:50:57.240</a></span> | <span class="t">We cannot compute it with the convolution anymore because the kernel will not be fixed</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3062" target="_blank">00:51:02.200</a></span> | <span class="t">Because before because the parameters of the model are fixed for all the inputs</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3066" target="_blank">00:51:06.680</a></span> | <span class="t">We can just build a kernel and run it for all the inputs</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3069" target="_blank">00:51:09.720</a></span> | <span class="t">but now for every input we should use a different kernel so we cannot compute it as a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3075" target="_blank">00:51:15.000</a></span> | <span class="t">Convolution we are only forced to compute it as a recurrence</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3079" target="_blank">00:51:19.660</a></span> | <span class="t">And</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3083" target="_blank">00:51:23.240</a></span> | <span class="t">Have you noticed that the authors talk about this scan operation you can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3087" target="_blank">00:51:27.960</a></span> | <span class="t">So what is this scan operation to when evaluating the model as a recurrence? Let's talk about it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3096" target="_blank">00:51:36.440</a></span> | <span class="t">So if you have ever done competitive programming you are familiar with the prefix sum array</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3101" target="_blank">00:51:41.640</a></span> | <span class="t">Which is an array calculated sequentially such that the value at each position indicates the sum of all the previous values</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3109" target="_blank">00:51:49.240</a></span> | <span class="t">We can easily compute it with the for loop in linear time</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3113" target="_blank">00:51:53.320</a></span> | <span class="t">So imagine we have this initial array</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3115" target="_blank">00:51:55.720</a></span> | <span class="t">We can calculate the prefix sum as like this the first value is equal to the first value</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3121" target="_blank">00:52:01.000</a></span> | <span class="t">the second value is computed as the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3124" target="_blank">00:52:04.040</a></span> | <span class="t">Previous value of this array. So this one plus the current value of the initial array. So</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3129" target="_blank">00:52:09.480</a></span> | <span class="t">Wait, this one is equal to this one plus this one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3133" target="_blank">00:52:13.160</a></span> | <span class="t">And this one is computed using the previous value plus the current value of the initial array</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3138" target="_blank">00:52:18.600</a></span> | <span class="t">And this one is computed using the previous value plus the current value of the initial array</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3143" target="_blank">00:52:23.400</a></span> | <span class="t">And this one is computed using the previous value plus the current</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3147" target="_blank">00:52:27.320</a></span> | <span class="t">element of the array</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3149" target="_blank">00:52:29.880</a></span> | <span class="t">Such that each item of this prefix sum indicates the sum of all the items of the initial array up to that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3156" target="_blank">00:52:36.840</a></span> | <span class="t">element. So the number 32 is the result of 10 plus 7 plus 6 plus 9</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3165" target="_blank">00:52:45.160</a></span> | <span class="t">The scan operation refers to computing an array like the prefix sum in which each value can be computed using the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3174" target="_blank">00:52:54.120</a></span> | <span class="t">previously computed value and the current input value</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3178" target="_blank">00:52:58.840</a></span> | <span class="t">And the recurrent formula of the state space model can also be thought as a scan operation in which each state</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3185" target="_blank">00:53:05.800</a></span> | <span class="t">is the sum of the previous state multiplied by an A matrix plus</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3190" target="_blank">00:53:10.600</a></span> | <span class="t">The current input multiplied by the B matrix</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3193" target="_blank">00:53:13.980</a></span> | <span class="t">So if the model input is X0, X1, X2, X3, X4 and X5</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3199" target="_blank">00:53:19.400</a></span> | <span class="t">We can compute for example H0 using only X0</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3203" target="_blank">00:53:23.640</a></span> | <span class="t">And then we can compute H1 using the previously computed value plus the current input each one multiplied by the A matrix and the B matrix</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3211" target="_blank">00:53:31.960</a></span> | <span class="t">Then we can compute H2 using H1</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3215" target="_blank">00:53:35.400</a></span> | <span class="t">multiplied by A plus X2 multiplied by B and H3 can be computed as H2</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3222" target="_blank">00:53:42.680</a></span> | <span class="t">multiplied by A plus X3 multiplied by B, etc, etc, etc</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3228" target="_blank">00:53:48.680</a></span> | <span class="t">So to generate the input we just multiply it H_k with the C matrix to generate the output token K</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3235" target="_blank">00:53:55.800</a></span> | <span class="t">So if we have this scan output, so if we build a</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3239" target="_blank">00:53:59.720</a></span> | <span class="t">Array like this one, so this array you can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3243" target="_blank">00:54:03.560</a></span> | <span class="t">We can easily compute the output of the model for each time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3248" target="_blank">00:54:08.200</a></span> | <span class="t">By just multiplying each of this value with the C matrix</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3251" target="_blank">00:54:11.880</a></span> | <span class="t">So we multiply it by C multiplied by C and this one here multiplied by C to compute</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3257" target="_blank">00:54:17.400</a></span> | <span class="t">Y0</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3259" target="_blank">00:54:19.400</a></span> | <span class="t">This is Y1</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3261" target="_blank">00:54:21.080</a></span> | <span class="t">This is Y2, etc, etc, etc</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3264" target="_blank">00:54:24.120</a></span> | <span class="t">Now what if I told you that the scan operation that I have shown you can be parallelized</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3271" target="_blank">00:54:31.580</a></span> | <span class="t">Of course, you will not believe me because the scan operation is one of those operations that naturally looks like a sequence</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3277" target="_blank">00:54:37.560</a></span> | <span class="t">So to compute the current value, I need to have the previous value plus the current input</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3282" target="_blank">00:54:42.760</a></span> | <span class="t">So how can I parallelize an operation like this? Actually, it can be parallelized</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3287" target="_blank">00:54:47.100</a></span> | <span class="t">As long as the operations that we are doing are associative</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3290" target="_blank">00:54:50.780</a></span> | <span class="t">Means that they benefit from the associative property</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3293" target="_blank">00:54:53.800</a></span> | <span class="t">Now if you remember from elementary school or middle school when they teach you about the properties of the addition and the multiplication</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3300" target="_blank">00:55:00.460</a></span> | <span class="t">You may recall that the associative property means that if you have</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3304" target="_blank">00:55:04.120</a></span> | <span class="t">The operation done on three operands, for example A multiplied B multiplied C</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3309" target="_blank">00:55:09.400</a></span> | <span class="t">It does not matter the order in which you do these operations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3312" target="_blank">00:55:12.780</a></span> | <span class="t">So it does not matter where you put the parentheses, the result will be the same</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3316" target="_blank">00:55:16.520</a></span> | <span class="t">So you can do A multiplied by B and then the result multiplied by C</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3319" target="_blank">00:55:19.960</a></span> | <span class="t">Or you can do A multiplied by the result of B multiplied by C</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3323" target="_blank">00:55:23.560</a></span> | <span class="t">So this is the associative property</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3325" target="_blank">00:55:25.800</a></span> | <span class="t">So as long as the operations that we are doing have this property, then we can parallelize the scan operation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3331" target="_blank">00:55:31.960</a></span> | <span class="t">I want to show you how to actually do it practically</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3336" target="_blank">00:55:36.040</a></span> | <span class="t">So imagine the initial array is this we can create multiple threads each one computing</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3342" target="_blank">00:55:42.120</a></span> | <span class="t">In parallel a sum. So for example, we have a we can have for example this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3347" target="_blank">00:55:47.800</a></span> | <span class="t">Okay, this is actually the picture I took from wikipedia and it's made for 16 input array</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3354" target="_blank">00:55:54.120</a></span> | <span class="t">But imagine we have eight threads</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3356" target="_blank">00:55:56.280</a></span> | <span class="t">The first thread will compute the summation of the first two elements</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3359" target="_blank">00:55:59.400</a></span> | <span class="t">the second thread will compute the summation of the third and the fourth the third of the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3364" target="_blank">00:56:04.680</a></span> | <span class="t">Fourth the fifth and the sixth etc, etc. And then we use the result of this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3368" target="_blank">00:56:08.760</a></span> | <span class="t">summation to compute the next step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3371" target="_blank">00:56:11.640</a></span> | <span class="t">And then in parallel and then we use it to compute the next step in parallel and then to compute the next step in parallel</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3380" target="_blank">00:56:20.440</a></span> | <span class="t">This is called the sweep down if I remember correctly and then we have a sweep up operation to rebuild all the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3387" target="_blank">00:56:27.240</a></span> | <span class="t">Values that we didn't compute. So for example, this value here is not computed until the last step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3393" target="_blank">00:56:33.400</a></span> | <span class="t">now by</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3395" target="_blank">00:56:35.160</a></span> | <span class="t">By doing a parallel scan</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3396" target="_blank">00:56:36.680</a></span> | <span class="t">Basically, we can decrease the time complexity of the scan operation from a sequence or so o of n</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3403" target="_blank">00:56:43.080</a></span> | <span class="t">It's reduced to o of n divided by t where t is the number of parallel threads that are computing this operation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3410" target="_blank">00:56:50.280</a></span> | <span class="t">And in my github repository, I have also put a excel file that shows you how to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3416" target="_blank">00:56:56.440</a></span> | <span class="t">How this scan operation is computed step by step. So I actually show you all the intermediate steps. So if you want to</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3423" target="_blank">00:57:03.480</a></span> | <span class="t">Understand how this works</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3425" target="_blank">00:57:05.480</a></span> | <span class="t">Now that we know that this parallel scan can be done in parallel, this is actually what the authors do. They also do the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3432" target="_blank">00:57:12.360</a></span> | <span class="t">computation of the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3435" target="_blank">00:57:15.080</a></span> | <span class="t">Recurrence to calculate the output of the model in parallel to reduce its time complexity</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3440" target="_blank">00:57:20.220</a></span> | <span class="t">Basically since Mamba cannot be evaluated using a convolution because it's time varying</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3445" target="_blank">00:57:25.960</a></span> | <span class="t">So it means that the parameters of the model are different for each time step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3450" target="_blank">00:57:30.120</a></span> | <span class="t">Our only way of computing the output is to use the recurrent formulation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3453" target="_blank">00:57:33.800</a></span> | <span class="t">But thanks to the parallel scan algorithm, this can be parallelized to reduce its time complexity</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3458" target="_blank">00:57:38.620</a></span> | <span class="t">The authors also indicate some techniques that they have used to make this algorithm faster</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3463" target="_blank">00:57:43.480</a></span> | <span class="t">The first technique that they show you is the kernel fusion</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3467" target="_blank">00:57:47.000</a></span> | <span class="t">The second is the parallel scan which I have already shown and then we have the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3470" target="_blank">00:57:50.840</a></span> | <span class="t">Circumputation of the activations that we will show later. So let's see all these techniques one by one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3476" target="_blank">00:57:56.280</a></span> | <span class="t">But first let's see how the memory hierarchy of the GPU works</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3479" target="_blank">00:57:59.960</a></span> | <span class="t">The GPU basically it's a very fast calculator. So it's a very very very big</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3486" target="_blank">00:58:06.200</a></span> | <span class="t">computational unit that can do a lot of operations in parallel</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3491" target="_blank">00:58:11.080</a></span> | <span class="t">And it has two main memories</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3493" target="_blank">00:58:13.880</a></span> | <span class="t">The one that you are mostly familiar with, the one that you actually check when you buy a GPU is called the DRAM</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3500" target="_blank">00:58:20.600</a></span> | <span class="t">So it's the high bandwidth memory and it's in the order of gigabytes</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3504" target="_blank">00:58:24.520</a></span> | <span class="t">And then the GPU also has a smaller memory, a local memory that is called the SRAM</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3509" target="_blank">00:58:29.560</a></span> | <span class="t">The difference between the two is that first of all the SRAM is much much much much much smaller</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3514" target="_blank">00:58:34.600</a></span> | <span class="t">It's in the order of megabytes</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3516" target="_blank">00:58:36.680</a></span> | <span class="t">And however, this is where the GPU will do the computation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3520" target="_blank">00:58:40.600</a></span> | <span class="t">So when the GPU needs to do some matrix multiplication</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3522" target="_blank">00:58:42.920</a></span> | <span class="t">It will first of all copy the information from the high bandwidth memory to the SRAM</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3527" target="_blank">00:58:47.020</a></span> | <span class="t">Then the core of the GPU will access the information in the SRAM to do the computation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3533" target="_blank">00:58:53.720</a></span> | <span class="t">And then the result will be saved back to this high bandwidth memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3537" target="_blank">00:58:57.080</a></span> | <span class="t">and</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3539" target="_blank">00:58:59.400</a></span> | <span class="t">Actually, if we check the data sheet of a GPU, in this case, this is the NVIDIA A100</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3544" target="_blank">00:59:04.300</a></span> | <span class="t">You will see that the GPU is very fast at computing operations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3549" target="_blank">00:59:09.320</a></span> | <span class="t">But the copying of information from the SRAM to the DRAM is not very fast, not as fast as computing operations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3556" target="_blank">00:59:16.940</a></span> | <span class="t">So as you can see here, for example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3559" target="_blank">00:59:19.560</a></span> | <span class="t">The copy speed of the copying speed is much slower</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3565" target="_blank">00:59:25.160</a></span> | <span class="t">So this is like two terabytes per second compared to the number of operations that the GPU can do</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3570" target="_blank">00:59:30.120</a></span> | <span class="t">In this case, it can do 20 tera floating point operations per second of 32 bit</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3576" target="_blank">00:59:36.440</a></span> | <span class="t">So this parameter here is basically 40 times faster than this parameter here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3582" target="_blank">00:59:42.360</a></span> | <span class="t">This also means that when we create an algorithm that runs on the GPU, so ECUDA kernel</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3588" target="_blank">00:59:48.740</a></span> | <span class="t">Sometimes the kernel may run slowly not because we are doing a lot of operations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3593" target="_blank">00:59:53.940</a></span> | <span class="t">But maybe because we are copying a lot of stuff around which results in a slow overall computation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3599" target="_blank">00:59:59.800</a></span> | <span class="t">And if this happens, we see that our operation is I/O bound because it's bounded by the I/O speed, by the copying speed</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3607" target="_blank">01:00:07.300</a></span> | <span class="t">Not by the computation speed of the GPU</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3609" target="_blank">01:00:09.460</a></span> | <span class="t">Now in the authors, they exploit this different hierarchy of the GPU to make their algorithm</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3616" target="_blank">01:00:16.900</a></span> | <span class="t">So the selective scan faster. So the main idea is to leverage the properties of modern accelerators</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3622" target="_blank">01:00:22.740</a></span> | <span class="t">So the GPU to maximize the to materialize the state edge. So the hidden state only in more</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3629" target="_blank">01:00:29.380</a></span> | <span class="t">Efficient levels of the memory hierarchy. So only in the SRAM, so the smaller memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3634" target="_blank">01:00:34.420</a></span> | <span class="t">Concretely instead of preparing the scan input because they compute the recurrence as a scan operation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3640" target="_blank">01:00:40.340</a></span> | <span class="t">Just like I showed you before. So the scan input is what is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3643" target="_blank">01:00:43.700</a></span> | <span class="t">batch</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3646" target="_blank">01:00:46.340</a></span> | <span class="t">the sequence length is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3648" target="_blank">01:00:48.340</a></span> | <span class="t">The</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3651" target="_blank">01:00:51.540</a></span> | <span class="t">Size, the D model, so the size of the input vector and N</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3654" target="_blank">01:00:54.660</a></span> | <span class="t">In the GPU high bandwidth memory, so in the DRAM, they load all the parameter of the state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3661" target="_blank">01:01:01.860</a></span> | <span class="t">So the delta, the A matrix, the B matrix, and the C matrix directly from the highest</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3666" target="_blank">01:01:06.100</a></span> | <span class="t">Bandwidth memory, so the DRAM, into the fast SRAM. They perform the discretization in the SRAM</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3673" target="_blank">01:01:13.140</a></span> | <span class="t">The recurrence also, so the scan operation is also done in this SRAM and finally the result of this scan is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3679" target="_blank">01:01:19.700</a></span> | <span class="t">computed back to the high bandwidth memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3682" target="_blank">01:01:22.900</a></span> | <span class="t">And they also make use of what is known as a kernel fusion</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3688" target="_blank">01:01:28.660</a></span> | <span class="t">So what is kernel fusion? When we perform a tensor operation, our deep learning framework</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3694" target="_blank">01:01:34.420</a></span> | <span class="t">So PyTorch, it will load the tensor. Suppose we are doing a matrix multiplication. It will load the tensor from the fast memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3702" target="_blank">01:01:42.900</a></span> | <span class="t">From the slow memory to the fast memory. So from the DRAM to the SRAM of the GPU</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3707" target="_blank">01:01:47.460</a></span> | <span class="t">It will perform the operation, for example the matrix multiplication, and then it will save back the result</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3712" target="_blank">01:01:52.580</a></span> | <span class="t">From the SRAM to the DRAM. So from the SRAM to the high bandwidth memory of the GPU</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3717" target="_blank">01:01:57.860</a></span> | <span class="t">However, what if we do three operations on the same tensor in sequence?</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3723" target="_blank">01:02:03.620</a></span> | <span class="t">The deep learning framework will do something like this. So it will load first of all the tensor from the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3730" target="_blank">01:02:10.260</a></span> | <span class="t">High bandwidth memory to the SRAM. It will compute the first operation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3733" target="_blank">01:02:13.700</a></span> | <span class="t">Which means calling the CUDA kernel associated with the first operation and then save the result back to the high bandwidth memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3740" target="_blank">01:02:20.580</a></span> | <span class="t">Then it will load again the result of the previous computation from the high bandwidth memory into the fast memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3746" target="_blank">01:02:26.500</a></span> | <span class="t">compute the second operation which means</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3748" target="_blank">01:02:28.900</a></span> | <span class="t">Launching the second CUDA kernel associated with this operation and then it will save the result of this operation back to the high bandwidth memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3756" target="_blank">01:02:36.100</a></span> | <span class="t">then it will</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3758" target="_blank">01:02:38.740</a></span> | <span class="t">Load the result of the previous computation again from the high bandwidth memory into the fast memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3763" target="_blank">01:02:43.700</a></span> | <span class="t">compute the third operation and then save back the result into the high bandwidth memory. As you can see</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3769" target="_blank">01:02:49.620</a></span> | <span class="t">the total time is occupied in this case when we have three operations in sequence is</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3775" target="_blank">01:02:55.460</a></span> | <span class="t">occupied by the copying operations that we are performing from the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3778" target="_blank">01:02:58.900</a></span> | <span class="t">high bandwidth memory to the fast memory and from the fast memory back to the high bandwidth memory because we know that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3785" target="_blank">01:03:05.300</a></span> | <span class="t">The GPUs are relatively slow at copying</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3787" target="_blank">01:03:07.620</a></span> | <span class="t">data instead of computing operations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3790" target="_blank">01:03:10.760</a></span> | <span class="t">So kernel fusion means that to make a sequence of operations faster</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3795" target="_blank">01:03:15.300</a></span> | <span class="t">We can fuse all these CUDA kernels</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3797" target="_blank">01:03:17.700</a></span> | <span class="t">So the three operations that we are doing in sequence into one custom CUDA kernel such that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3803" target="_blank">01:03:23.220</a></span> | <span class="t">We don't copy the intermediate results to the high bandwidth memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3807" target="_blank">01:03:27.460</a></span> | <span class="t">But we keep doing these operations in the fast memory until we have done all these three computations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3812" target="_blank">01:03:32.420</a></span> | <span class="t">And then only the last result is saved into the high bandwidth memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3816" target="_blank">01:03:36.180</a></span> | <span class="t">This speeds up the overall computation because we don't have the intermediate copy operations</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3822" target="_blank">01:03:42.120</a></span> | <span class="t">Because they would result in an I/O bound</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3824" target="_blank">01:03:44.820</a></span> | <span class="t">algorithm</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3827" target="_blank">01:03:47.920</a></span> | <span class="t">Okay, the last innovation of this selective scan algorithm is the recomputation of the activations, let's see what is it</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3835" target="_blank">01:03:55.060</a></span> | <span class="t">So when we train a deep learning model, this model gets converted into a computation graph</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3840" target="_blank">01:04:00.580</a></span> | <span class="t">When we perform a back propagation in order to calculate the gradients at each node of this computation graph</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3846" target="_blank">01:04:06.340</a></span> | <span class="t">We need to cache the output values of each node that we have done during the forward step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3851" target="_blank">01:04:11.700</a></span> | <span class="t">So imagine we have a very simple model like the one I show you here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3855" target="_blank">01:04:15.380</a></span> | <span class="t">Let me show with a pointer. So this model basically computes the output using just a linear operation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3861" target="_blank">01:04:21.940</a></span> | <span class="t">So x1 is multiplied by this</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3863" target="_blank">01:04:23.940</a></span> | <span class="t">Parameter w1 plus x2 multiplied by this parameter w2 plus a bias</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3870" target="_blank">01:04:30.260</a></span> | <span class="t">Suppose we have done the forward process and it has produced at each node its own value</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3874" target="_blank">01:04:34.900</a></span> | <span class="t">During the back propagation our goal is to calculate the gradient of the loss function with respect to each parameter</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3882" target="_blank">01:04:42.840</a></span> | <span class="t">Here so with respect to w1 with respect to w2 and with respect to the bias</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3888" target="_blank">01:04:48.020</a></span> | <span class="t">to compute the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3890" target="_blank">01:04:50.500</a></span> | <span class="t">The gradient of the loss function with respect to the w1 for example, I show you the step here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3897" target="_blank">01:04:57.060</a></span> | <span class="t">And to compute this gradient we need to also compute the gradient of all the intermediate nodes</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3902" target="_blank">01:05:02.900</a></span> | <span class="t">And to compute the gradient of the intermediate nodes</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3906" target="_blank">01:05:06.100</a></span> | <span class="t">We need to have the values of the activations of each node that we had during the forward step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3911" target="_blank">01:05:11.940</a></span> | <span class="t">So for example to compute the gradient of the loss function with respect to this node y_pred</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3916" target="_blank">01:05:16.900</a></span> | <span class="t">Which result in the expression 2 multiplied by y_pred minus 2 multiplied by target. We need to cache the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3924" target="_blank">01:05:24.340</a></span> | <span class="t">Value y_pred that we had during the forward step</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3928" target="_blank">01:05:28.020</a></span> | <span class="t">And these activations actually can occupy a lot of memory in a very big network. And this is why in the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3934" target="_blank">01:05:34.660</a></span> | <span class="t">in the paper they talk about</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3937" target="_blank">01:05:37.780</a></span> | <span class="t">Recomputing them. So since caching the activations and then reusing them during back propagation means that we need to save them</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3946" target="_blank">01:05:46.340</a></span> | <span class="t">To the high bandwidth memory. So the slow memory and then copy back them from the slow memory during back propagation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3952" target="_blank">01:05:52.900</a></span> | <span class="t">It may be faster to just recompute them during back propagation because maybe the recomputation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3957" target="_blank">01:05:57.560</a></span> | <span class="t">Speed because the gpu is very fast at computing operations than it is at copying</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3962" target="_blank">01:06:02.820</a></span> | <span class="t">Maybe just recomputing them is faster than copying them</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3966" target="_blank">01:06:06.100</a></span> | <span class="t">So this is the reference in the paper in which they describe this technique</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3969" target="_blank">01:06:09.780</a></span> | <span class="t">So they say finally we must also avoid saving the intermediate states which are necessary for back propagation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3975" target="_blank">01:06:15.380</a></span> | <span class="t">So the intermediate states are all the activations of all the nodes of this computation graph</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3980" target="_blank">01:06:20.420</a></span> | <span class="t">So we carefully apply the classic technique of recomputation to reduce the memory requirements. So the intermediate states are not stored</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3987" target="_blank">01:06:27.140</a></span> | <span class="t">They are not stored in the high bandwidth memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3989" target="_blank">01:06:29.780</a></span> | <span class="t">But recomputed during the backward pass when the inputs are loaded from the high bandwidth memory to the fast RAM</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=3995" target="_blank">01:06:35.380</a></span> | <span class="t">So basically it's faster to just redo the calculations again instead of copying this information to the high band memory and then</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4002" target="_blank">01:06:42.340</a></span> | <span class="t">Reloading it from high bandwidth memory to the fast memory</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4008" target="_blank">01:06:48.820</a></span> | <span class="t">Now let's look at the block that makes up Mamba in the Mamba architecture</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4013" target="_blank">01:06:53.860</a></span> | <span class="t">So first I introduce what is the Mamba block and then we will show you all the Mamba architecture</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4018" target="_blank">01:06:58.360</a></span> | <span class="t">So Mamba is built by stacking multiple layers of this Mamba block that we can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4023" target="_blank">01:07:03.620</a></span> | <span class="t">And this is very similar to the stacked layer of the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4027" target="_blank">01:07:07.140</a></span> | <span class="t">So if you remember the transformer model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4028" target="_blank">01:07:08.660</a></span> | <span class="t">We have the encoder and the decoder and the encoder side and the decoder sides are made by stacking these blocks</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4036" target="_blank">01:07:16.420</a></span> | <span class="t">with the self-attention and the feed forward the network</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4039" target="_blank">01:07:19.220</a></span> | <span class="t">multiple times on top of the other such that the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4042" target="_blank">01:07:22.500</a></span> | <span class="t">Output of the one block is sent as input to the next block and the output of the last block is sent to the output</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4049" target="_blank">01:07:29.380</a></span> | <span class="t">Of the model and this is exactly what we do with Mamba in which we create</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4053" target="_blank">01:07:33.620</a></span> | <span class="t">First of all, we have our input which will be sent to this block and this block will be repeated many times such that the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4061" target="_blank">01:07:41.060</a></span> | <span class="t">Output of this block here will become the input of the next block</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4066" target="_blank">01:07:46.420</a></span> | <span class="t">At the beginning of this block we have a linear layer two linear layers that convert the size</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4072" target="_blank">01:07:52.180</a></span> | <span class="t">D model into d inner as least this is how they call it in the code</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4076" target="_blank">01:07:56.740</a></span> | <span class="t">So d model is the size of the vector of our embedding. So imagine we have an embedding size of 512</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4083" target="_blank">01:08:03.620</a></span> | <span class="t">This is d model and the d inner can be chosen. You can choose for example double the size of the d model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4090" target="_blank">01:08:10.180</a></span> | <span class="t">And this is just a linear projection</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4093" target="_blank">01:08:13.460</a></span> | <span class="t">Then they have a convolution here on this branch and this is actually</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4096" target="_blank">01:08:16.820</a></span> | <span class="t">To mix up kind of the tokens with each other because otherwise the state space model they will be running independently</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4104" target="_blank">01:08:24.040</a></span> | <span class="t">For each dimension, but this convolution makes up all these dimensions</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4108" target="_blank">01:08:28.520</a></span> | <span class="t">And then we have these two silo activations. We have the state space</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4113" target="_blank">01:08:33.060</a></span> | <span class="t">Model here that runs the recurrence using the parallel scan algorithm that I have just shown you before</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4120" target="_blank">01:08:40.660</a></span> | <span class="t">and then we will multiply element wise product of this branch and the output of the state space model then the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4127" target="_blank">01:08:47.140</a></span> | <span class="t">Linear, there is another linear layer that will project back the d inner</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4130" target="_blank">01:08:50.980</a></span> | <span class="t">So the inner dimension of this block to the outer dimension, which is the d model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4135" target="_blank">01:08:55.140</a></span> | <span class="t">So we go back to the 512 dimensions of the embedding size initially if we have chosen the model equal to 512</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4142" target="_blank">01:09:02.120</a></span> | <span class="t">Now let's see the entire architecture of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4147" target="_blank">01:09:07.380</a></span> | <span class="t">And I drew this architecture by myself by analyzing the code so I didn't have time to make it very beautiful</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4153" target="_blank">01:09:13.380</a></span> | <span class="t">But okay, it's very similar to what we do with the transformer. So we have our input it gets converted into embeddings</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4160" target="_blank">01:09:20.360</a></span> | <span class="t">So it becomes a sequence of tokens each token made up of an embedding of size. Let's say 512</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4166" target="_blank">01:09:26.680</a></span> | <span class="t">And then we have many blocks like this one after another</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4171" target="_blank">01:09:31.780</a></span> | <span class="t">We have n of them such that the output of one block is sent as input to the next one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4176" target="_blank">01:09:36.660</a></span> | <span class="t">And the mama block that I show you in the previous slide is basically just this one</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4181" target="_blank">01:09:41.940</a></span> | <span class="t">But they also include a rms norm at the beginning and then a skip connection</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4186" target="_blank">01:09:46.900</a></span> | <span class="t">You can see here and this is repeated n times</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4190" target="_blank">01:09:50.420</a></span> | <span class="t">finally, there is an rms norm just like</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4193" target="_blank">01:09:53.060</a></span> | <span class="t">Lama and just like mistral because we have this rms norm and then we have the linear layer that will project the output embedding</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4200" target="_blank">01:10:00.580</a></span> | <span class="t">back into our vocabulary and then we have a softmax to choose the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4204" target="_blank">01:10:04.260</a></span> | <span class="t">Which will indicate which token from our vocabulary</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4208" target="_blank">01:10:08.600</a></span> | <span class="t">We need to choose as the next token if we are modeling a language model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4213" target="_blank">01:10:13.380</a></span> | <span class="t">and this is the architecture of</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4216" target="_blank">01:10:16.420</a></span> | <span class="t">of mamba guys</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4218" target="_blank">01:10:18.020</a></span> | <span class="t">So let's look also at the performance</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4220" target="_blank">01:10:20.500</a></span> | <span class="t">So as you remember at the initial when we started talking about mamba mamba was introduced to solve the problems of the selecting</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4227" target="_blank">01:10:27.300</a></span> | <span class="t">selective copying task and the induction task because</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4230" target="_blank">01:10:30.260</a></span> | <span class="t">we saw that the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4233" target="_blank">01:10:33.060</a></span> | <span class="t">State space models were not performing very well in</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4235" target="_blank">01:10:35.780</a></span> | <span class="t">context aware reasoning</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4238" target="_blank">01:10:38.180</a></span> | <span class="t">So they wanted to solve this problem with mamba by using they introduced that's why they introduced the selective state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4244" target="_blank">01:10:44.740</a></span> | <span class="t">with their selective scan algorithm</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4247" target="_blank">01:10:47.720</a></span> | <span class="t">And we can see that the state space model. So the s4 model. So the structural space space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4255" target="_blank">01:10:55.780</a></span> | <span class="t">Performs quite poorly on this selective copying but mamba performs very well</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4260" target="_blank">01:11:00.580</a></span> | <span class="t">So it has a 99.8%</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4262" target="_blank">01:11:02.900</a></span> | <span class="t">Of accuracy and the mamba basically this layer here is called the s6 layer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4269" target="_blank">01:11:09.540</a></span> | <span class="t">And the s4 layer is the one described in the previous paper. So structure state space model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4274" target="_blank">01:11:14.340</a></span> | <span class="t">While on the induction heads we can see that also mamba is performing very well</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4279" target="_blank">01:11:19.780</a></span> | <span class="t">So the accuracy of mamba you can see here is always</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4283" target="_blank">01:11:23.700</a></span> | <span class="t">Nearly 100% actually it's 100% for sequence length that can reach 10 to the power of 6</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4289" target="_blank">01:11:29.620</a></span> | <span class="t">So very very very very very long sequence length in comparison</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4293" target="_blank">01:11:33.380</a></span> | <span class="t">For example, the transformer model with the absolute positional encoding or also rotary positional encodings</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4298" target="_blank">01:11:38.360</a></span> | <span class="t">Start degrading in accuracy when the sequence length reaches a certain size</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4303" target="_blank">01:11:43.060</a></span> | <span class="t">And so they are very quite good up to a few hundred tokens</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4309" target="_blank">01:11:49.860</a></span> | <span class="t">But they start degrading as soon as they reach the thousands of tokens, but mamba maintains a very</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4315" target="_blank">01:11:55.540</a></span> | <span class="t">Consistent performance over even very long sequence length and this is very important for language modeling because</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4322" target="_blank">01:12:02.180</a></span> | <span class="t">The prompts especially with the retrieval augmented generation, but also with chat applications, etc</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4326" target="_blank">01:12:06.980</a></span> | <span class="t">They are becoming very long. So we want models that can perform well on very very long sequence</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4332" target="_blank">01:12:12.420</a></span> | <span class="t">And we can also see here that the model</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4337" target="_blank">01:12:17.280</a></span> | <span class="t">Performance so the number of operations that we need to do to train a model to reach a certain perplexity</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4343" target="_blank">01:12:23.460</a></span> | <span class="t">Is very comparable with the transformer</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4346" target="_blank">01:12:26.800</a></span> | <span class="t">So mamba actually performs as good as the best transformer model that we have now</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4352" target="_blank">01:12:32.080</a></span> | <span class="t">So the transformer model like lama and mistral. This is the transformer plus plus you can see here</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4358" target="_blank">01:12:38.560</a></span> | <span class="t">And it performs very similarly to the best model that we have here. So it's a very good</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4365" target="_blank">01:12:45.420</a></span> | <span class="t">Concurrent to the transform, but as we saw in the previous slide it can scale much better for longer sequences</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4370" target="_blank">01:12:50.780</a></span> | <span class="t">And this is why it became quite popular recently</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4373" target="_blank">01:12:53.660</a></span> | <span class="t">Thank you guys for watching my video. I hope you learned a lot in this video</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4377" target="_blank">01:12:57.900</a></span> | <span class="t">I wanted to make a video that was very descriptive and also very</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4382" target="_blank">01:13:02.140</a></span> | <span class="t">Technically in detail because I wanted to derive all the formulations of mamba. I just don't like to throw formulas at people</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4388" target="_blank">01:13:08.620</a></span> | <span class="t">And mamba I think will be a very popular model in the future</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4392" target="_blank">01:13:12.460</a></span> | <span class="t">Even if I think it has its own limitations, for example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4395" target="_blank">01:13:15.180</a></span> | <span class="t">It's still a recurrent neural network because it's still run like a recurrence</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4399" target="_blank">01:13:19.120</a></span> | <span class="t">And it may have its own limitations for for example</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4402" target="_blank">01:13:22.460</a></span> | <span class="t">We still don't know how well it performs on massive amounts of data like data that has been used for lama or for</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4408" target="_blank">01:13:28.940</a></span> | <span class="t">mistral</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4410" target="_blank">01:13:30.780</a></span> | <span class="t">So but I think people are looking for alternatives for the transformer because the transformer has shown its limitations, especially for</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4418" target="_blank">01:13:38.300</a></span> | <span class="t">Scaling to very long sequence length which are very much needed for language modeling</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4423" target="_blank">01:13:43.260</a></span> | <span class="t">But also with recent models for image generation movie generation and audio generation</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4427" target="_blank">01:13:47.920</a></span> | <span class="t">and so</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4430" target="_blank">01:13:50.140</a></span> | <span class="t">also, the computational complexity of the</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4432" target="_blank">01:13:52.700</a></span> | <span class="t">Transformer is massive because the the scaling power is quadratic</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4437" target="_blank">01:13:57.840</a></span> | <span class="t">so it results in a really high memory consumption and that's why</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4442" target="_blank">01:14:02.860</a></span> | <span class="t">People normal people cannot even inference a model like mistral on their computer unless they use the model sharding</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4449" target="_blank">01:14:09.120</a></span> | <span class="t">and very advanced techniques</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4451" target="_blank">01:14:11.580</a></span> | <span class="t">so I hope that</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4454" target="_blank">01:14:14.380</a></span> | <span class="t">More research is done in this area. So thank you for watching my video</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4458" target="_blank">01:14:18.060</a></span> | <span class="t">I hope you like this video and you will subscribe to my channel</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4461" target="_blank">01:14:21.900</a></span> | <span class="t">Please share this video with your friends and share it on your social media. This is the best way to support me</span></div><div class="c"><span class="s"><a href="https://www.youtube.com/watch?v=8Q_tqwpTpVU&t=4467" target="_blank">01:14:27.020</a></span> | <span class="t">Thank you and have a nice day</span></div></div></body></html>