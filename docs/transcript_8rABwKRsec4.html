<html><head><title>The New Code — Sean Grove, OpenAI</title>
<style>
    body {
        font-family: Arial, sans-serif;
        margin: 0;
        padding: 0;
        background-color: #f4f4f4;
        color: #333;
    }
    .container {
        width: 95%;  /* Increased width to use more space */
        margin: auto;
        overflow: auto;  /* Added to handle overflow by adding a scrollbar if necessary */
    }
    h2, h3 {
        color: #333;
        text-align: center;
    }
    a {
        color: #0000FF;  /* Traditional blue color for links */
        text-decoration: none;
    }
    a:hover {
        text-decoration: underline;
    }
    img {
        display: block;
        margin: auto;
        max-width: 100%;
    }
    .c {
        margin: 10px 0;
    }
    .s, .t {
        display: inline-block;
        margin-right: 5px;
    }
    .max-width {
        max-width: 800px;
        margin: auto;
        padding-left: 20px;
    }
    table {
        width: 100%;
        border-collapse: collapse;
    }
    th, td {
        border: 1px solid #ddd;
        padding: 8px;
        text-align: left;  /* Ensure text alignment is consistent */
    }
    tr:nth-child(even) {
        background-color: #f2f2f2;
    }
    tr:nth-child(odd) {
        background-color: #e6e6e6;
    }
</style>

    <!-- Google tag (gtag.js) -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=G-69VLBMTTP0"></script>
    <script>
      window.dataLayer = window.dataLayer || [];
      function gtag(){dataLayer.push(arguments);}
      gtag('js', new Date());

      gtag('config', 'G-69VLBMTTP0');
    </script>
    </head><body><div class='container'><a href="index.html">Back to Index</a><h2>The New Code — Sean Grove, OpenAI</h2><a href="https://www.youtube.com/watch?v=8rABwKRsec4" target="_blank"><img src="https://i.ytimg.com/vi_webp/8rABwKRsec4/maxresdefault.webp" style="width:50%;"></a><div><br></div><h3>Transcript</h3><div class='max-width'><p>Leipzig Reviewer: Peter van de Ven Hello, everyone. Thank you very much for having me. It's a very exciting place to be, a very exciting time to be. I mean, this has been a pretty intense couple of days. I don't know if you feel the same way, but also very energizing.</p><p>So I want to take a little bit of your time today to talk about what I see is the coming of the new code, in particular specifications, which sort of hold this promise. It has been the dream of the industry, where you can write your code, your intentions once, and run them everywhere.</p><p>Quaking Joe, my name is Sean. I work at OpenAI, specifically in alignment research. And today, I want to talk about sort of the value of code versus communication, and why specifications might be a little bit of a better approach in general. I'm going to go over the anatomy of a specification, and we'll use the model spec as the example.</p><p>And we'll talk about communicating intent to other humans. And we'll go over the 4.0 sycophancy issue as a case study. We'll talk about how to make this specification executable, how to communicate intent to the models, and how to think about specifications as code, even if they're a little bit different.</p><p>And we'll end on a couple of open questions. So let's talk about code versus communication. Real quick, raise your hand if you write code, and vibe code counts. Cool. Keep them up if your job is to write code. Okay? Now, for those people, keep their hand up if you feel that the most valuable, professional artifact that you produce is code.</p><p>Okay? There's quite a few people, and I think this is quite natural. We all work very, very hard to solve problems. We talk with people. We gather requirements. We think through implementation details. We integrate with lots of different sources. And the ultimate thing that we produce is code. Code is the artifact that we can point to.</p><p>We can measure. We can debate. And we can discuss. It feels tangible and real. But it's sort of underselling the job that each of you does. Code is sort of 10% to 20% of the value that you bring. The other 80% to 90% is in structured communication. And this is going to be different for everyone, but a process typically looks something like you talk to users in order to understand their challenges.</p><p>You distill these stories down and then ideate about how to solve these problems. What is the goal that you want to achieve? You plan ways to achieve those goals. You share those plans with your colleagues. You translate those plans into code. So this is a very important step, obviously.</p><p>And then you test and verify, not the code itself. Right? No one cares actually about the code itself. What you care is when the code ran, did it achieve the goals? Did it alleviate the challenges of your user? You look at the effects that your code had on the world.</p><p>So talking, understanding, distilling, ideating, planning, sharing, translating, testing, verifying. These all sound like structured communication to me. And structured communication is the bottleneck. Knowing what to build, talking to people and gathering requirements. Knowing how to build it. Knowing why to build it. And at the end of the day, knowing if it has been built correctly and has actually achieved the intentions that you set out with.</p><p>And the more advanced AI models get, the more we are all going to starkly feel this bottleneck. Because in the near future, the person who communicates most effectively is the most valuable programmer. And literally, if you can communicate effectively, you can program. So let's take vibe coding as an illustrative example.</p><p>Vibe coding tends to feel quite good. And it's worth asking, why is that? Well, vibe coding is fundamentally about communication first. And the code is actually a secondary downstream artifact of that communication. We get to describe our intentions and the outcomes that we want to see. And we let the model actually handle the grunt work for us.</p><p>And even so, there is something strange about the way that we do vibe coding. We communicate via prompts to the model. And we tell them our intentions and our values. And we get a code artifact out at the end. And then we sort of throw our prompts away. They're ephemeral.</p><p>And if you've written TypeScript or Rust, once you put your code through a compiler, or it gets down into a binary, no one is happy with that binary. That wasn't the purpose. It's useful. In fact, we always regenerate the binaries from scratch every time we compile or we run our code through V8 or whatever it might be from the source spec.</p><p>It's the source specification that's the valuable artifact. And yet when we prompt elements, we sort of do the opposite. We keep the generated code and we delete the prompt. And this feels like a little bit like you shred the source and then you very carefully version control the binary.</p><p>And that's why it's so important to actually capture the intent and the values in a specification. A written specification is what enables you to align humans on the shared set of goals and to know if you are aligned, if you're actually synchronized on what needs to be done. This is the artifact that you discuss, that you debate, that you refer to, and that you synchronize on.</p><p>And this is really important, so I want to nail this home. That a written specification effectively aligns humans. And it is the artifact that you use to communicate, and to discuss, and debate, and refer to, and synchronize on. If you don't have a specification, you just have a vague idea.</p><p>Now let's talk about why specifications are more powerful in general than code. Because code itself is actually a lossy projection from the specification. In the same way that if you were to take a compiled C binary and decompile it, you wouldn't get nice comments and well-named variables. You would have to work backwards.</p><p>You'd have to infer what was this person trying to do. Why is this code written this way? It isn't actually contained in there. It was a lossy translation. And in the same way, code itself, even nice code, typically doesn't embody all of the intentions and the values in itself.</p><p>You have to infer what is the ultimate goal that this team is trying to achieve when you read through code. So communication, the work that we established, we already do when embodied inside of a written specification is better than code. It actually encodes all of the necessary requirements in order to generate the code.</p><p>And in the same way that having a source code that you pass to a compiler allows you to target multiple different architectures. You can compile for ARM64 or x86 or WebAssembly. The source document actually contains enough information to describe how to translate it to your target architecture. In the same way, a sufficiently robust specification given to models will produce good TypeScript, good Rust, servers, clients, documentation, tutorials, blog posts, and even podcasts.</p><p>A show of hands, who works at a company that has developers as customers? Okay, so a quick thought exercise is if you were to take your entire code base, all of the documentation, or all of the code that runs your business, and you were to put that into a podcast generator, could you generate something that would be sufficiently interesting and compelling that would tell the users how to succeed, how to achieve their goals?</p><p>Or is all of that information somewhere else? It's not actually in your code. And so moving forward, the new scarce skill is writing specifications that fully capture the intent and values. And whoever masters that, again, becomes the most valuable programmer. And there's a reasonable chance that this is going to be the coders of today.</p><p>This is already very similar to what we do. However, product managers also write specifications. Lawmakers write legal specifications. This is actually a universal principle. So with that in mind, let's look at what a specification actually looks like. And I'm going to use the OpenAI model spec as an example here.</p><p>So last year, OpenAI released the model spec. And this is a living document that tries to clearly and unambiguously express the intentions and values that OpenAI hopes to imbue its models with, that it ships to the world. And it was updated in February and open sourced. So you can actually go to GitHub and you can see the implementation of the model spec.</p><p>And surprise, surprise, it's actually just a collection of Markdown files. It just looks like this. Now Markdown is remarkable. It is human readable. It's versioned. It's changelogged. And because it is natural language, everyone, not just technical people, can contribute, including product, legal, safety, research, policy. They can all read, discuss, debate, and contribute to the same source code.</p><p>This is the universal artifact that aligns all of the humans as to our intentions and values inside of the company. Now, as much as we might try to use unambiguous language, there are times where it's very difficult to express the nuance. So every clause in the model spec has an ID here.</p><p>So you can see SY73 here. And using that ID, you can find another file in the repository, SY73.markdown, or MD, that contains one or more challenging prompts for this exact clause. So the document itself actually encodes success criteria, that the model under test has to be able to answer this in a way that actually adheres to that clause.</p><p>So let's talk about sycophancy. Recently, there was an update to 4.0. I don't know if you've heard of this. It caused extreme sycophancy. And we can ask, what value is the model spec in this scenario? And the model spec serves to align humans around a set of values and intentions.</p><p>Here's an example of sycophancy where the user calls out the behavior of being sycophant or sycophantic at the expense of impartial truth. And the model very kindly praises the user for their insight. There have been other esteemed researchers who have found similarly concerning examples. And this hurts. Shipping sycophancy in this manner erodes trust.</p><p>It hurts. So, and it also raises a lot of questions. Like, was this intentional? You can see some way where you might interpret it that way. Was it accidental? And why wasn't it caught? Luckily, the model spec actually includes a section dedicated to this, since its release, that says, "Don't be sycophantic." And it explains that while sycophancy might feel good in the short term, it's bad for everyone in the long term.</p><p>So we actually expressed our intentions and our values and were able to communicate it to others through this. So, people could reference it. And if we have it in the model specification, if the model specification is our agreed-upon set of intentions and values, and the behavior doesn't align with that, then this must be a bug.</p><p>So we rolled back, we published some studies and some blog post, and we fixed it. But in the interim, the spec served as a trust anchor, a way to communicate to people what is expected and what is not expected. So, if the only thing the model specification did was to align humans along those shared sets of intentions and values, it would already be incredibly useful.</p><p>But ideally, we can also align our models and the artifacts that our models produce against that same specification. So there's a technique, a paper that we released, called Deliberative Alignment, that sort of talks about this, how to automatically align a model. And the technique is such where you take your specification and a set of very challenging input prompts, and you sample from the model under a test or training.</p><p>You then take its response, the original prompt and the policy, and you give that to a greater model. And you ask it to score the response according to the specification. How aligned is it? So the document actually becomes both training material and eval material. And based off of the score, we reinforce those weights.</p><p>And it goes from, you know, you could include your specification in the context, and then maybe a system message or developer message, in every single time you sample. And that is actually quite useful. A prompted model is going to be somewhat aligned. But it does detract from the compute available to solve the problem that you're trying to solve with the model.</p><p>And keep in mind, these specifications can be anything. They could be code style, or testing requirements, or safety requirements. All of that can be embedded into the model. So through this technique, you're actually moving it from an inference time compute, and actually you're pushing down into the weights of the model, so that the model actually feels your policy and is able to to sort of muscle memory style apply it to the problem at hand.</p><p>And even though we saw that the model spec is just markdown, it's quite useful to think of it as code. It's quite analogous. These specifications they compose, they're executable, as we've seen. They are testable. They have interfaces where they touch the real world. They can be shipped as modules.</p><p>And whenever you're working on a model spec, there are a lot of similar sort of problem domains. So just like in programming, where you have a type checker, the type checker is meant to ensure consistency. Where if interface A has a dependent module B, they have to be consistent in their understanding of one another.</p><p>So if department A writes a spec, and department B writes a spec, and there is a conflict in there, you want to be able to pull that forward, and maybe block the publication of the specification. As we saw, the policy can actually embody its own unit tests. And you can imagine sort of various linters, where if you're using overly ambiguous language, you're going to confuse humans, and you're going to confuse the model, and the artifacts that you get from that are going to be less satisfactory.</p><p>So specs actually give us a very similar tool chain, but it's targeted at intentions rather than syntax. So let's talk about lawmakers as programmers. The US Constitution is literally a national model specification. It has written text, which is aspirationally, at least clear and unambiguous policy, that we can all refer to.</p><p>And it doesn't mean that we agree with it, but we can refer to it as the current status quo, as the reality. There is a versioned way to make amendments, to bump, and to publish updates to it. There is judicial review, where a grader is effectively grading a situation and seeing how well it aligns with the policy.</p><p>And even though the source policy is meant to be unambiguous, sometimes the world is messy, and maybe you miss part of the distribution, and a case falls through. And in that case, there is a lot of compute spent in judicial review, where you're trying to understand how the law actually applies here.</p><p>And once that's decided, it sets a precedent. And that precedent is effectively an input-output pair that serves as a unit test that disambiguates and reinforces the original policy spec. It has things like a chain of command embedded in it. And the enforcement of this, over time, is a training loop that helps align all of us towards a shared set of intentions and values.</p><p>So this is one artifact that communicates intent, it adjudicates compliance, and it has a way of evolving safely. So it's quite possible that lawmakers will be programmers, or inversely that programmers will be lawmakers in the future. And actually, this is a very universal concept. Programmers are in the business of aligning silicon via code specifications.</p><p>Product managers align teams via product specifications. Lawmakers literally align humans via legal specifications. And everyone in this room, whenever you are doing a prompt, it's a sort of proto-specification. You are in the business of aligning AI models towards a common set of intentions and values. And whether you realize it or not, you are spec authors in this world.</p><p>And specs let you ship faster and safer. Everyone can contribute, and whoever writes the spec, be it a PM, a lawmaker, an engineer, a marketer, is now the programmer. And software engineering has never been about code. Going back to our original question, a lot of you put your hands down when you thought, "Well, actually, the thing I produce is not code." Engineering has never been about this.</p><p>Coding is an incredible skill and a wonderful asset, but it is not the end goal. Engineering is the precise exploration by humans of software solutions to human problems. It's always been this way. We're just moving away from sort of the disparate machine encodings to a unified human encoding of how we actually solve these problems.</p><p>I want to thank Josh for this credit. So I want to ask you, put this in action. Whenever you're working on your next AI feature, start with a specification. What do you actually expect to happen? What's success criteria look like? Debate whether or not it's actually clearly written down and communicated.</p><p>Make the spec executable. Feed the spec to the model, and test against the spec. And there's an interesting question sort of in this world. Given that there's so many parallels between programming and spec authorship, I wonder what does the IDE look like in the future? You know, an integrated development environment.</p><p>And I'd like to think it's something like an integrated thought clarifier, where whenever you're writing your specification, it sort of pulls out the ambiguity and asks you to clarify it. And it really clarifies your thoughts so that you and all human beings can communicate your intent to each other much more effectively and to the models.</p><p>And I have a closing request for help, which is, what is both amenable and in desperate need of specification? This is aligning agent at scale. I love this line of like, then you realize that you never told it what you wanted, and maybe you never fully understood it anyway.</p><p>This is a cry for specification. I love this. I love this. I love this. We have a new agent robustness team that we've started up. So please join us and help us deliver safe AGI for the benefit of all humanity. And thank you. I'm happy to chat. I'm happy to chat.</p><p>I'm happy to chat. Thank you. Thank you. Thank you. Thank you. We'll see you next time.</p></div></div></body></html>